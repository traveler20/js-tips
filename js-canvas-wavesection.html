<!DOCTYPE html>
<html lang="ja">
	<head>
		<meta charset="UTF-8" />
		<meta http-equiv="X-UA-Compatible" content="IE=edge" />
		<meta name="viewport" content="width=device-width, initial-scale=1.0" />
		<title>Document</title>
		<link
			rel="stylesheet"
			type="text/css"
			href="http://coco-factory.jp/ugokuweb/wp-content/themes/ugokuweb/data/move02/5-12/css/reset.css"
		/>
	</head>
	<body>
		<style>
			.wave {
				position: relative;
			}
			.wave p {
				padding: 300px 0;
				text-align: center;
			}
			.wave:nth-child(1) {
				background: #fff;
			}
			.wave:nth-child(2) {
				background: #eee;
			}
			.wave:nth-child(3) {
				background: #43c0e4;
			}
			.wave canvas {
				position: absolute;
				bottom: 0;
				left: 0;
				width: 100%;
			}
		</style>
		<div>
			<div class="wave">
				<p>コンテンツが入ります。</p>
				<canvas id="waveCanvas"></canvas>
			</div>
			<div class="wave">
				<p>コンテンツが入ります。</p>
				<canvas id="waveCanvas2"></canvas>
			</div>
			<div class="wave">
				<p>コンテンツが入ります。</p>
				<canvas id="waveCanvas3"></canvas>
			</div>
			<!--/wrapper-->
		</div>
		<script>
			let unit = 100,
				canvasList, // キャンバスの配列
				info = {}, // 全キャンバス共通の描画情報
				colorList; // 各キャンバスの色情報

			/**
			 * Init function.
			 *
			 * Initialize variables and begin the animation.
			 */
			function init() {
				info.seconds = 0;
				info.t = 0;
				canvasList = [];
				colorList = [];
				// canvas1個めの色指定
				canvasList.push(document.getElementById("waveCanvas"));
				colorList.push(["#eee"]);

				// canvas2個めの色指定
				canvasList.push(document.getElementById("waveCanvas2"));
				colorList.push(["#43c0e4"]);

				// canvas3個めの色指定
				canvasList.push(document.getElementById("waveCanvas3"));
				colorList.push(["#fff"]);
				// 各キャンバスの初期化
				for (const canvasIndex in canvasList) {
					const canvas = canvasList[canvasIndex];
					canvas.width = document.documentElement.clientWidth; //Canvasのwidthをウィンドウの幅に合わせる
					canvas.height = 200; //波の高さ
					canvas.contextCache = canvas.getContext("2d");
				}
				// 共通の更新処理呼び出し
				update();
			}

			function update() {
				for (const canvasIndex in canvasList) {
					const canvas = canvasList[canvasIndex];
					// 各キャンバスの描画
					draw(canvas, colorList[canvasIndex]);
				}
				// 共通の描画情報の更新
				info.seconds = info.seconds + 0.014;
				info.t = info.seconds * Math.PI;
				// 自身の再起呼び出し
				setTimeout(update, 35);
			}

			/**
			 * Draw animation function.
			 *
			 * This function draws one frame of the animation, waits 20ms, and then calls
			 * itself again.
			 */
			function draw(canvas, color) {
				// 対象のcanvasのコンテキストを取得
				const context = canvas.contextCache;
				// キャンバスの描画をクリア
				context.clearRect(0, 0, canvas.width, canvas.height);

				//波を描画 drawWave(canvas, color[数字（波の数を0から数えて指定）], 透過, 波の幅のzoom,波の開始位置の遅れ )
				drawWave(canvas, color[0], 1, 3, 0);
			}

			/**
			 * 波を描画
			 * drawWave(色, 不透明度, 波の幅のzoom, 波の開始位置の遅れ)
			 */
			function drawWave(canvas, color, alpha, zoom, delay) {
				const context = canvas.contextCache;
				context.fillStyle = color; //塗りの色
				context.globalAlpha = alpha;
				context.beginPath(); //パスの開始
				drawSine(canvas, info.t / 0.5, zoom, delay);
				context.lineTo(canvas.width + 10, canvas.height); //パスをCanvasの右下へ
				context.lineTo(0, canvas.height); //パスをCanvasの左下へ
				context.closePath(); //パスを閉じる
				context.fill(); //波を塗りつぶす
			}

			/**
			 * Function to draw sine
			 *
			 * The sine curve is drawn in 10px segments starting at the origin.
			 * drawSine(時間, 波の幅のzoom, 波の開始位置の遅れ)
			 */
			function drawSine(canvas, t, zoom, delay) {
				const xAxis = Math.floor(canvas.height / 2);
				const yAxis = 0;
				const context = canvas.contextCache;
				// Set the initial x and y, starting at 0,0 and translating to the origin on
				// the canvas.
				// 時間を横の位置とする
				let x = t;
				let y = Math.sin(x) / zoom;
				// スタート位置にパスを置く
				context.moveTo(yAxis, unit * y + xAxis);

				// Loop to draw segments (横幅の分、波を描画)
				for (i = yAxis; i <= canvas.width + 10; i += 10) {
					x = t + (-yAxis + i) / unit / zoom;
					y = Math.sin(x - delay) / 3;
					context.lineTo(i, unit * y + xAxis);
				}
			}

			init();
		</script>
	</body>
</html>
