<!DOCTYPE html>
<html lang="ja">
	<head>
		<meta charset="UTF-8" />
		<meta http-equiv="X-UA-Compatible" content="IE=edge" />
		<meta name="viewport" content="width=device-width, initial-scale=1.0" />
		<title>Document</title>
	</head>
	<body>
		<div id="coverBlack"></div>
		<script>
			(() => {
				var t = {
						401: (t, e, n) => {
							"use strict";
							n.d(e, { Z: () => o });
							var i = n(645),
								r = n.n(i)()(function (t) {
									return t[1];
								});
							r.push([
								t.id,
								"html {\n  touch-action: none;\n}\n\nbody {\n  margin: 0;\n  padding: 0;\n  overflow: hidden;\n  background: #000000;\n}\n\n#coverBlack {\n  position: absolute;\n  top: 0;\n  left: 0;\n  z-index: 1;\n  width: 100%;\n  height: 100%;\n  opacity: 1;\n  background: #000000;\n}\n",
								"",
							]);
							const o = r;
						},
						645: (t) => {
							"use strict";
							t.exports = function (t) {
								var e = [];
								return (
									(e.toString = function () {
										return this.map(function (e) {
											var n = t(e);
											return e[2]
												? "@media ".concat(e[2], " {").concat(n, "}")
												: n;
										}).join("");
									}),
									(e.i = function (t, n, i) {
										"string" == typeof t && (t = [[null, t, ""]]);
										var r = {};
										if (i)
											for (var o = 0; o < this.length; o++) {
												var a = this[o][0];
												null != a && (r[a] = !0);
											}
										for (var s = 0; s < t.length; s++) {
											var c = [].concat(t[s]);
											(i && r[c[0]]) ||
												(n &&
													(c[2]
														? (c[2] = "".concat(n, " and ").concat(c[2]))
														: (c[2] = n)),
												e.push(c));
										}
									}),
									e
								);
							};
						},
						276: function (t, e) {
							!(function (t) {
								"use strict";
								var e = /[achlmqstvz]|(-?\d*\.?\d*(?:e[\-+]?\d+)?)[0-9]/gi,
									n = /(?:(-)?\d*\.?\d*(?:e[\-+]?\d+)?)[0-9]/gi,
									i = /[\+\-]?\d*\.?\d+e[\+\-]?\d+/gi,
									r = /(^[#\.][a-z]|[a-y][a-z])/i,
									o = Math.PI / 180,
									a = 180 / Math.PI,
									s = Math.sin,
									c = Math.cos,
									l = Math.abs,
									h = Math.sqrt,
									p = Math.atan2,
									u = 1e8,
									d = function (t) {
										return "string" == typeof t;
									},
									m = function (t) {
										return "number" == typeof t;
									},
									f = {},
									g = {},
									S = 1e5,
									y = function (t) {
										return Math.round(((t + u) % 1) * S) / S || (t < 0 ? 0 : 1);
									},
									V = function (t) {
										return Math.round(t * S) / S || 0;
									},
									q = function (t) {
										return Math.round(1e10 * t) / 1e10 || 0;
									},
									R = function (t, e, n, i) {
										var r = t[e],
											o = 1 === i ? 6 : T(r, n, i);
										if (o && o + n + 2 < r.length)
											return (
												t.splice(e, 0, r.slice(0, n + o + 2)),
												r.splice(0, n + o),
												1
											);
									},
									M = function (t, e) {
										return (
											(e.totalLength = t.totalLength),
											t.samples
												? ((e.samples = t.samples.slice(0)),
												  (e.lookup = t.lookup.slice(0)),
												  (e.minLength = t.minLength),
												  (e.resolution = t.resolution))
												: t.totalPoints && (e.totalPoints = t.totalPoints),
											e
										);
									},
									I = function (t, e) {
										var n = t.length,
											i = t[n - 1] || [],
											r = i.length;
										n &&
											e[0] === i[r - 2] &&
											e[1] === i[r - 1] &&
											((e = i.concat(e.slice(2))), n--),
											(t[n] = e);
									};
								function v(t) {
									var e,
										n = (t =
											(d(t) && r.test(t) && document.querySelector(t)) || t)
											.getAttribute
											? t
											: 0;
									return n && (t = t.getAttribute("d"))
										? (n._gsPath || (n._gsPath = {}),
										  (e = n._gsPath[t]) && !e._dirty
												? e
												: (n._gsPath[t] = F(t)))
										: t
										? d(t)
											? F(t)
											: m(t[0])
											? [t]
											: t
										: console.warn(
												"Expecting a <path> element or an SVG path data string"
										  );
								}
								function k(t) {
									var e,
										n = 0;
									for (t.reverse(); n < t.length; n += 2)
										(e = t[n]), (t[n] = t[n + 1]), (t[n + 1] = e);
									t.reversed = !t.reversed;
								}
								var U = {
									rect: "rx,ry,x,y,width,height",
									circle: "r,cx,cy",
									ellipse: "rx,ry,cx,cy",
									line: "x1,x2,y1,y2",
								};
								function w(t, e) {
									var i,
										r,
										o,
										a,
										s,
										c,
										l,
										h,
										p,
										u,
										d,
										m,
										f,
										g,
										S,
										y,
										V,
										q,
										R,
										M,
										I,
										v,
										k = t.tagName.toLowerCase(),
										w = 0.552284749831;
									return "path" !== k && t.getBBox
										? ((c = (function (t, e) {
												var n,
													i = document.createElementNS(
														"http://www.w3.org/2000/svg",
														"path"
													),
													r = [].slice.call(t.attributes),
													o = r.length;
												for (e = "," + e + ","; --o > -1; )
													(n = r[o].nodeName.toLowerCase()),
														e.indexOf("," + n + ",") < 0 &&
															i.setAttributeNS(null, n, r[o].nodeValue);
												return i;
										  })(
												t,
												"x,y,width,height,cx,cy,rx,ry,r,x1,x2,y1,y2,points"
										  )),
										  (v = (function (t, e) {
												for (
													var n = e ? e.split(",") : [], i = {}, r = n.length;
													--r > -1;

												)
													i[n[r]] = +t.getAttribute(n[r]) || 0;
												return i;
										  })(t, U[k])),
										  "rect" === k
												? ((a = v.rx),
												  (s = v.ry || a),
												  (r = v.x),
												  (o = v.y),
												  (u = v.width - 2 * a),
												  (d = v.height - 2 * s),
												  (i =
														a || s
															? "M" +
															  (y = (g = (f = r + a) + u) + a) +
															  "," +
															  (q = o + s) +
															  " V" +
															  (R = q + d) +
															  " C" +
															  [
																	y,
																	(M = R + s * w),
																	(S = g + a * w),
																	(I = R + s),
																	g,
																	I,
																	g - (g - f) / 3,
																	I,
																	f + (g - f) / 3,
																	I,
																	f,
																	I,
																	(m = r + a * (1 - w)),
																	I,
																	r,
																	M,
																	r,
																	R,
																	r,
																	R - (R - q) / 3,
																	r,
																	q + (R - q) / 3,
																	r,
																	q,
																	r,
																	(V = o + s * (1 - w)),
																	m,
																	o,
																	f,
																	o,
																	f + (g - f) / 3,
																	o,
																	g - (g - f) / 3,
																	o,
																	g,
																	o,
																	S,
																	o,
																	y,
																	V,
																	y,
																	q,
															  ].join(",") +
															  "z"
															: "M" +
															  (r + u) +
															  "," +
															  o +
															  " v" +
															  d +
															  " h" +
															  -u +
															  " v" +
															  -d +
															  " h" +
															  u +
															  "z"))
												: "circle" === k || "ellipse" === k
												? ("circle" === k
														? (h = (a = s = v.r) * w)
														: ((a = v.rx), (h = (s = v.ry) * w)),
												  (i =
														"M" +
														((r = v.cx) + a) +
														"," +
														(o = v.cy) +
														" C" +
														[
															r + a,
															o + h,
															r + (l = a * w),
															o + s,
															r,
															o + s,
															r - l,
															o + s,
															r - a,
															o + h,
															r - a,
															o,
															r - a,
															o - h,
															r - l,
															o - s,
															r,
															o - s,
															r + l,
															o - s,
															r + a,
															o - h,
															r + a,
															o,
														].join(",") +
														"z"))
												: "line" === k
												? (i =
														"M" + v.x1 + "," + v.y1 + " L" + v.x2 + "," + v.y2)
												: ("polyline" !== k && "polygon" !== k) ||
												  ((i =
														"M" +
														(r = (p =
															(t.getAttribute("points") + "").match(n) ||
															[]).shift()) +
														"," +
														(o = p.shift()) +
														" L" +
														p.join(",")),
												  "polygon" === k && (i += "," + r + "," + o + "z")),
										  c.setAttribute("d", N((c._gsRawPath = F(i)))),
										  e &&
												t.parentNode &&
												(t.parentNode.insertBefore(c, t),
												t.parentNode.removeChild(t)),
										  c)
										: t;
								}
								function x(t, e, n) {
									var i,
										r = t[e],
										o = t[e + 2],
										s = t[e + 4];
									return (
										(r += (o - r) * n),
										(r += ((o += (s - o) * n) - r) * n),
										(i = o + (s + (t[e + 6] - s) * n - o) * n - r),
										(r = t[e + 1]),
										(r += ((o = t[e + 3]) - r) * n),
										(r += ((o += ((s = t[e + 5]) - o) * n) - r) * n),
										V(p(o + (s + (t[e + 7] - s) * n - o) * n - r, i) * a)
									);
								}
								function O(t, e, n) {
									(n = void 0 === n ? 1 : q(n) || 0), (e = q(e) || 0);
									var i = Math.max(0, ~~(l(n - e) - 1e-8)),
										r = (function (t) {
											for (var e = [], n = 0; n < t.length; n++)
												e[n] = M(t[n], t[n].slice(0));
											return M(t, e);
										})(t);
									if (
										(e > n &&
											((e = 1 - e),
											(n = 1 - n),
											(function (t, e) {
												var n = t.length;
												for (e || t.reverse(); n--; ) t[n].reversed || k(t[n]);
											})(r),
											(r.totalLength = 0)),
										e < 0 || n < 0)
									) {
										var o = Math.abs(~~Math.min(e, n)) + 1;
										(e += o), (n += o);
									}
									r.totalLength || K(r);
									var a,
										s,
										c,
										h,
										p,
										u,
										d,
										m,
										S = n > 1,
										y = z(r, e, f, !0),
										V = z(r, n, g),
										v = V.segment,
										U = y.segment,
										w = V.segIndex,
										O = y.segIndex,
										b = V.i,
										W = y.i,
										E = O === w,
										C = b === W && E;
									if (S || i) {
										for (
											a = w < O || (E && b < W) || (C && V.t < y.t),
												R(r, O, W, y.t) &&
													(O++,
													a ||
														(w++,
														C
															? ((V.t = (V.t - y.t) / (1 - y.t)), (b = 0))
															: E && (b -= W))),
												1 - (n - e) < 1e-5
													? (w = O - 1)
													: !V.t && w
													? w--
													: R(r, w, b, V.t) && a && O++,
												1 === y.t && (O = (O + 1) % r.length),
												p = [],
												d = 1 + (u = r.length) * i,
												m = O,
												d += (u - O + w) % u,
												h = 0;
											h < d;
											h++
										)
											I(p, r[m++ % u]);
										r = p;
									} else if (((c = 1 === V.t ? 6 : T(v, b, V.t)), e !== n))
										for (
											s = T(U, W, C ? y.t / V.t : y.t),
												E && (c += s),
												v.splice(b + c + 2),
												(s || W) && U.splice(0, W + s),
												h = r.length;
											h--;

										)
											(h < O || h > w) && r.splice(h, 1);
									else
										(v.angle = x(v, b + c, 0)),
											(y = v[(b += c)]),
											(V = v[b + 1]),
											(v.length = v.totalLength = 0),
											(v.totalPoints = r.totalPoints = 8),
											v.push(y, V, y, V, y, V, y, V);
									return (r.totalLength = 0), r;
								}
								function b(t, e, n) {
									(e = e || 0),
										t.samples || ((t.samples = []), (t.lookup = []));
									var i,
										r,
										o,
										a,
										s,
										c,
										p,
										d,
										m,
										f,
										g,
										S,
										y,
										V,
										q,
										R,
										M,
										I = ~~t.resolution || 12,
										v = 1 / I,
										k = n ? e + 6 * n + 1 : t.length,
										U = t[e],
										w = t[e + 1],
										x = e ? (e / 6) * I : 0,
										O = t.samples,
										b = t.lookup,
										K = (e ? t.minLength : u) || u,
										T = O[x + n * I - 1],
										z = e ? O[x - 1] : 0;
									for (O.length = b.length = 0, r = e + 2; r < k; r += 6) {
										if (
											((o = t[r + 4] - U),
											(a = t[r + 2] - U),
											(s = t[r] - U),
											(d = t[r + 5] - w),
											(m = t[r + 3] - w),
											(f = t[r + 1] - w),
											(c = p = g = S = 0),
											l(o) < 1e-5 && l(d) < 1e-5 && l(s) + l(f) < 1e-5)
										)
											t.length > 8 && (t.splice(r, 6), (r -= 6), (k -= 6));
										else
											for (i = 1; i <= I; i++)
												(c =
													p -
													(p =
														((V = v * i) * V * o +
															3 * (y = 1 - V) * (V * a + y * s)) *
														V)),
													(g =
														S -
														(S = (V * V * d + 3 * y * (V * m + y * f)) * V)),
													(R = h(g * g + c * c)) < K && (K = R),
													(z += R),
													(O[x++] = z);
										(U += o), (w += d);
									}
									if (T) for (T -= z; x < O.length; x++) O[x] += T;
									if (O.length && K)
										for (
											t.totalLength = M = O[O.length - 1] || 0,
												t.minLength = K,
												R = q = 0,
												i = 0;
											i < M;
											i += K
										)
											b[R++] = O[q] < i ? ++q : q;
									else t.totalLength = O[0] = 0;
									return e ? z - O[e / 2 - 1] : z;
								}
								function K(t, e) {
									var n, i, r;
									for (r = n = i = 0; r < t.length; r++)
										(t[r].resolution = ~~e || 12),
											(i += t[r].length),
											(n += b(t[r]));
									return (t.totalPoints = i), (t.totalLength = n), t;
								}
								function T(t, e, n) {
									if (n <= 0 || n >= 1) return 0;
									var i = t[e],
										r = t[e + 1],
										o = t[e + 2],
										a = t[e + 3],
										s = t[e + 4],
										c = t[e + 5],
										l = i + (o - i) * n,
										h = o + (s - o) * n,
										p = r + (a - r) * n,
										u = a + (c - a) * n,
										d = l + (h - l) * n,
										m = p + (u - p) * n,
										f = s + (t[e + 6] - s) * n,
										g = c + (t[e + 7] - c) * n;
									return (
										(h += (f - h) * n),
										(u += (g - u) * n),
										t.splice(
											e + 2,
											4,
											V(l),
											V(p),
											V(d),
											V(m),
											V(d + (h - d) * n),
											V(m + (u - m) * n),
											V(h),
											V(u),
											V(f),
											V(g)
										),
										t.samples &&
											t.samples.splice(
												((e / 6) * t.resolution) | 0,
												0,
												0,
												0,
												0,
												0,
												0,
												0
											),
										6
									);
								}
								function z(t, e, n, i) {
									(n = n || {}),
										t.totalLength || K(t),
										(e < 0 || e > 1) && (e = y(e));
									var r,
										o,
										a,
										s,
										c,
										l,
										h,
										p = 0,
										u = t[0];
									if (e)
										if (1 === e)
											(h = 1), (l = (u = t[(p = t.length - 1)]).length - 8);
										else {
											if (t.length > 1) {
												for (
													a = t.totalLength * e, c = l = 0;
													(c += t[l++].totalLength) < a;

												)
													p = l;
												e =
													(a - (s = c - (u = t[p]).totalLength)) / (c - s) || 0;
											}
											(r = u.samples),
												(o = u.resolution),
												(a = u.totalLength * e),
												(s = (l = u.lookup[~~(a / u.minLength)] || 0)
													? r[l - 1]
													: 0),
												(c = r[l]) < a && ((s = c), (c = r[++l])),
												(h = (1 / o) * ((a - s) / (c - s) + (l % o))),
												(l = 6 * ~~(l / o)),
												i &&
													1 === h &&
													(l + 6 < u.length
														? ((l += 6), (h = 0))
														: p + 1 < t.length && ((l = h = 0), (u = t[++p])));
										}
									else (h = l = p = 0), (u = t[0]);
									return (
										(n.t = h),
										(n.i = l),
										(n.path = t),
										(n.segment = u),
										(n.segIndex = p),
										n
									);
								}
								function W(t, e, n, i) {
									var r,
										o,
										a,
										s,
										c,
										l,
										h,
										p,
										u,
										d = t[0],
										m = i || {};
									if (((e < 0 || e > 1) && (e = y(e)), t.length > 1)) {
										for (
											a = t.totalLength * e, c = l = 0;
											(c += t[l++].totalLength) < a;

										)
											d = t[l];
										e = (a - (s = c - d.totalLength)) / (c - s) || 0;
									}
									return (
										(r = d.samples),
										(o = d.resolution),
										(a = d.totalLength * e),
										(s = (l =
											d.lookup[
												e < 1 ? ~~(a / d.minLength) : d.lookup.length - 1
											] || 0)
											? r[l - 1]
											: 0),
										(c = r[l]) < a && ((s = c), (c = r[++l])),
										(u =
											1 - (h = (1 / o) * ((a - s) / (c - s) + (l % o)) || 0)),
										(p = d[(l = 6 * ~~(l / o))]),
										(m.x = V(
											(h * h * (d[l + 6] - p) +
												3 * u * (h * (d[l + 4] - p) + u * (d[l + 2] - p))) *
												h +
												p
										)),
										(m.y = V(
											(h * h * (d[l + 7] - (p = d[l + 1])) +
												3 * u * (h * (d[l + 5] - p) + u * (d[l + 3] - p))) *
												h +
												p
										)),
										n &&
											(m.angle = d.totalLength
												? x(d, l, h >= 1 ? 1 - 1e-9 : h || 1e-9)
												: d.angle || 0),
										m
									);
								}
								function E(t, e, n, i, r, o, a) {
									for (var s, c, l, h, p, u = t.length; --u > -1; )
										for (c = (s = t[u]).length, l = 0; l < c; l += 2)
											(h = s[l]),
												(p = s[l + 1]),
												(s[l] = h * e + p * i + o),
												(s[l + 1] = h * n + p * r + a);
									return (t._dirty = 1), t;
								}
								function C(t, e, n, i, r, a, p, u, d) {
									if (t !== u || e !== d) {
										(n = l(n)), (i = l(i));
										var m = (r % 360) * o,
											f = c(m),
											g = s(m),
											S = Math.PI,
											y = 2 * S,
											V = (t - u) / 2,
											q = (e - d) / 2,
											R = f * V + g * q,
											M = -g * V + f * q,
											I = R * R,
											v = M * M,
											k = I / (n * n) + v / (i * i);
										k > 1 && ((n = h(k) * n), (i = h(k) * i));
										var U = n * n,
											w = i * i,
											x = (U * w - U * v - w * I) / (U * v + w * I);
										x < 0 && (x = 0);
										var O = (a === p ? -1 : 1) * h(x),
											b = O * ((n * M) / i),
											K = O * ((-i * R) / n),
											T = (t + u) / 2 + (f * b - g * K),
											z = (e + d) / 2 + (g * b + f * K),
											W = (R - b) / n,
											E = (M - K) / i,
											C = (-R - b) / n,
											F = (-M - K) / i,
											Z = W * W + E * E,
											H = (E < 0 ? -1 : 1) * Math.acos(W / h(Z)),
											N =
												(W * F - E * C < 0 ? -1 : 1) *
												Math.acos((W * C + E * F) / h(Z * (C * C + F * F)));
										isNaN(N) && (N = S),
											!p && N > 0 ? (N -= y) : p && N < 0 && (N += y),
											(H %= y),
											(N %= y);
										var j,
											D = Math.ceil(l(N) / (y / 4)),
											A = [],
											L = N / D,
											B = ((4 / 3) * s(L / 2)) / (1 + c(L / 2)),
											G = f * n,
											Q = g * n,
											_ = g * -i,
											P = f * i;
										for (j = 0; j < D; j++)
											(R = c((r = H + j * L))),
												(M = s(r)),
												(W = c((r += L))),
												(E = s(r)),
												A.push(
													R - B * M,
													M + B * R,
													W + B * E,
													E - B * W,
													W,
													E
												);
										for (j = 0; j < A.length; j += 2)
											(R = A[j]),
												(M = A[j + 1]),
												(A[j] = R * G + M * _ + T),
												(A[j + 1] = R * Q + M * P + z);
										return (A[j - 2] = u), (A[j - 1] = d), A;
									}
								}
								function F(t) {
									var n,
										r,
										o,
										a,
										s,
										c,
										h,
										p,
										u,
										d,
										m,
										f,
										g,
										S,
										y,
										V =
											(t + "")
												.replace(i, function (t) {
													var e = +t;
													return e < 1e-4 && e > -1e-4 ? 0 : e;
												})
												.match(e) || [],
										q = [],
										R = 0,
										M = 0,
										I = 2 / 3,
										v = V.length,
										k = 0,
										U = "ERROR: malformed path: " + t,
										w = function (t, e, n, i) {
											(d = (n - t) / 3),
												(m = (i - e) / 3),
												h.push(t + d, e + m, n - d, i - m, n, i);
										};
									if (!t || !isNaN(V[0]) || isNaN(V[1]))
										return console.log(U), q;
									for (n = 0; n < v; n++)
										if (
											((g = s),
											isNaN(V[n])
												? (c = (s = V[n].toUpperCase()) !== V[n])
												: n--,
											(o = +V[n + 1]),
											(a = +V[n + 2]),
											c && ((o += R), (a += M)),
											n || ((p = o), (u = a)),
											"M" === s)
										)
											h && (h.length < 8 ? (q.length -= 1) : (k += h.length)),
												(R = p = o),
												(M = u = a),
												(h = [o, a]),
												q.push(h),
												(n += 2),
												(s = "L");
										else if ("C" === s)
											h || (h = [0, 0]),
												c || (R = M = 0),
												h.push(
													o,
													a,
													R + 1 * V[n + 3],
													M + 1 * V[n + 4],
													(R += 1 * V[n + 5]),
													(M += 1 * V[n + 6])
												),
												(n += 6);
										else if ("S" === s)
											(d = R),
												(m = M),
												("C" !== g && "S" !== g) ||
													((d += R - h[h.length - 4]),
													(m += M - h[h.length - 3])),
												c || (R = M = 0),
												h.push(
													d,
													m,
													o,
													a,
													(R += 1 * V[n + 3]),
													(M += 1 * V[n + 4])
												),
												(n += 4);
										else if ("Q" === s)
											(d = R + (o - R) * I),
												(m = M + (a - M) * I),
												c || (R = M = 0),
												(R += 1 * V[n + 3]),
												(M += 1 * V[n + 4]),
												h.push(d, m, R + (o - R) * I, M + (a - M) * I, R, M),
												(n += 4);
										else if ("T" === s)
											(d = R - h[h.length - 4]),
												(m = M - h[h.length - 3]),
												h.push(
													R + d,
													M + m,
													o + (R + 1.5 * d - o) * I,
													a + (M + 1.5 * m - a) * I,
													(R = o),
													(M = a)
												),
												(n += 2);
										else if ("H" === s) w(R, M, (R = o), M), (n += 1);
										else if ("V" === s)
											w(R, M, R, (M = o + (c ? M - R : 0))), (n += 1);
										else if ("L" === s || "Z" === s)
											"Z" === s && ((o = p), (a = u), (h.closed = !0)),
												("L" === s || l(R - o) > 0.5 || l(M - a) > 0.5) &&
													(w(R, M, o, a), "L" === s && (n += 2)),
												(R = o),
												(M = a);
										else if ("A" === s) {
											if (
												((S = V[n + 4]),
												(y = V[n + 5]),
												(d = V[n + 6]),
												(m = V[n + 7]),
												(r = 7),
												S.length > 1 &&
													(S.length < 3
														? ((m = d), (d = y), r--)
														: ((m = y), (d = S.substr(2)), (r -= 2)),
													(y = S.charAt(1)),
													(S = S.charAt(0))),
												(f = C(
													R,
													M,
													+V[n + 1],
													+V[n + 2],
													+V[n + 3],
													+S,
													+y,
													(c ? R : 0) + 1 * d,
													(c ? M : 0) + 1 * m
												)),
												(n += r),
												f)
											)
												for (r = 0; r < f.length; r++) h.push(f[r]);
											(R = h[h.length - 2]), (M = h[h.length - 1]);
										} else console.log(U);
									return (
										(n = h.length) < 6
											? (q.pop(), (n = 0))
											: h[0] === h[n - 2] &&
											  h[1] === h[n - 1] &&
											  (h.closed = !0),
										(q.totalPoints = k + n),
										q
									);
								}
								function Z(t, e) {
									void 0 === e && (e = 1);
									for (
										var n = t[0], i = 0, r = [n, i], o = 2;
										o < t.length;
										o += 2
									)
										r.push(
											n,
											i,
											t[o],
											(i = ((t[o] - n) * e) / 2),
											(n = t[o]),
											-i
										);
									return r;
								}
								function H(t, e, n) {
									l(t[0] - t[2]) < 1e-4 &&
										l(t[1] - t[3]) < 1e-4 &&
										(t = t.slice(2));
									var i,
										r,
										o,
										a,
										u,
										d,
										m,
										f,
										g,
										S,
										y,
										q,
										R,
										M,
										I = t.length - 2,
										v = +t[0],
										k = +t[1],
										U = +t[2],
										w = +t[3],
										x = [v, k, v, k],
										O = U - v,
										b = w - k,
										K =
											Math.abs(t[I] - v) < 0.001 &&
											Math.abs(t[I + 1] - k) < 0.001;
									for (
										isNaN(n) && (n = Math.PI / 10),
											K &&
												(t.push(U, w),
												(U = v),
												(w = k),
												(v = t[I - 2]),
												(k = t[I - 1]),
												t.unshift(v, k),
												(I += 4)),
											e = e || 0 === e ? +e : 1,
											u = 2;
										u < I;
										u += 2
									)
										(i = v),
											(r = k),
											(v = U),
											(k = w),
											(U = +t[u + 2]),
											(w = +t[u + 3]),
											(v === U && k === w) ||
												((q = (d = O) * d + (f = b) * f),
												(R = (O = U - v) * O + (b = w - k) * b),
												(M = (m = U - i) * m + (g = w - r) * g),
												(y =
													((o = Math.acos((q + R - M) / h(4 * q * R))) /
														Math.PI) *
													e),
												(S = h(q) * y),
												(y *= h(R)),
												(v === i && k === r) ||
													(o > n
														? ((a = p(g, m)),
														  x.push(
																V(v - c(a) * S),
																V(k - s(a) * S),
																V(v),
																V(k),
																V(v + c(a) * y),
																V(k + s(a) * y)
														  ))
														: ((a = p(f, d)),
														  x.push(V(v - c(a) * S), V(k - s(a) * S)),
														  (a = p(b, O)),
														  x.push(
																V(v),
																V(k),
																V(v + c(a) * y),
																V(k + s(a) * y)
														  ))));
									return (
										v !== U || k !== w || x.length < 4
											? x.push(V(U), V(w), V(U), V(w))
											: (x.length -= 2),
										K && (x.splice(0, 6), (x.length = x.length - 6)),
										x
									);
								}
								function N(t) {
									m(t[0]) && (t = [t]);
									var e,
										n,
										i,
										r,
										o = "",
										a = t.length;
									for (n = 0; n < a; n++) {
										for (
											r = t[n],
												o += "M" + V(r[0]) + "," + V(r[1]) + " C",
												e = r.length,
												i = 2;
											i < e;
											i++
										)
											o +=
												V(r[i++]) +
												"," +
												V(r[i++]) +
												" " +
												V(r[i++]) +
												"," +
												V(r[i++]) +
												" " +
												V(r[i++]) +
												"," +
												V(r[i]) +
												" ";
										r.closed && (o += "z");
									}
									return o;
								}
								var j,
									D,
									A,
									L,
									B,
									G,
									Q,
									_,
									P = "transform",
									J = P + "Origin",
									Y = function (t) {
										var e = t.ownerDocument || t;
										!(P in t.style) &&
											"msTransform" in t.style &&
											(J = (P = "msTransform") + "Origin");
										for (; e.parentNode && (e = e.parentNode); );
										if (((D = window), (Q = new ot()), e)) {
											(j = e), (A = e.documentElement), (L = e.body);
											var n = e.createElement("div"),
												i = e.createElement("div");
											L.appendChild(n),
												n.appendChild(i),
												(n.style.position = "static"),
												(n.style[P] = "translate3d(0,0,1px)"),
												(_ = i.offsetParent !== n),
												L.removeChild(n);
										}
										return e;
									},
									X = [],
									$ = [],
									tt = function (t) {
										return (
											t.ownerSVGElement ||
											("svg" === (t.tagName + "").toLowerCase() ? t : null)
										);
									},
									et = function t(e) {
										return (
											"fixed" === D.getComputedStyle(e).position ||
											((e = e.parentNode) && 1 === e.nodeType ? t(e) : void 0)
										);
									},
									nt = function t(e, n) {
										if (e.parentNode && (j || Y(e))) {
											var i = tt(e),
												r = i
													? i.getAttribute("xmlns") ||
													  "http://www.w3.org/2000/svg"
													: "http://www.w3.org/1999/xhtml",
												o = i ? (n ? "rect" : "g") : "div",
												a = 2 !== n ? 0 : 100,
												s = 3 === n ? 100 : 0,
												c =
													"position:absolute;display:block;pointer-events:none;margin:0;padding:0;",
												l = j.createElementNS
													? j.createElementNS(r.replace(/^https/, "http"), o)
													: j.createElement(o);
											return (
												n &&
													(i
														? (G || (G = t(e)),
														  l.setAttribute("width", 0.01),
														  l.setAttribute("height", 0.01),
														  l.setAttribute(
																"transform",
																"translate(" + a + "," + s + ")"
														  ),
														  G.appendChild(l))
														: (B || ((B = t(e)).style.cssText = c),
														  (l.style.cssText =
																c +
																"width:0.1px;height:0.1px;top:" +
																s +
																"px;left:" +
																a +
																"px"),
														  B.appendChild(l))),
												l
											);
										}
										throw "Need document and parent.";
									},
									it = function (t, e) {
										var n,
											i,
											r,
											o,
											a,
											s,
											c = tt(t),
											l = t === c,
											h = c ? X : $,
											p = t.parentNode;
										if (t === D) return t;
										if (
											(h.length || h.push(nt(t, 1), nt(t, 2), nt(t, 3)),
											(n = c ? G : B),
											c)
										)
											(r = l ? { x: 0, y: 0 } : t.getBBox()),
												(i = t.transform ? t.transform.baseVal : {})
													.numberOfItems
													? ((o =
															(i =
																i.numberOfItems > 1
																	? (function (t) {
																			for (
																				var e = new ot(), n = 0;
																				n < t.numberOfItems;
																				n++
																			)
																				e.multiply(t.getItem(n).matrix);
																			return e;
																	  })(i)
																	: i.getItem(0).matrix).a *
																r.x +
															i.c * r.y),
													  (a = i.b * r.x + i.d * r.y))
													: ((i = Q), (o = r.x), (a = r.y)),
												e && "g" === t.tagName.toLowerCase() && (o = a = 0),
												(l ? c : p).appendChild(n),
												n.setAttribute(
													"transform",
													"matrix(" +
														i.a +
														"," +
														i.b +
														"," +
														i.c +
														"," +
														i.d +
														"," +
														(i.e + o) +
														"," +
														(i.f + a) +
														")"
												);
										else {
											if (((o = a = 0), _))
												for (
													i = t.offsetParent, r = t;
													r && (r = r.parentNode) && r !== i && r.parentNode;

												)
													(D.getComputedStyle(r)[P] + "").length > 4 &&
														((o = r.offsetLeft), (a = r.offsetTop), (r = 0));
											if ("absolute" !== (s = D.getComputedStyle(t)).position)
												for (i = t.offsetParent; p && p !== i; )
													(o += p.scrollLeft || 0),
														(a += p.scrollTop || 0),
														(p = p.parentNode);
											((r = n.style).top = t.offsetTop - a + "px"),
												(r.left = t.offsetLeft - o + "px"),
												(r[P] = s[P]),
												(r[J] = s[J]),
												(r.position =
													"fixed" === s.position ? "fixed" : "absolute"),
												t.parentNode.appendChild(n);
										}
										return n;
									},
									rt = function (t, e, n, i, r, o, a) {
										return (
											(t.a = e),
											(t.b = n),
											(t.c = i),
											(t.d = r),
											(t.e = o),
											(t.f = a),
											t
										);
									},
									ot = (function () {
										function t(t, e, n, i, r, o) {
											void 0 === t && (t = 1),
												void 0 === e && (e = 0),
												void 0 === n && (n = 0),
												void 0 === i && (i = 1),
												void 0 === r && (r = 0),
												void 0 === o && (o = 0),
												rt(this, t, e, n, i, r, o);
										}
										var e = t.prototype;
										return (
											(e.inverse = function () {
												var t = this.a,
													e = this.b,
													n = this.c,
													i = this.d,
													r = this.e,
													o = this.f,
													a = t * i - e * n || 1e-10;
												return rt(
													this,
													i / a,
													-e / a,
													-n / a,
													t / a,
													(n * o - i * r) / a,
													-(t * o - e * r) / a
												);
											}),
											(e.multiply = function (t) {
												var e = this.a,
													n = this.b,
													i = this.c,
													r = this.d,
													o = this.e,
													a = this.f,
													s = t.a,
													c = t.c,
													l = t.b,
													h = t.d,
													p = t.e,
													u = t.f;
												return rt(
													this,
													s * e + l * i,
													s * n + l * r,
													c * e + h * i,
													c * n + h * r,
													o + p * e + u * i,
													a + p * n + u * r
												);
											}),
											(e.clone = function () {
												return new t(
													this.a,
													this.b,
													this.c,
													this.d,
													this.e,
													this.f
												);
											}),
											(e.equals = function (t) {
												var e = this.a,
													n = this.b,
													i = this.c,
													r = this.d,
													o = this.e,
													a = this.f;
												return (
													e === t.a &&
													n === t.b &&
													i === t.c &&
													r === t.d &&
													o === t.e &&
													a === t.f
												);
											}),
											(e.apply = function (t, e) {
												void 0 === e && (e = {});
												var n = t.x,
													i = t.y,
													r = this.a,
													o = this.b,
													a = this.c,
													s = this.d,
													c = this.e,
													l = this.f;
												return (
													(e.x = n * r + i * a + c || 0),
													(e.y = n * o + i * s + l || 0),
													e
												);
											}),
											t
										);
									})();
								function at(t, e, n, i) {
									if (!t || !t.parentNode || (j || Y(t)).documentElement === t)
										return new ot();
									var r = (function (t) {
											for (var e, n; t && t !== L; )
												(n = t._gsap) && n.uncache && n.get(t, "x"),
													n &&
														!n.scaleX &&
														!n.scaleY &&
														n.renderTransform &&
														((n.scaleX = n.scaleY = 1e-4),
														n.renderTransform(1, n),
														e ? e.push(n) : (e = [n])),
													(t = t.parentNode);
											return e;
										})(t),
										o = tt(t) ? X : $,
										a = it(t, n),
										s = o[0].getBoundingClientRect(),
										c = o[1].getBoundingClientRect(),
										l = o[2].getBoundingClientRect(),
										h = a.parentNode,
										p = !i && et(t),
										u = new ot(
											(c.left - s.left) / 100,
											(c.top - s.top) / 100,
											(l.left - s.left) / 100,
											(l.top - s.top) / 100,
											s.left +
												(p
													? 0
													: D.pageXOffset ||
													  j.scrollLeft ||
													  A.scrollLeft ||
													  L.scrollLeft ||
													  0),
											s.top +
												(p
													? 0
													: D.pageYOffset ||
													  j.scrollTop ||
													  A.scrollTop ||
													  L.scrollTop ||
													  0)
										);
									if ((h.removeChild(a), r))
										for (s = r.length; s--; )
											((c = r[s]).scaleX = c.scaleY = 0),
												c.renderTransform(1, c);
									return e ? u.inverse() : u;
								}
								var st,
									ct,
									lt,
									ht,
									pt = "x,translateX,left,marginLeft,xPercent".split(","),
									ut = "y,translateY,top,marginTop,yPercent".split(","),
									dt = Math.PI / 180,
									mt = function (t, e, n, i) {
										for (
											var r = e.length, o = 2 === i ? 0 : i, a = 0;
											a < r;
											a++
										)
											(t[o] = parseFloat(e[a][n])),
												2 === i && (t[o + 1] = 0),
												(o += 2);
										return t;
									},
									ft = function (t, e, n) {
										return parseFloat(t._gsap.get(t, e, n || "px")) || 0;
									},
									gt = function (t) {
										var e,
											n = t[0],
											i = t[1];
										for (e = 2; e < t.length; e += 2)
											(n = t[e] += n), (i = t[e + 1] += i);
									},
									St = function (t, e, n, i, r, o, a, s, c) {
										return (
											"cubic" === a.type
												? (e = [e])
												: (e.unshift(ft(n, i, s), r ? ft(n, r, c) : 0),
												  a.relative && gt(e),
												  (e = [(r ? H : Z)(e, a.curviness)])),
											(e = o(Mt(e, n, a))),
											It(t, n, i, e, "x", s),
											r && It(t, n, r, e, "y", c),
											K(e, a.resolution || (0 === a.curviness ? 20 : 12))
										);
									},
									yt = function (t) {
										return t;
									},
									Vt = /[-+\.]*\d+[\.e\-\+]*\d*[e\-\+]*\d*/g,
									qt = function (t, e, n) {
										var i,
											r,
											o,
											a = at(t);
										return (
											"svg" === (t.tagName + "").toLowerCase()
												? ((r = (i = t.viewBox.baseVal).x),
												  (o = i.y),
												  i.width ||
														(i = {
															width: +t.getAttribute("width"),
															height: +t.getAttribute("height"),
														}))
												: ((i = e && t.getBBox && t.getBBox()), (r = o = 0)),
											e &&
												"auto" !== e &&
												((r += e.push
													? e[0] * (i ? i.width : t.offsetWidth || 0)
													: e.x),
												(o += e.push
													? e[1] * (i ? i.height : t.offsetHeight || 0)
													: e.y)),
											n.apply(
												r || o ? a.apply({ x: r, y: o }) : { x: a.e, y: a.f }
											)
										);
									},
									Rt = function (t, e, n, i) {
										var r,
											o = at(t.parentNode, !0, !0),
											a = o.clone().multiply(at(e)),
											s = qt(t, n, o),
											c = qt(e, i, o),
											l = c.x,
											h = c.y;
										return (
											(a.e = a.f = 0),
											"auto" === i &&
												e.getTotalLength &&
												"path" === e.tagName.toLowerCase() &&
												((r = e.getAttribute("d").match(Vt) || []),
												(l += (r = a.apply({ x: +r[0], y: +r[1] })).x),
												(h += r.y)),
											(r ||
												(e.getBBox &&
													t.getBBox &&
													e.ownerSVGElement === t.ownerSVGElement)) &&
												((l -= (r = a.apply(e.getBBox())).x), (h -= r.y)),
											(a.e = l - s.x),
											(a.f = h - s.y),
											a
										);
									},
									Mt = function (t, e, n) {
										var i,
											r,
											o,
											a = n.align,
											s = n.matrix,
											c = n.offsetX,
											l = n.offsetY,
											h = n.alignOrigin,
											p = t[0][0],
											u = t[0][1],
											d = ft(e, "x"),
											m = ft(e, "y");
										return t && t.length
											? (a &&
													("self" === a || (i = ht(a)[0] || e) === e
														? E(t, 1, 0, 0, 1, d - p, m - u)
														: (h && !1 !== h[2]
																? st.set(e, {
																		transformOrigin:
																			100 * h[0] + "% " + 100 * h[1] + "%",
																  })
																: (h = [
																		ft(e, "xPercent") / -100,
																		ft(e, "yPercent") / -100,
																  ]),
														  (o = (r = Rt(e, i, h, "auto")).apply({
																x: p,
																y: u,
														  })),
														  E(
																t,
																r.a,
																r.b,
																r.c,
																r.d,
																d + r.e - (o.x - r.e),
																m + r.f - (o.y - r.f)
														  ))),
											  s
													? E(t, s.a, s.b, s.c, s.d, s.e, s.f)
													: (c || l) && E(t, 1, 0, 0, 1, c || 0, l || 0),
											  t)
											: v("M0,0L0,0");
									},
									It = function (t, e, n, i, r, o) {
										var a = e._gsap,
											s = a.harness,
											c = s && s.aliases && s.aliases[n],
											l = c && c.indexOf(",") < 0 ? c : n,
											h = (t._pt = new ct(
												t._pt,
												e,
												l,
												0,
												0,
												yt,
												0,
												a.set(e, l, t)
											));
										(h.u = lt(a.get(e, l, o)) || 0),
											(h.path = i),
											(h.pp = r),
											t._props.push(l);
									},
									vt = {
										version: "3.6.1",
										name: "motionPath",
										register: function (t, e, n) {
											(lt = (st = t).utils.getUnit),
												(ht = st.utils.toArray),
												(ct = n);
										},
										init: function (t, e) {
											if (!st)
												return (
													console.warn(
														"Please gsap.registerPlugin(MotionPathPlugin)"
													),
													!1
												);
											("object" == typeof e && !e.style && e.path) ||
												(e = { path: e });
											var n,
												i,
												r,
												o,
												a = [],
												s = e,
												c = s.path,
												l = s.autoRotate,
												h = s.unitX,
												p = s.unitY,
												u = s.x,
												d = s.y,
												m = c[0],
												f =
													((r = e.start),
													(o = "end" in e ? e.end : 1),
													function (t) {
														return r || 1 !== o ? O(t, r, o) : t;
													});
											if (
												((this.rawPaths = a),
												(this.target = t),
												(this.rotate = l || 0 === l) &&
													((this.rOffset = parseFloat(l) || 0),
													(this.radians = !!e.useRadians),
													(this.rProp = e.rotation || "rotation"),
													(this.rSet = t._gsap.set(t, this.rProp, this)),
													(this.ru = lt(t._gsap.get(t, this.rProp)) || 0)),
												Array.isArray(c) &&
													!("closed" in c) &&
													"number" != typeof m)
											) {
												for (i in m)
													!u && ~pt.indexOf(i)
														? (u = i)
														: !d && ~ut.indexOf(i) && (d = i);
												for (i in (u && d
													? a.push(
															St(
																this,
																mt(mt([], c, u, 0), c, d, 1),
																t,
																u,
																d,
																f,
																e,
																h || lt(c[0][u]),
																p || lt(c[0][d])
															)
													  )
													: (u = d = 0),
												m))
													i !== u &&
														i !== d &&
														a.push(
															St(
																this,
																mt([], c, i, 2),
																t,
																i,
																0,
																f,
																e,
																lt(c[0][i])
															)
														);
											} else
												K((n = f(Mt(v(e.path), t, e))), e.resolution),
													a.push(n),
													It(this, t, e.x || "x", n, "x", e.unitX || "px"),
													It(this, t, e.y || "y", n, "y", e.unitY || "px");
										},
										render: function (t, e) {
											var n = e.rawPaths,
												i = n.length,
												r = e._pt;
											for (t > 1 ? (t = 1) : t < 0 && (t = 0); i--; )
												W(n[i], t, !i && e.rotate, n[i]);
											for (; r; )
												r.set(r.t, r.p, r.path[r.pp] + r.u, r.d, t),
													(r = r._next);
											e.rotate &&
												e.rSet(
													e.target,
													e.rProp,
													n[0].angle * (e.radians ? dt : 1) + e.rOffset + e.ru,
													e,
													t
												);
										},
										getLength: function (t) {
											return K(v(t)).totalLength;
										},
										sliceRawPath: O,
										getRawPath: v,
										pointsToSegment: H,
										stringToRawPath: F,
										rawPathToString: N,
										transformRawPath: E,
										getGlobalMatrix: at,
										getPositionOnPath: W,
										cacheRawPathMeasurements: K,
										convertToPath: function (t, e) {
											return ht(t).map(function (t) {
												return w(t, !1 !== e);
											});
										},
										convertCoordinates: function (t, e, n) {
											var i = at(e, !0, !0).multiply(at(t));
											return n ? i.apply(n) : i;
										},
										getAlignMatrix: Rt,
										getRelativePosition: function (t, e, n, i) {
											var r = Rt(t, e, n, i);
											return { x: r.e, y: r.f };
										},
										arrayToRawPath: function (t, e) {
											var n = mt(
												mt([], t, (e = e || {}).x || "x", 0),
												t,
												e.y || "y",
												1
											);
											return (
												e.relative && gt(n),
												["cubic" === e.type ? n : H(n, e.curviness)]
											);
										},
									};
								(st ||
									("undefined" != typeof window &&
										(st = window.gsap) &&
										st.registerPlugin &&
										st)) &&
									st.registerPlugin(vt),
									(t.MotionPathPlugin = vt),
									(t.default = vt),
									Object.defineProperty(t, "__esModule", { value: !0 });
							})(e);
						},
						379: (t, e, n) => {
							"use strict";
							var i,
								r = (function () {
									var t = {};
									return function (e) {
										if (void 0 === t[e]) {
											var n = document.querySelector(e);
											if (
												window.HTMLIFrameElement &&
												n instanceof window.HTMLIFrameElement
											)
												try {
													n = n.contentDocument.head;
												} catch (t) {
													n = null;
												}
											t[e] = n;
										}
										return t[e];
									};
								})(),
								o = [];
							function a(t) {
								for (var e = -1, n = 0; n < o.length; n++)
									if (o[n].identifier === t) {
										e = n;
										break;
									}
								return e;
							}
							function s(t, e) {
								for (var n = {}, i = [], r = 0; r < t.length; r++) {
									var s = t[r],
										c = e.base ? s[0] + e.base : s[0],
										l = n[c] || 0,
										h = "".concat(c, " ").concat(l);
									n[c] = l + 1;
									var p = a(h),
										u = { css: s[1], media: s[2], sourceMap: s[3] };
									-1 !== p
										? (o[p].references++, o[p].updater(u))
										: o.push({
												identifier: h,
												updater: f(u, e),
												references: 1,
										  }),
										i.push(h);
								}
								return i;
							}
							function c(t) {
								var e = document.createElement("style"),
									i = t.attributes || {};
								if (void 0 === i.nonce) {
									var o = n.nc;
									o && (i.nonce = o);
								}
								if (
									(Object.keys(i).forEach(function (t) {
										e.setAttribute(t, i[t]);
									}),
									"function" == typeof t.insert)
								)
									t.insert(e);
								else {
									var a = r(t.insert || "head");
									if (!a)
										throw new Error(
											"Couldn't find a style target. This probably means that the value for the 'insert' parameter is invalid."
										);
									a.appendChild(e);
								}
								return e;
							}
							var l,
								h =
									((l = []),
									function (t, e) {
										return (l[t] = e), l.filter(Boolean).join("\n");
									});
							function p(t, e, n, i) {
								var r = n
									? ""
									: i.media
									? "@media ".concat(i.media, " {").concat(i.css, "}")
									: i.css;
								if (t.styleSheet) t.styleSheet.cssText = h(e, r);
								else {
									var o = document.createTextNode(r),
										a = t.childNodes;
									a[e] && t.removeChild(a[e]),
										a.length ? t.insertBefore(o, a[e]) : t.appendChild(o);
								}
							}
							function u(t, e, n) {
								var i = n.css,
									r = n.media,
									o = n.sourceMap;
								if (
									(r ? t.setAttribute("media", r) : t.removeAttribute("media"),
									o &&
										"undefined" != typeof btoa &&
										(i +=
											"\n/*# sourceMappingURL=data:application/json;base64,".concat(
												btoa(unescape(encodeURIComponent(JSON.stringify(o)))),
												" */"
											)),
									t.styleSheet)
								)
									t.styleSheet.cssText = i;
								else {
									for (; t.firstChild; ) t.removeChild(t.firstChild);
									t.appendChild(document.createTextNode(i));
								}
							}
							var d = null,
								m = 0;
							function f(t, e) {
								var n, i, r;
								if (e.singleton) {
									var o = m++;
									(n = d || (d = c(e))),
										(i = p.bind(null, n, o, !1)),
										(r = p.bind(null, n, o, !0));
								} else
									(n = c(e)),
										(i = u.bind(null, n, e)),
										(r = function () {
											!(function (t) {
												if (null === t.parentNode) return !1;
												t.parentNode.removeChild(t);
											})(n);
										});
								return (
									i(t),
									function (e) {
										if (e) {
											if (
												e.css === t.css &&
												e.media === t.media &&
												e.sourceMap === t.sourceMap
											)
												return;
											i((t = e));
										} else r();
									}
								);
							}
							t.exports = function (t, e) {
								(e = e || {}).singleton ||
									"boolean" == typeof e.singleton ||
									(e.singleton =
										(void 0 === i &&
											(i = Boolean(
												window && document && document.all && !window.atob
											)),
										i));
								var n = s((t = t || []), e);
								return function (t) {
									if (
										((t = t || []),
										"[object Array]" === Object.prototype.toString.call(t))
									) {
										for (var i = 0; i < n.length; i++) {
											var r = a(n[i]);
											o[r].references--;
										}
										for (var c = s(t, e), l = 0; l < n.length; l++) {
											var h = a(n[l]);
											0 === o[h].references && (o[h].updater(), o.splice(h, 1));
										}
										n = c;
									}
								};
							};
						},
						933: (t, e, n) => {
							var i;
							!(function () {
								function r(t, e, n) {
									return t.call.apply(t.bind, arguments);
								}
								function o(t, e, n) {
									if (!t) throw Error();
									if (2 < arguments.length) {
										var i = Array.prototype.slice.call(arguments, 2);
										return function () {
											var n = Array.prototype.slice.call(arguments);
											return Array.prototype.unshift.apply(n, i), t.apply(e, n);
										};
									}
									return function () {
										return t.apply(e, arguments);
									};
								}
								function a(t, e, n) {
									return (a =
										Function.prototype.bind &&
										-1 !=
											Function.prototype.bind.toString().indexOf("native code")
											? r
											: o).apply(null, arguments);
								}
								var s =
									Date.now ||
									function () {
										return +new Date();
									};
								function c(t, e) {
									(this.a = t), (this.o = e || t), (this.c = this.o.document);
								}
								var l = !!window.FontFace;
								function h(t, e, n, i) {
									if (((e = t.c.createElement(e)), n))
										for (var r in n)
											n.hasOwnProperty(r) &&
												("style" == r
													? (e.style.cssText = n[r])
													: e.setAttribute(r, n[r]));
									return i && e.appendChild(t.c.createTextNode(i)), e;
								}
								function p(t, e, n) {
									(t = t.c.getElementsByTagName(e)[0]) ||
										(t = document.documentElement),
										t.insertBefore(n, t.lastChild);
								}
								function u(t) {
									t.parentNode && t.parentNode.removeChild(t);
								}
								function d(t, e, n) {
									(e = e || []), (n = n || []);
									for (
										var i = t.className.split(/\s+/), r = 0;
										r < e.length;
										r += 1
									) {
										for (var o = !1, a = 0; a < i.length; a += 1)
											if (e[r] === i[a]) {
												o = !0;
												break;
											}
										o || i.push(e[r]);
									}
									for (e = [], r = 0; r < i.length; r += 1) {
										for (o = !1, a = 0; a < n.length; a += 1)
											if (i[r] === n[a]) {
												o = !0;
												break;
											}
										o || e.push(i[r]);
									}
									t.className = e
										.join(" ")
										.replace(/\s+/g, " ")
										.replace(/^\s+|\s+$/, "");
								}
								function m(t, e) {
									for (
										var n = t.className.split(/\s+/), i = 0, r = n.length;
										i < r;
										i++
									)
										if (n[i] == e) return !0;
									return !1;
								}
								function f(t, e, n) {
									function i() {
										s && r && o && (s(a), (s = null));
									}
									e = h(t, "link", {
										rel: "stylesheet",
										href: e,
										media: "all",
									});
									var r = !1,
										o = !0,
										a = null,
										s = n || null;
									l
										? ((e.onload = function () {
												(r = !0), i();
										  }),
										  (e.onerror = function () {
												(r = !0), (a = Error("Stylesheet failed to load")), i();
										  }))
										: setTimeout(function () {
												(r = !0), i();
										  }, 0),
										p(t, "head", e);
								}
								function g(t, e, n, i) {
									var r = t.c.getElementsByTagName("head")[0];
									if (r) {
										var o = h(t, "script", { src: e }),
											a = !1;
										return (
											(o.onload = o.onreadystatechange =
												function () {
													a ||
														(this.readyState &&
															"loaded" != this.readyState &&
															"complete" != this.readyState) ||
														((a = !0),
														n && n(null),
														(o.onload = o.onreadystatechange = null),
														"HEAD" == o.parentNode.tagName && r.removeChild(o));
												}),
											r.appendChild(o),
											setTimeout(function () {
												a || ((a = !0), n && n(Error("Script load timeout")));
											}, i || 5e3),
											o
										);
									}
									return null;
								}
								function S() {
									(this.a = 0), (this.c = null);
								}
								function y(t) {
									return (
										t.a++,
										function () {
											t.a--, q(t);
										}
									);
								}
								function V(t, e) {
									(t.c = e), q(t);
								}
								function q(t) {
									0 == t.a && t.c && (t.c(), (t.c = null));
								}
								function R(t) {
									this.a = t || "-";
								}
								function M(t, e) {
									(this.c = t), (this.f = 4), (this.a = "n");
									var n = (e || "n4").match(/^([nio])([1-9])$/i);
									n && ((this.a = n[1]), (this.f = parseInt(n[2], 10)));
								}
								function I(t) {
									var e = [];
									t = t.split(/,\s*/);
									for (var n = 0; n < t.length; n++) {
										var i = t[n].replace(/['"]/g, "");
										-1 != i.indexOf(" ") || /^\d/.test(i)
											? e.push("'" + i + "'")
											: e.push(i);
									}
									return e.join(",");
								}
								function v(t) {
									return t.a + t.f;
								}
								function k(t) {
									var e = "normal";
									return (
										"o" === t.a
											? (e = "oblique")
											: "i" === t.a && (e = "italic"),
										e
									);
								}
								function U(t) {
									var e = 4,
										n = "n",
										i = null;
									return (
										t &&
											((i = t.match(/(normal|oblique|italic)/i)) &&
												i[1] &&
												(n = i[1].substr(0, 1).toLowerCase()),
											(i = t.match(/([1-9]00|normal|bold)/i)) &&
												i[1] &&
												(/bold/i.test(i[1])
													? (e = 7)
													: /[1-9]00/.test(i[1]) &&
													  (e = parseInt(i[1].substr(0, 1), 10)))),
										n + e
									);
								}
								function w(t, e) {
									(this.c = t),
										(this.f = t.o.document.documentElement),
										(this.h = e),
										(this.a = new R("-")),
										(this.j = !1 !== e.events),
										(this.g = !1 !== e.classes);
								}
								function x(t) {
									if (t.g) {
										var e = m(t.f, t.a.c("wf", "active")),
											n = [],
											i = [t.a.c("wf", "loading")];
										e || n.push(t.a.c("wf", "inactive")), d(t.f, n, i);
									}
									O(t, "inactive");
								}
								function O(t, e, n) {
									t.j && t.h[e] && (n ? t.h[e](n.c, v(n)) : t.h[e]());
								}
								function b() {
									this.c = {};
								}
								function K(t, e) {
									(this.c = t),
										(this.f = e),
										(this.a = h(
											this.c,
											"span",
											{ "aria-hidden": "true" },
											this.f
										));
								}
								function T(t) {
									p(t.c, "body", t.a);
								}
								function z(t) {
									return (
										"display:block;position:absolute;top:-9999px;left:-9999px;font-size:300px;width:auto;height:auto;line-height:normal;margin:0;padding:0;font-variant:normal;white-space:nowrap;font-family:" +
										I(t.c) +
										";font-style:" +
										k(t) +
										";font-weight:" +
										t.f +
										"00;"
									);
								}
								function W(t, e, n, i, r, o) {
									(this.g = t),
										(this.j = e),
										(this.a = i),
										(this.c = n),
										(this.f = r || 3e3),
										(this.h = o || void 0);
								}
								function E(t, e, n, i, r, o, a) {
									(this.v = t),
										(this.B = e),
										(this.c = n),
										(this.a = i),
										(this.s = a || "BESbswy"),
										(this.f = {}),
										(this.w = r || 3e3),
										(this.u = o || null),
										(this.m = this.j = this.h = this.g = null),
										(this.g = new K(this.c, this.s)),
										(this.h = new K(this.c, this.s)),
										(this.j = new K(this.c, this.s)),
										(this.m = new K(this.c, this.s)),
										(t = z((t = new M(this.a.c + ",serif", v(this.a))))),
										(this.g.a.style.cssText = t),
										(t = z((t = new M(this.a.c + ",sans-serif", v(this.a))))),
										(this.h.a.style.cssText = t),
										(t = z((t = new M("serif", v(this.a))))),
										(this.j.a.style.cssText = t),
										(t = z((t = new M("sans-serif", v(this.a))))),
										(this.m.a.style.cssText = t),
										T(this.g),
										T(this.h),
										T(this.j),
										T(this.m);
								}
								(R.prototype.c = function (t) {
									for (var e = [], n = 0; n < arguments.length; n++)
										e.push(arguments[n].replace(/[\W_]+/g, "").toLowerCase());
									return e.join(this.a);
								}),
									(W.prototype.start = function () {
										var t = this.c.o.document,
											e = this,
											n = s(),
											i = new Promise(function (i, r) {
												!(function o() {
													s() - n >= e.f
														? r()
														: t.fonts
																.load(
																	(function (t) {
																		return (
																			k(t) + " " + t.f + "00 300px " + I(t.c)
																		);
																	})(e.a),
																	e.h
																)
																.then(
																	function (t) {
																		1 <= t.length ? i() : setTimeout(o, 25);
																	},
																	function () {
																		r();
																	}
																);
												})();
											}),
											r = null,
											o = new Promise(function (t, n) {
												r = setTimeout(n, e.f);
											});
										Promise.race([o, i]).then(
											function () {
												r && (clearTimeout(r), (r = null)), e.g(e.a);
											},
											function () {
												e.j(e.a);
											}
										);
									});
								var C = { D: "serif", C: "sans-serif" },
									F = null;
								function Z() {
									if (null === F) {
										var t = /AppleWebKit\/([0-9]+)(?:\.([0-9]+))/.exec(
											window.navigator.userAgent
										);
										F =
											!!t &&
											(536 > parseInt(t[1], 10) ||
												(536 === parseInt(t[1], 10) &&
													11 >= parseInt(t[2], 10)));
									}
									return F;
								}
								function H(t, e, n) {
									for (var i in C)
										if (
											C.hasOwnProperty(i) &&
											e === t.f[C[i]] &&
											n === t.f[C[i]]
										)
											return !0;
									return !1;
								}
								function N(t) {
									var e,
										n = t.g.a.offsetWidth,
										i = t.h.a.offsetWidth;
									(e = n === t.f.serif && i === t.f["sans-serif"]) ||
										(e = Z() && H(t, n, i)),
										e
											? s() - t.A >= t.w
												? Z() &&
												  H(t, n, i) &&
												  (null === t.u || t.u.hasOwnProperty(t.a.c))
													? j(t, t.v)
													: j(t, t.B)
												: (function (t) {
														setTimeout(
															a(function () {
																N(this);
															}, t),
															50
														);
												  })(t)
											: j(t, t.v);
								}
								function j(t, e) {
									setTimeout(
										a(function () {
											u(this.g.a),
												u(this.h.a),
												u(this.j.a),
												u(this.m.a),
												e(this.a);
										}, t),
										0
									);
								}
								function D(t, e, n) {
									(this.c = t),
										(this.a = e),
										(this.f = 0),
										(this.m = this.j = !1),
										(this.s = n);
								}
								E.prototype.start = function () {
									(this.f.serif = this.j.a.offsetWidth),
										(this.f["sans-serif"] = this.m.a.offsetWidth),
										(this.A = s()),
										N(this);
								};
								var A = null;
								function L(t) {
									0 == --t.f &&
										t.j &&
										(t.m
											? ((t = t.a).g &&
													d(
														t.f,
														[t.a.c("wf", "active")],
														[t.a.c("wf", "loading"), t.a.c("wf", "inactive")]
													),
											  O(t, "active"))
											: x(t.a));
								}
								function B(t) {
									(this.j = t),
										(this.a = new b()),
										(this.h = 0),
										(this.f = this.g = !0);
								}
								function G(t, e, n, i, r) {
									var o = 0 == --t.h;
									(t.f || t.g) &&
										setTimeout(function () {
											var t = r || null,
												s = i || {};
											if (0 === n.length && o) x(e.a);
											else {
												(e.f += n.length), o && (e.j = o);
												var c,
													l = [];
												for (c = 0; c < n.length; c++) {
													var h = n[c],
														p = s[h.c],
														u = e.a,
														m = h;
													if (
														(u.g &&
															d(u.f, [
																u.a.c("wf", m.c, v(m).toString(), "loading"),
															]),
														O(u, "fontloading", m),
														(u = null),
														null === A)
													)
														if (window.FontFace) {
															m = /Gecko.*Firefox\/(\d+)/.exec(
																window.navigator.userAgent
															);
															var f =
																/OS X.*Version\/10\..*Safari/.exec(
																	window.navigator.userAgent
																) && /Apple/.exec(window.navigator.vendor);
															A = m ? 42 < parseInt(m[1], 10) : !f;
														} else A = !1;
													(u = A
														? new W(a(e.g, e), a(e.h, e), e.c, h, e.s, p)
														: new E(a(e.g, e), a(e.h, e), e.c, h, e.s, t, p)),
														l.push(u);
												}
												for (c = 0; c < l.length; c++) l[c].start();
											}
										}, 0);
								}
								function Q(t, e) {
									(this.c = t), (this.a = e);
								}
								function _(t, e) {
									(this.c = t), (this.a = e);
								}
								function P(t, e) {
									(this.c = t || J),
										(this.a = []),
										(this.f = []),
										(this.g = e || "");
								}
								(D.prototype.g = function (t) {
									var e = this.a;
									e.g &&
										d(
											e.f,
											[e.a.c("wf", t.c, v(t).toString(), "active")],
											[
												e.a.c("wf", t.c, v(t).toString(), "loading"),
												e.a.c("wf", t.c, v(t).toString(), "inactive"),
											]
										),
										O(e, "fontactive", t),
										(this.m = !0),
										L(this);
								}),
									(D.prototype.h = function (t) {
										var e = this.a;
										if (e.g) {
											var n = m(
													e.f,
													e.a.c("wf", t.c, v(t).toString(), "active")
												),
												i = [],
												r = [e.a.c("wf", t.c, v(t).toString(), "loading")];
											n ||
												i.push(e.a.c("wf", t.c, v(t).toString(), "inactive")),
												d(e.f, i, r);
										}
										O(e, "fontinactive", t), L(this);
									}),
									(B.prototype.load = function (t) {
										(this.c = new c(this.j, t.context || this.j)),
											(this.g = !1 !== t.events),
											(this.f = !1 !== t.classes),
											(function (t, e, n) {
												var i = [],
													r = n.timeout;
												!(function (t) {
													t.g && d(t.f, [t.a.c("wf", "loading")]),
														O(t, "loading");
												})(e),
													(i = (function (t, e, n) {
														var i,
															r = [];
														for (i in e)
															if (e.hasOwnProperty(i)) {
																var o = t.c[i];
																o && r.push(o(e[i], n));
															}
														return r;
													})(t.a, n, t.c));
												var o = new D(t.c, e, r);
												for (t.h = i.length, e = 0, n = i.length; e < n; e++)
													i[e].load(function (e, n, i) {
														G(t, o, e, n, i);
													});
											})(this, new w(this.c, t), t);
									}),
									(Q.prototype.load = function (t) {
										function e() {
											if (o["__mti_fntLst" + i]) {
												var n,
													r = o["__mti_fntLst" + i](),
													a = [];
												if (r)
													for (var s = 0; s < r.length; s++) {
														var c = r[s].fontfamily;
														null != r[s].fontStyle && null != r[s].fontWeight
															? ((n = r[s].fontStyle + r[s].fontWeight),
															  a.push(new M(c, n)))
															: a.push(new M(c));
													}
												t(a);
											} else
												setTimeout(function () {
													e();
												}, 50);
										}
										var n = this,
											i = n.a.projectId,
											r = n.a.version;
										if (i) {
											var o = n.c.o;
											g(
												this.c,
												(n.a.api || "https://fast.fonts.net/jsapi") +
													"/" +
													i +
													".js" +
													(r ? "?v=" + r : ""),
												function (r) {
													r
														? t([])
														: ((o["__MonotypeConfiguration__" + i] =
																function () {
																	return n.a;
																}),
														  e());
												}
											).id = "__MonotypeAPIScript__" + i;
										} else t([]);
									}),
									(_.prototype.load = function (t) {
										var e,
											n,
											i = this.a.urls || [],
											r = this.a.families || [],
											o = this.a.testStrings || {},
											a = new S();
										for (e = 0, n = i.length; e < n; e++) f(this.c, i[e], y(a));
										var s = [];
										for (e = 0, n = r.length; e < n; e++)
											if ((i = r[e].split(":"))[1])
												for (
													var c = i[1].split(","), l = 0;
													l < c.length;
													l += 1
												)
													s.push(new M(i[0], c[l]));
											else s.push(new M(i[0]));
										V(a, function () {
											t(s, o);
										});
									});
								var J = "https://fonts.googleapis.com/css";
								function Y(t) {
									(this.f = t), (this.a = []), (this.c = {});
								}
								var X = {
										latin: "BESbswy",
										"latin-ext": "çöüğş",
										cyrillic: "йяЖ",
										greek: "αβΣ",
										khmer: "កខគ",
										Hanuman: "កខគ",
									},
									$ = {
										thin: "1",
										extralight: "2",
										"extra-light": "2",
										ultralight: "2",
										"ultra-light": "2",
										light: "3",
										regular: "4",
										book: "4",
										medium: "5",
										"semi-bold": "6",
										semibold: "6",
										"demi-bold": "6",
										demibold: "6",
										bold: "7",
										"extra-bold": "8",
										extrabold: "8",
										"ultra-bold": "8",
										ultrabold: "8",
										black: "9",
										heavy: "9",
										l: "3",
										r: "4",
										b: "7",
									},
									tt = { i: "i", italic: "i", n: "n", normal: "n" },
									et =
										/^(thin|(?:(?:extra|ultra)-?)?light|regular|book|medium|(?:(?:semi|demi|extra|ultra)-?)?bold|black|heavy|l|r|b|[1-9]00)?(n|i|normal|italic)?$/;
								function nt(t, e) {
									(this.c = t), (this.a = e);
								}
								var it = { Arimo: !0, Cousine: !0, Tinos: !0 };
								function rt(t, e) {
									(this.c = t), (this.a = e);
								}
								function ot(t, e) {
									(this.c = t), (this.f = e), (this.a = []);
								}
								(nt.prototype.load = function (t) {
									var e = new S(),
										n = this.c,
										i = new P(this.a.api, this.a.text),
										r = this.a.families;
									!(function (t, e) {
										for (var n = e.length, i = 0; i < n; i++) {
											var r = e[i].split(":");
											3 == r.length && t.f.push(r.pop());
											var o = "";
											2 == r.length && "" != r[1] && (o = ":"),
												t.a.push(r.join(o));
										}
									})(i, r);
									var o = new Y(r);
									!(function (t) {
										for (var e = t.f.length, n = 0; n < e; n++) {
											var i = t.f[n].split(":"),
												r = i[0].replace(/\+/g, " "),
												o = ["n4"];
											if (2 <= i.length) {
												var a;
												if (((a = []), (s = i[1])))
													for (
														var s, c = (s = s.split(",")).length, l = 0;
														l < c;
														l++
													) {
														var h;
														if ((h = s[l]).match(/^[\w-]+$/))
															if (null == (p = et.exec(h.toLowerCase())))
																h = "";
															else {
																if (
																	((h =
																		null == (h = p[2]) || "" == h
																			? "n"
																			: tt[h]),
																	null == (p = p[1]) || "" == p)
																)
																	p = "4";
																else
																	var p =
																		$[p] || (isNaN(p) ? "4" : p.substr(0, 1));
																h = [h, p].join("");
															}
														else h = "";
														h && a.push(h);
													}
												0 < a.length && (o = a),
													3 == i.length &&
														((a = []),
														0 < (i = (i = i[2]) ? i.split(",") : a).length &&
															(i = X[i[0]]) &&
															(t.c[r] = i));
											}
											for (
												t.c[r] || ((i = X[r]) && (t.c[r] = i)), i = 0;
												i < o.length;
												i += 1
											)
												t.a.push(new M(r, o[i]));
										}
									})(o),
										f(
											n,
											(function (t) {
												if (0 == t.a.length) throw Error("No fonts to load!");
												if (-1 != t.c.indexOf("kit=")) return t.c;
												for (var e = t.a.length, n = [], i = 0; i < e; i++)
													n.push(t.a[i].replace(/ /g, "+"));
												return (
													(e = t.c + "?family=" + n.join("%7C")),
													0 < t.f.length && (e += "&subset=" + t.f.join(",")),
													0 < t.g.length &&
														(e += "&text=" + encodeURIComponent(t.g)),
													e
												);
											})(i),
											y(e)
										),
										V(e, function () {
											t(o.a, o.c, it);
										});
								}),
									(rt.prototype.load = function (t) {
										var e = this.a.id,
											n = this.c.o;
										e
											? g(
													this.c,
													(this.a.api || "https://use.typekit.net") +
														"/" +
														e +
														".js",
													function (e) {
														if (e) t([]);
														else if (
															n.Typekit &&
															n.Typekit.config &&
															n.Typekit.config.fn
														) {
															e = n.Typekit.config.fn;
															for (var i = [], r = 0; r < e.length; r += 2)
																for (
																	var o = e[r], a = e[r + 1], s = 0;
																	s < a.length;
																	s++
																)
																	i.push(new M(o, a[s]));
															try {
																n.Typekit.load({
																	events: !1,
																	classes: !1,
																	async: !0,
																});
															} catch (t) {}
															t(i);
														}
													},
													2e3
											  )
											: t([]);
									}),
									(ot.prototype.load = function (t) {
										var e = this.f.id,
											n = this.c.o,
											i = this;
										e
											? (n.__webfontfontdeckmodule__ ||
													(n.__webfontfontdeckmodule__ = {}),
											  (n.__webfontfontdeckmodule__[e] = function (e, n) {
													for (var r = 0, o = n.fonts.length; r < o; ++r) {
														var a = n.fonts[r];
														i.a.push(
															new M(
																a.name,
																U(
																	"font-weight:" +
																		a.weight +
																		";font-style:" +
																		a.style
																)
															)
														);
													}
													t(i.a);
											  }),
											  g(
													this.c,
													(this.f.api || "https://f.fontdeck.com/s/css/js/") +
														(function (t) {
															return (
																t.o.location.hostname || t.a.location.hostname
															);
														})(this.c) +
														"/" +
														e +
														".js",
													function (e) {
														e && t([]);
													}
											  ))
											: t([]);
									});
								var at = new B(window);
								(at.a.c.custom = function (t, e) {
									return new _(e, t);
								}),
									(at.a.c.fontdeck = function (t, e) {
										return new ot(e, t);
									}),
									(at.a.c.monotype = function (t, e) {
										return new Q(e, t);
									}),
									(at.a.c.typekit = function (t, e) {
										return new rt(e, t);
									}),
									(at.a.c.google = function (t, e) {
										return new nt(e, t);
									});
								var st = { load: a(at.load, at) };
								void 0 ===
									(i = function () {
										return st;
									}.call(e, n, e, t)) || (t.exports = i);
							})();
						},
					},
					e = {};
				function n(i) {
					var r = e[i];
					if (void 0 !== r) return r.exports;
					var o = (e[i] = { id: i, exports: {} });
					return t[i].call(o.exports, o, o.exports, n), o.exports;
				}
				(n.n = (t) => {
					var e = t && t.__esModule ? () => t.default : () => t;
					return n.d(e, { a: e }), e;
				}),
					(n.d = (t, e) => {
						for (var i in e)
							n.o(e, i) &&
								!n.o(t, i) &&
								Object.defineProperty(t, i, { enumerable: !0, get: e[i] });
					}),
					(n.o = (t, e) => Object.prototype.hasOwnProperty.call(t, e)),
					(() => {
						"use strict";
						function t(t) {
							if (void 0 === t)
								throw new ReferenceError(
									"this hasn't been initialised - super() hasn't been called"
								);
							return t;
						}
						function e(t, e) {
							(t.prototype = Object.create(e.prototype)),
								(t.prototype.constructor = t),
								(t.__proto__ = e);
						}
						var i,
							r,
							o,
							a,
							s,
							c,
							l,
							h,
							p,
							u,
							d,
							m,
							f,
							g,
							S,
							y,
							V,
							q,
							R,
							M,
							I,
							v,
							k,
							U,
							w,
							x,
							O,
							b,
							K = {
								autoSleep: 120,
								force3D: "auto",
								nullTargetWarn: 1,
								units: { lineHeight: "" },
							},
							T = { duration: 0.5, overwrite: !1, delay: 0 },
							z = 1e8,
							W = 1e-8,
							E = 2 * Math.PI,
							C = E / 4,
							F = 0,
							Z = Math.sqrt,
							H = Math.cos,
							N = Math.sin,
							j = function (t) {
								return "string" == typeof t;
							},
							D = function (t) {
								return "function" == typeof t;
							},
							A = function (t) {
								return "number" == typeof t;
							},
							L = function (t) {
								return void 0 === t;
							},
							B = function (t) {
								return "object" == typeof t;
							},
							G = function (t) {
								return !1 !== t;
							},
							Q = function () {
								return "undefined" != typeof window;
							},
							_ = function (t) {
								return D(t) || j(t);
							},
							P =
								("function" == typeof ArrayBuffer && ArrayBuffer.isView) ||
								function () {},
							J = Array.isArray,
							Y = /(?:-?\.?\d|\.)+/gi,
							X = /[-+=.]*\d+[.e\-+]*\d*[e\-+]*\d*/g,
							$ = /[-+=.]*\d+[.e-]*\d*[a-z%]*/g,
							tt = /[-+=.]*\d+\.?\d*(?:e-|e\+)?\d*/gi,
							et = /[+-]=-?[.\d]+/,
							nt = /[#\-+.]*\b[a-z\d-=+%.]+/gi,
							it = /[\d.+\-=]+(?:e[-+]\d*)*/i,
							rt = {},
							ot = {},
							at = function (t) {
								return (ot = Tt(t, rt)) && Sn;
							},
							st = function (t, e) {
								return console.warn(
									"Invalid property",
									t,
									"set to",
									e,
									"Missing plugin? gsap.registerPlugin()"
								);
							},
							ct = function (t, e) {
								return !e && console.warn(t);
							},
							lt = function (t, e) {
								return (t && (rt[t] = e) && ot && (ot[t] = e)) || rt;
							},
							ht = function () {
								return 0;
							},
							pt = {},
							ut = [],
							dt = {},
							mt = {},
							ft = {},
							gt = 30,
							St = [],
							yt = "",
							Vt = function (t) {
								var e,
									n,
									i = t[0];
								if (
									(B(i) || D(i) || (t = [t]), !(e = (i._gsap || {}).harness))
								) {
									for (n = St.length; n-- && !St[n].targetTest(i); );
									e = St[n];
								}
								for (n = t.length; n--; )
									(t[n] && (t[n]._gsap || (t[n]._gsap = new je(t[n], e)))) ||
										t.splice(n, 1);
								return t;
							},
							qt = function (t) {
								return t._gsap || Vt(ae(t))[0]._gsap;
							},
							Rt = function (t, e, n) {
								return (n = t[e]) && D(n)
									? t[e]()
									: (L(n) && t.getAttribute && t.getAttribute(e)) || n;
							},
							Mt = function (t, e) {
								return (t = t.split(",")).forEach(e) || t;
							},
							It = function (t) {
								return Math.round(1e5 * t) / 1e5 || 0;
							},
							vt = function (t, e) {
								for (var n = e.length, i = 0; t.indexOf(e[i]) < 0 && ++i < n; );
								return i < n;
							},
							kt = function (t, e, n) {
								var i,
									r = A(t[1]),
									o = (r ? 2 : 1) + (e < 2 ? 0 : 1),
									a = t[o];
								if ((r && (a.duration = t[1]), (a.parent = n), e)) {
									for (i = a; n && !("immediateRender" in i); )
										(i = n.vars.defaults || {}),
											(n = G(n.vars.inherit) && n.parent);
									(a.immediateRender = G(i.immediateRender)),
										e < 2 ? (a.runBackwards = 1) : (a.startAt = t[o - 1]);
								}
								return a;
							},
							Ut = function () {
								var t,
									e,
									n = ut.length,
									i = ut.slice(0);
								for (dt = {}, ut.length = 0, t = 0; t < n; t++)
									(e = i[t]) &&
										e._lazy &&
										(e.render(e._lazy[0], e._lazy[1], !0)._lazy = 0);
							},
							wt = function (t, e, n, i) {
								ut.length && Ut(), t.render(e, n, i), ut.length && Ut();
							},
							xt = function (t) {
								var e = parseFloat(t);
								return (e || 0 === e) && (t + "").match(nt).length < 2
									? e
									: j(t)
									? t.trim()
									: t;
							},
							Ot = function (t) {
								return t;
							},
							bt = function (t, e) {
								for (var n in e) n in t || (t[n] = e[n]);
								return t;
							},
							Kt = function (t, e) {
								for (var n in e)
									n in t || "duration" === n || "ease" === n || (t[n] = e[n]);
							},
							Tt = function (t, e) {
								for (var n in e) t[n] = e[n];
								return t;
							},
							zt = function t(e, n) {
								for (var i in n)
									"__proto__" !== i &&
										"constructor" !== i &&
										"prototype" !== i &&
										(e[i] = B(n[i]) ? t(e[i] || (e[i] = {}), n[i]) : n[i]);
								return e;
							},
							Wt = function (t, e) {
								var n,
									i = {};
								for (n in t) n in e || (i[n] = t[n]);
								return i;
							},
							Et = function (t) {
								var e = t.parent || r,
									n = t.keyframes ? Kt : bt;
								if (G(t.inherit))
									for (; e; ) n(t, e.vars.defaults), (e = e.parent || e._dp);
								return t;
							},
							Ct = function (t, e, n, i) {
								void 0 === n && (n = "_first"), void 0 === i && (i = "_last");
								var r = e._prev,
									o = e._next;
								r ? (r._next = o) : t[n] === e && (t[n] = o),
									o ? (o._prev = r) : t[i] === e && (t[i] = r),
									(e._next = e._prev = e.parent = null);
							},
							Ft = function (t, e) {
								t.parent &&
									(!e || t.parent.autoRemoveChildren) &&
									t.parent.remove(t),
									(t._act = 0);
							},
							Zt = function (t, e) {
								if (t && (!e || e._end > t._dur || e._start < 0))
									for (var n = t; n; ) (n._dirty = 1), (n = n.parent);
								return t;
							},
							Ht = function (t) {
								for (var e = t.parent; e && e.parent; )
									(e._dirty = 1), e.totalDuration(), (e = e.parent);
								return t;
							},
							Nt = function t(e) {
								return !e || (e._ts && t(e.parent));
							},
							jt = function (t) {
								return t._repeat
									? Dt(t._tTime, (t = t.duration() + t._rDelay)) * t
									: 0;
							},
							Dt = function (t, e) {
								var n = Math.floor((t /= e));
								return t && n === t ? n - 1 : n;
							},
							At = function (t, e) {
								return (
									(t - e._start) * e._ts +
									(e._ts >= 0 ? 0 : e._dirty ? e.totalDuration() : e._tDur)
								);
							},
							Lt = function (t) {
								return (t._end = It(
									t._start + (t._tDur / Math.abs(t._ts || t._rts || W) || 0)
								));
							},
							Bt = function (t, e) {
								var n = t._dp;
								return (
									n &&
										n.smoothChildTiming &&
										t._ts &&
										((t._start = It(
											n._time -
												(t._ts > 0
													? e / t._ts
													: ((t._dirty ? t.totalDuration() : t._tDur) - e) /
													  -t._ts)
										)),
										Lt(t),
										n._dirty || Zt(n, t)),
									t
								);
							},
							Gt = function (t, e) {
								var n;
								if (
									((e._time || (e._initted && !e._dur)) &&
										((n = At(t.rawTime(), e)),
										(!e._dur || ne(0, e.totalDuration(), n) - e._tTime > W) &&
											e.render(n, !0)),
									Zt(t, e)._dp && t._initted && t._time >= t._dur && t._ts)
								) {
									if (t._dur < t.duration())
										for (n = t; n._dp; )
											n.rawTime() >= 0 && n.totalTime(n._tTime), (n = n._dp);
									t._zTime = -1e-8;
								}
							},
							Qt = function (t, e, n, i) {
								return (
									e.parent && Ft(e),
									(e._start = It(n + e._delay)),
									(e._end = It(
										e._start +
											(e.totalDuration() / Math.abs(e.timeScale()) || 0)
									)),
									(function (t, e, n, i, r) {
										void 0 === n && (n = "_first"),
											void 0 === i && (i = "_last");
										var o,
											a = t[i];
										if (r) for (o = e[r]; a && a[r] > o; ) a = a._prev;
										a
											? ((e._next = a._next), (a._next = e))
											: ((e._next = t[n]), (t[n] = e)),
											e._next ? (e._next._prev = e) : (t[i] = e),
											(e._prev = a),
											(e.parent = e._dp = t);
									})(t, e, "_first", "_last", t._sort ? "_start" : 0),
									(t._recent = e),
									i || Gt(t, e),
									t
								);
							},
							_t = function (t, e) {
								return (
									(rt.ScrollTrigger || st("scrollTrigger", e)) &&
									rt.ScrollTrigger.create(e, t)
								);
							},
							Pt = function (t, e, n, i) {
								return (
									_e(t, e),
									t._initted
										? !n &&
										  t._pt &&
										  ((t._dur && !1 !== t.vars.lazy) ||
												(!t._dur && t.vars.lazy)) &&
										  l !== xe.frame
											? (ut.push(t), (t._lazy = [e, i]), 1)
											: void 0
										: 1
								);
							},
							Jt = function t(e) {
								var n = e.parent;
								return (
									n &&
									n._ts &&
									n._initted &&
									!n._lock &&
									(n.rawTime() < 0 || t(n))
								);
							},
							Yt = function (t, e, n, i) {
								var r = t._repeat,
									o = It(e) || 0,
									a = t._tTime / t._tDur;
								return (
									a && !i && (t._time *= o / t._dur),
									(t._dur = o),
									(t._tDur = r
										? r < 0
											? 1e10
											: It(o * (r + 1) + t._rDelay * r)
										: o),
									a && !i ? Bt(t, (t._tTime = t._tDur * a)) : t.parent && Lt(t),
									n || Zt(t.parent, t),
									t
								);
							},
							Xt = function (t) {
								return t instanceof Ae ? Zt(t) : Yt(t, t._dur);
							},
							$t = { _start: 0, endTime: ht },
							te = function t(e, n) {
								var i,
									r,
									o = e.labels,
									a = e._recent || $t,
									s = e.duration() >= z ? a.endTime(!1) : e._dur;
								return j(n) && (isNaN(n) || n in o)
									? "<" === (i = n.charAt(0)) || ">" === i
										? ("<" === i ? a._start : a.endTime(a._repeat >= 0)) +
										  (parseFloat(n.substr(1)) || 0)
										: (i = n.indexOf("=")) < 0
										? (n in o || (o[n] = s), o[n])
										: ((r = +(n.charAt(i - 1) + n.substr(i + 1))),
										  i > 1 ? t(e, n.substr(0, i - 1)) + r : s + r)
									: null == n
									? s
									: +n;
							},
							ee = function (t, e) {
								return t || 0 === t ? e(t) : e;
							},
							ne = function (t, e, n) {
								return n < t ? t : n > e ? e : n;
							},
							ie = function (t) {
								if ("string" != typeof t) return "";
								var e = it.exec(t);
								return e ? t.substr(e.index + e[0].length) : "";
							},
							re = [].slice,
							oe = function (t, e) {
								return (
									t &&
									B(t) &&
									"length" in t &&
									((!e && !t.length) || (t.length - 1 in t && B(t[0]))) &&
									!t.nodeType &&
									t !== o
								);
							},
							ae = function (t, e) {
								return !j(t) || e || (!a && Oe())
									? J(t)
										? (function (t, e, n) {
												return (
													void 0 === n && (n = []),
													t.forEach(function (t) {
														var i;
														return (j(t) && !e) || oe(t, 1)
															? (i = n).push.apply(i, ae(t))
															: n.push(t);
													}) || n
												);
										  })(t, e)
										: oe(t)
										? re.call(t, 0)
										: t
										? [t]
										: []
									: re.call(s.querySelectorAll(t), 0);
							},
							se = function (t) {
								return t.sort(function () {
									return 0.5 - Math.random();
								});
							},
							ce = function (t) {
								if (D(t)) return t;
								var e = B(t) ? t : { each: t },
									n = Ce(e.ease),
									i = e.from || 0,
									r = parseFloat(e.base) || 0,
									o = {},
									a = i > 0 && i < 1,
									s = isNaN(i) || a,
									c = e.axis,
									l = i,
									h = i;
								return (
									j(i)
										? (l = h = { center: 0.5, edges: 0.5, end: 1 }[i] || 0)
										: !a && s && ((l = i[0]), (h = i[1])),
									function (t, a, p) {
										var u,
											d,
											m,
											f,
											g,
											S,
											y,
											V,
											q,
											R = (p || e).length,
											M = o[R];
										if (!M) {
											if (
												!(q = "auto" === e.grid ? 0 : (e.grid || [1, z])[1])
											) {
												for (
													y = -z;
													y < (y = p[q++].getBoundingClientRect().left) &&
													q < R;

												);
												q--;
											}
											for (
												M = o[R] = [],
													u = s ? Math.min(q, R) * l - 0.5 : i % q,
													d = s ? (R * h) / q - 0.5 : (i / q) | 0,
													y = 0,
													V = z,
													S = 0;
												S < R;
												S++
											)
												(m = (S % q) - u),
													(f = d - ((S / q) | 0)),
													(M[S] = g =
														c ? Math.abs("y" === c ? f : m) : Z(m * m + f * f)),
													g > y && (y = g),
													g < V && (V = g);
											"random" === i && se(M),
												(M.max = y - V),
												(M.min = V),
												(M.v = R =
													(parseFloat(e.amount) ||
														parseFloat(e.each) *
															(q > R
																? R - 1
																: c
																? "y" === c
																	? R / q
																	: q
																: Math.max(q, R / q)) ||
														0) * ("edges" === i ? -1 : 1)),
												(M.b = R < 0 ? r - R : r),
												(M.u = ie(e.amount || e.each) || 0),
												(n = n && R < 0 ? We(n) : n);
										}
										return (
											(R = (M[t] - M.min) / M.max || 0),
											It(M.b + (n ? n(R) : R) * M.v) + M.u
										);
									}
								);
							},
							le = function (t) {
								var e = t < 1 ? Math.pow(10, (t + "").length - 2) : 1;
								return function (n) {
									var i = Math.round(parseFloat(n) / t) * t * e;
									return (i - (i % 1)) / e + (A(n) ? 0 : ie(n));
								};
							},
							he = function (t, e) {
								var n,
									i,
									r = J(t);
								return (
									!r &&
										B(t) &&
										((n = r = t.radius || z),
										t.values
											? ((t = ae(t.values)), (i = !A(t[0])) && (n *= n))
											: (t = le(t.increment))),
									ee(
										e,
										r
											? D(t)
												? function (e) {
														return (i = t(e)), Math.abs(i - e) <= n ? i : e;
												  }
												: function (e) {
														for (
															var r,
																o,
																a = parseFloat(i ? e.x : e),
																s = parseFloat(i ? e.y : 0),
																c = z,
																l = 0,
																h = t.length;
															h--;

														)
															(r = i
																? (r = t[h].x - a) * r + (o = t[h].y - s) * o
																: Math.abs(t[h] - a)) < c && ((c = r), (l = h));
														return (
															(l = !n || c <= n ? t[l] : e),
															i || l === e || A(e) ? l : l + ie(e)
														);
												  }
											: le(t)
									)
								);
							},
							pe = function (t, e, n, i) {
								return ee(J(t) ? !e : !0 === n ? !!(n = 0) : !i, function () {
									return J(t)
										? t[~~(Math.random() * t.length)]
										: (n = n || 1e-5) &&
												(i = n < 1 ? Math.pow(10, (n + "").length - 2) : 1) &&
												Math.floor(
													Math.round(
														(t - n / 2 + Math.random() * (e - t + 0.99 * n)) / n
													) *
														n *
														i
												) / i;
								});
							},
							ue = function (t, e, n) {
								return ee(n, function (n) {
									return t[~~e(n)];
								});
							},
							de = function (t) {
								for (
									var e, n, i, r, o = 0, a = "";
									~(e = t.indexOf("random(", o));

								)
									(i = t.indexOf(")", e)),
										(r = "[" === t.charAt(e + 7)),
										(n = t.substr(e + 7, i - e - 7).match(r ? nt : Y)),
										(a +=
											t.substr(o, e - o) +
											pe(r ? n : +n[0], r ? 0 : +n[1], +n[2] || 1e-5)),
										(o = i + 1);
								return a + t.substr(o, t.length - o);
							},
							me = function (t, e, n, i, r) {
								var o = e - t,
									a = i - n;
								return ee(r, function (e) {
									return n + (((e - t) / o) * a || 0);
								});
							},
							fe = function (t, e, n) {
								var i,
									r,
									o,
									a = t.labels,
									s = z;
								for (i in a)
									(r = a[i] - e) < 0 == !!n &&
										r &&
										s > (r = Math.abs(r)) &&
										((o = i), (s = r));
								return o;
							},
							ge = function (t, e, n) {
								var i,
									r,
									o = t.vars,
									a = o[e];
								if (a)
									return (
										(i = o[e + "Params"]),
										(r = o.callbackScope || t),
										n && ut.length && Ut(),
										i ? a.apply(r, i) : a.call(r)
									);
							},
							Se = function (t) {
								return (
									Ft(t),
									t.scrollTrigger && t.scrollTrigger.kill(!1),
									t.progress() < 1 && ge(t, "onInterrupt"),
									t
								);
							},
							ye = function (t) {
								var e = (t = (!t.name && t.default) || t).name,
									n = D(t),
									i =
										e && !n && t.init
											? function () {
													this._props = [];
											  }
											: t,
									r = {
										init: ht,
										render: cn,
										add: Ge,
										kill: hn,
										modifier: ln,
										rawVars: 0,
									},
									o = {
										targetTest: 0,
										get: 0,
										getSetter: rn,
										aliases: {},
										register: 0,
									};
								if ((Oe(), t !== i)) {
									if (mt[e]) return;
									bt(i, bt(Wt(t, r), o)),
										Tt(i.prototype, Tt(r, Wt(t, o))),
										(mt[(i.prop = e)] = i),
										t.targetTest && (St.push(i), (pt[e] = 1)),
										(e =
											("css" === e
												? "CSS"
												: e.charAt(0).toUpperCase() + e.substr(1)) + "Plugin");
								}
								lt(e, i), t.register && t.register(Sn, i, dn);
							},
							Ve = 255,
							qe = {
								aqua: [0, Ve, Ve],
								lime: [0, Ve, 0],
								silver: [192, 192, 192],
								black: [0, 0, 0],
								maroon: [128, 0, 0],
								teal: [0, 128, 128],
								blue: [0, 0, Ve],
								navy: [0, 0, 128],
								white: [Ve, Ve, Ve],
								olive: [128, 128, 0],
								yellow: [Ve, Ve, 0],
								orange: [Ve, 165, 0],
								gray: [128, 128, 128],
								purple: [128, 0, 128],
								green: [0, 128, 0],
								red: [Ve, 0, 0],
								pink: [Ve, 192, 203],
								cyan: [0, Ve, Ve],
								transparent: [Ve, Ve, Ve, 0],
							},
							Re = function (t, e, n) {
								return (
									((6 * (t = t < 0 ? t + 1 : t > 1 ? t - 1 : t) < 1
										? e + (n - e) * t * 6
										: t < 0.5
										? n
										: 3 * t < 2
										? e + (n - e) * (2 / 3 - t) * 6
										: e) *
										Ve +
										0.5) |
									0
								);
							},
							Me = function (t, e, n) {
								var i,
									r,
									o,
									a,
									s,
									c,
									l,
									h,
									p,
									u,
									d = t
										? A(t)
											? [t >> 16, (t >> 8) & Ve, t & Ve]
											: 0
										: qe.black;
								if (!d) {
									if (
										("," === t.substr(-1) && (t = t.substr(0, t.length - 1)),
										qe[t])
									)
										d = qe[t];
									else if ("#" === t.charAt(0)) {
										if (
											(t.length < 6 &&
												((i = t.charAt(1)),
												(r = t.charAt(2)),
												(o = t.charAt(3)),
												(t =
													"#" +
													i +
													i +
													r +
													r +
													o +
													o +
													(5 === t.length ? t.charAt(4) + t.charAt(4) : ""))),
											9 === t.length)
										)
											return [
												(d = parseInt(t.substr(1, 6), 16)) >> 16,
												(d >> 8) & Ve,
												d & Ve,
												parseInt(t.substr(7), 16) / 255,
											];
										d = [
											(t = parseInt(t.substr(1), 16)) >> 16,
											(t >> 8) & Ve,
											t & Ve,
										];
									} else if ("hsl" === t.substr(0, 3))
										if (((d = u = t.match(Y)), e)) {
											if (~t.indexOf("="))
												return (
													(d = t.match(X)), n && d.length < 4 && (d[3] = 1), d
												);
										} else
											(a = (+d[0] % 360) / 360),
												(s = +d[1] / 100),
												(i =
													2 * (c = +d[2] / 100) -
													(r = c <= 0.5 ? c * (s + 1) : c + s - c * s)),
												d.length > 3 && (d[3] *= 1),
												(d[0] = Re(a + 1 / 3, i, r)),
												(d[1] = Re(a, i, r)),
												(d[2] = Re(a - 1 / 3, i, r));
									else d = t.match(Y) || qe.transparent;
									d = d.map(Number);
								}
								return (
									e &&
										!u &&
										((i = d[0] / Ve),
										(r = d[1] / Ve),
										(o = d[2] / Ve),
										(c =
											((l = Math.max(i, r, o)) + (h = Math.min(i, r, o))) / 2),
										l === h
											? (a = s = 0)
											: ((p = l - h),
											  (s = c > 0.5 ? p / (2 - l - h) : p / (l + h)),
											  (a =
													l === i
														? (r - o) / p + (r < o ? 6 : 0)
														: l === r
														? (o - i) / p + 2
														: (i - r) / p + 4),
											  (a *= 60)),
										(d[0] = ~~(a + 0.5)),
										(d[1] = ~~(100 * s + 0.5)),
										(d[2] = ~~(100 * c + 0.5))),
									n && d.length < 4 && (d[3] = 1),
									d
								);
							},
							Ie = function (t) {
								var e = [],
									n = [],
									i = -1;
								return (
									t.split(ke).forEach(function (t) {
										var r = t.match($) || [];
										e.push.apply(e, r), n.push((i += r.length + 1));
									}),
									(e.c = n),
									e
								);
							},
							ve = function (t, e, n) {
								var i,
									r,
									o,
									a,
									s = "",
									c = (t + s).match(ke),
									l = e ? "hsla(" : "rgba(",
									h = 0;
								if (!c) return t;
								if (
									((c = c.map(function (t) {
										return (
											(t = Me(t, e, 1)) &&
											l +
												(e
													? t[0] + "," + t[1] + "%," + t[2] + "%," + t[3]
													: t.join(",")) +
												")"
										);
									})),
									n && ((o = Ie(t)), (i = n.c).join(s) !== o.c.join(s)))
								)
									for (
										a = (r = t.replace(ke, "1").split($)).length - 1;
										h < a;
										h++
									)
										s +=
											r[h] +
											(~i.indexOf(h)
												? c.shift() || l + "0,0,0,0)"
												: (o.length ? o : c.length ? c : n).shift());
								if (!r)
									for (a = (r = t.split(ke)).length - 1; h < a; h++)
										s += r[h] + c[h];
								return s + r[a];
							},
							ke = (function () {
								var t,
									e =
										"(?:\\b(?:(?:rgb|rgba|hsl|hsla)\\(.+?\\))|\\B#(?:[0-9a-f]{3,4}){1,2}\\b";
								for (t in qe) e += "|" + t + "\\b";
								return new RegExp(e + ")", "gi");
							})(),
							Ue = /hsl[a]?\(/,
							we = function (t) {
								var e,
									n = t.join(" ");
								if (((ke.lastIndex = 0), ke.test(n)))
									return (
										(e = Ue.test(n)),
										(t[1] = ve(t[1], e)),
										(t[0] = ve(t[0], e, Ie(t[1]))),
										!0
									);
							},
							xe =
								((y = Date.now),
								(V = 500),
								(q = 33),
								(R = y()),
								(M = R),
								(v = I = 1e3 / 240),
								(U = function t(e) {
									var n,
										i,
										r,
										o,
										a = y() - M,
										s = !0 === e;
									if (
										(a > V && (R += a - q),
										((n = (r = (M += a) - R) - v) > 0 || s) &&
											((o = ++f.frame),
											(g = r - 1e3 * f.time),
											(f.time = r /= 1e3),
											(v += n + (n >= I ? 4 : I - n)),
											(i = 1)),
										s || (u = d(t)),
										i)
									)
										for (S = 0; S < k.length; S++) k[S](r, g, o, e);
								}),
								(f = {
									time: 0,
									frame: 0,
									tick: function () {
										U(!0);
									},
									deltaRatio: function (t) {
										return g / (1e3 / (t || 60));
									},
									wake: function () {
										c &&
											(!a &&
												Q() &&
												((o = a = window),
												(s = o.document || {}),
												(rt.gsap = Sn),
												(o.gsapVersions || (o.gsapVersions = [])).push(
													Sn.version
												),
												at(ot || o.GreenSockGlobals || (!o.gsap && o) || {}),
												(m = o.requestAnimationFrame)),
											u && f.sleep(),
											(d =
												m ||
												function (t) {
													return setTimeout(t, (v - 1e3 * f.time + 1) | 0);
												}),
											(p = 1),
											U(2));
									},
									sleep: function () {
										(m ? o.cancelAnimationFrame : clearTimeout)(u),
											(p = 0),
											(d = ht);
									},
									lagSmoothing: function (t, e) {
										(V = t || 1e8), (q = Math.min(e, V, 0));
									},
									fps: function (t) {
										(I = 1e3 / (t || 240)), (v = 1e3 * f.time + I);
									},
									add: function (t) {
										k.indexOf(t) < 0 && k.push(t), Oe();
									},
									remove: function (t) {
										var e;
										~(e = k.indexOf(t)) && k.splice(e, 1) && S >= e && S--;
									},
									_listeners: (k = []),
								})),
							Oe = function () {
								return !p && xe.wake();
							},
							be = {},
							Ke = /^[\d.\-M][\d.\-,\s]/,
							Te = /["']/g,
							ze = function (t) {
								for (
									var e,
										n,
										i,
										r = {},
										o = t.substr(1, t.length - 3).split(":"),
										a = o[0],
										s = 1,
										c = o.length;
									s < c;
									s++
								)
									(n = o[s]),
										(e = s !== c - 1 ? n.lastIndexOf(",") : n.length),
										(i = n.substr(0, e)),
										(r[a] = isNaN(i) ? i.replace(Te, "").trim() : +i),
										(a = n.substr(e + 1).trim());
								return r;
							},
							We = function (t) {
								return function (e) {
									return 1 - t(1 - e);
								};
							},
							Ee = function t(e, n) {
								for (var i, r = e._first; r; )
									r instanceof Ae
										? t(r, n)
										: !r.vars.yoyoEase ||
										  (r._yoyo && r._repeat) ||
										  r._yoyo === n ||
										  (r.timeline
												? t(r.timeline, n)
												: ((i = r._ease),
												  (r._ease = r._yEase),
												  (r._yEase = i),
												  (r._yoyo = n))),
										(r = r._next);
							},
							Ce = function (t, e) {
								return (
									(t &&
										(D(t)
											? t
											: be[t] ||
											  (function (t) {
													var e,
														n,
														i,
														r,
														o = (t + "").split("("),
														a = be[o[0]];
													return a && o.length > 1 && a.config
														? a.config.apply(
																null,
																~t.indexOf("{")
																	? [ze(o[1])]
																	: ((e = t),
																	  (n = e.indexOf("(") + 1),
																	  (i = e.indexOf(")")),
																	  (r = e.indexOf("(", n)),
																	  e.substring(
																			n,
																			~r && r < i ? e.indexOf(")", i + 1) : i
																	  ))
																			.split(",")
																			.map(xt)
														  )
														: be._CE && Ke.test(t)
														? be._CE("", t)
														: a;
											  })(t))) ||
									e
								);
							},
							Fe = function (t, e, n, i) {
								void 0 === n &&
									(n = function (t) {
										return 1 - e(1 - t);
									}),
									void 0 === i &&
										(i = function (t) {
											return t < 0.5 ? e(2 * t) / 2 : 1 - e(2 * (1 - t)) / 2;
										});
								var r,
									o = { easeIn: e, easeOut: n, easeInOut: i };
								return (
									Mt(t, function (t) {
										for (var e in ((be[t] = rt[t] = o),
										(be[(r = t.toLowerCase())] = n),
										o))
											be[
												r +
													("easeIn" === e
														? ".in"
														: "easeOut" === e
														? ".out"
														: ".inOut")
											] = be[t + "." + e] = o[e];
									}),
									o
								);
							},
							Ze = function (t) {
								return function (e) {
									return e < 0.5
										? (1 - t(1 - 2 * e)) / 2
										: 0.5 + t(2 * (e - 0.5)) / 2;
								};
							},
							He = function t(e, n, i) {
								var r = n >= 1 ? n : 1,
									o = (i || (e ? 0.3 : 0.45)) / (n < 1 ? n : 1),
									a = (o / E) * (Math.asin(1 / r) || 0),
									s = function (t) {
										return 1 === t
											? 1
											: r * Math.pow(2, -10 * t) * N((t - a) * o) + 1;
									},
									c =
										"out" === e
											? s
											: "in" === e
											? function (t) {
													return 1 - s(1 - t);
											  }
											: Ze(s);
								return (
									(o = E / o),
									(c.config = function (n, i) {
										return t(e, n, i);
									}),
									c
								);
							},
							Ne = function t(e, n) {
								void 0 === n && (n = 1.70158);
								var i = function (t) {
										return t ? --t * t * ((n + 1) * t + n) + 1 : 0;
									},
									r =
										"out" === e
											? i
											: "in" === e
											? function (t) {
													return 1 - i(1 - t);
											  }
											: Ze(i);
								return (
									(r.config = function (n) {
										return t(e, n);
									}),
									r
								);
							};
						Mt("Linear,Quad,Cubic,Quart,Quint,Strong", function (t, e) {
							var n = e < 5 ? e + 1 : e;
							Fe(
								t + ",Power" + (n - 1),
								e
									? function (t) {
											return Math.pow(t, n);
									  }
									: function (t) {
											return t;
									  },
								function (t) {
									return 1 - Math.pow(1 - t, n);
								},
								function (t) {
									return t < 0.5
										? Math.pow(2 * t, n) / 2
										: 1 - Math.pow(2 * (1 - t), n) / 2;
								}
							);
						}),
							(be.Linear.easeNone = be.none = be.Linear.easeIn),
							Fe("Elastic", He("in"), He("out"), He()),
							(w = 7.5625),
							(O = 1 / (x = 2.75)),
							Fe(
								"Bounce",
								function (t) {
									return 1 - b(1 - t);
								},
								(b = function (t) {
									return t < O
										? w * t * t
										: t < 0.7272727272727273
										? w * Math.pow(t - 1.5 / x, 2) + 0.75
										: t < 0.9090909090909092
										? w * (t -= 2.25 / x) * t + 0.9375
										: w * Math.pow(t - 2.625 / x, 2) + 0.984375;
								})
							),
							Fe("Expo", function (t) {
								return t ? Math.pow(2, 10 * (t - 1)) : 0;
							}),
							Fe("Circ", function (t) {
								return -(Z(1 - t * t) - 1);
							}),
							Fe("Sine", function (t) {
								return 1 === t ? 1 : 1 - H(t * C);
							}),
							Fe("Back", Ne("in"), Ne("out"), Ne()),
							(be.SteppedEase =
								be.steps =
								rt.SteppedEase =
									{
										config: function (t, e) {
											void 0 === t && (t = 1);
											var n = 1 / t,
												i = t + (e ? 0 : 1),
												r = e ? 1 : 0;
											return function (t) {
												return (((i * ne(0, 0.99999999, t)) | 0) + r) * n;
											};
										},
									}),
							(T.ease = be["quad.out"]),
							Mt(
								"onComplete,onUpdate,onStart,onRepeat,onReverseComplete,onInterrupt",
								function (t) {
									return (yt += t + "," + t + "Params,");
								}
							);
						var je = function (t, e) {
								(this.id = F++),
									(t._gsap = this),
									(this.target = t),
									(this.harness = e),
									(this.get = e ? e.get : Rt),
									(this.set = e ? e.getSetter : rn);
							},
							De = (function () {
								function t(t, e) {
									var n = t.parent || r;
									(this.vars = t),
										(this._delay = +t.delay || 0),
										(this._repeat = t.repeat === 1 / 0 ? -2 : t.repeat || 0) &&
											((this._rDelay = t.repeatDelay || 0),
											(this._yoyo = !!t.yoyo || !!t.yoyoEase)),
										(this._ts = 1),
										Yt(this, +t.duration, 1, 1),
										(this.data = t.data),
										p || xe.wake(),
										n && Qt(n, this, e || 0 === e ? e : n._time, 1),
										t.reversed && this.reverse(),
										t.paused && this.paused(!0);
								}
								var e = t.prototype;
								return (
									(e.delay = function (t) {
										return t || 0 === t
											? (this.parent &&
													this.parent.smoothChildTiming &&
													this.startTime(this._start + t - this._delay),
											  (this._delay = t),
											  this)
											: this._delay;
									}),
									(e.duration = function (t) {
										return arguments.length
											? this.totalDuration(
													this._repeat > 0
														? t + (t + this._rDelay) * this._repeat
														: t
											  )
											: this.totalDuration() && this._dur;
									}),
									(e.totalDuration = function (t) {
										return arguments.length
											? ((this._dirty = 0),
											  Yt(
													this,
													this._repeat < 0
														? t
														: (t - this._repeat * this._rDelay) /
																(this._repeat + 1)
											  ))
											: this._tDur;
									}),
									(e.totalTime = function (t, e) {
										if ((Oe(), !arguments.length)) return this._tTime;
										var n = this._dp;
										if (n && n.smoothChildTiming && this._ts) {
											for (
												Bt(this, t), !n._dp || n.parent || Gt(n, this);
												n.parent;

											)
												n.parent._time !==
													n._start +
														(n._ts >= 0
															? n._tTime / n._ts
															: (n.totalDuration() - n._tTime) / -n._ts) &&
													n.totalTime(n._tTime, !0),
													(n = n.parent);
											!this.parent &&
												this._dp.autoRemoveChildren &&
												((this._ts > 0 && t < this._tDur) ||
													(this._ts < 0 && t > 0) ||
													(!this._tDur && !t)) &&
												Qt(this._dp, this, this._start - this._delay);
										}
										return (
											(this._tTime !== t ||
												(!this._dur && !e) ||
												(this._initted && Math.abs(this._zTime) === W) ||
												(!t &&
													!this._initted &&
													(this.add || this._ptLookup))) &&
												(this._ts || (this._pTime = t), wt(this, t, e)),
											this
										);
									}),
									(e.time = function (t, e) {
										return arguments.length
											? this.totalTime(
													Math.min(this.totalDuration(), t + jt(this)) %
														this._dur || (t ? this._dur : 0),
													e
											  )
											: this._time;
									}),
									(e.totalProgress = function (t, e) {
										return arguments.length
											? this.totalTime(this.totalDuration() * t, e)
											: this.totalDuration()
											? Math.min(1, this._tTime / this._tDur)
											: this.ratio;
									}),
									(e.progress = function (t, e) {
										return arguments.length
											? this.totalTime(
													this.duration() *
														(!this._yoyo || 1 & this.iteration() ? t : 1 - t) +
														jt(this),
													e
											  )
											: this.duration()
											? Math.min(1, this._time / this._dur)
											: this.ratio;
									}),
									(e.iteration = function (t, e) {
										var n = this.duration() + this._rDelay;
										return arguments.length
											? this.totalTime(this._time + (t - 1) * n, e)
											: this._repeat
											? Dt(this._tTime, n) + 1
											: 1;
									}),
									(e.timeScale = function (t) {
										if (!arguments.length)
											return -1e-8 === this._rts ? 0 : this._rts;
										if (this._rts === t) return this;
										var e =
											this.parent && this._ts
												? At(this.parent._time, this)
												: this._tTime;
										return (
											(this._rts = +t || 0),
											(this._ts = this._ps || -1e-8 === t ? 0 : this._rts),
											Ht(this.totalTime(ne(-this._delay, this._tDur, e), !0))
										);
									}),
									(e.paused = function (t) {
										return arguments.length
											? (this._ps !== t &&
													((this._ps = t),
													t
														? ((this._pTime =
																this._tTime ||
																Math.max(-this._delay, this.rawTime())),
														  (this._ts = this._act = 0))
														: (Oe(),
														  (this._ts = this._rts),
														  this.totalTime(
																this.parent && !this.parent.smoothChildTiming
																	? this.rawTime()
																	: this._tTime || this._pTime,
																1 === this.progress() &&
																	(this._tTime -= W) &&
																	Math.abs(this._zTime) !== W
														  ))),
											  this)
											: this._ps;
									}),
									(e.startTime = function (t) {
										if (arguments.length) {
											this._start = t;
											var e = this.parent || this._dp;
											return (
												e &&
													(e._sort || !this.parent) &&
													Qt(e, this, t - this._delay),
												this
											);
										}
										return this._start;
									}),
									(e.endTime = function (t) {
										return (
											this._start +
											(G(t) ? this.totalDuration() : this.duration()) /
												Math.abs(this._ts)
										);
									}),
									(e.rawTime = function (t) {
										var e = this.parent || this._dp;
										return e
											? t &&
											  (!this._ts ||
													(this._repeat &&
														this._time &&
														this.totalProgress() < 1))
												? this._tTime % (this._dur + this._rDelay)
												: this._ts
												? At(e.rawTime(t), this)
												: this._tTime
											: this._tTime;
									}),
									(e.globalTime = function (t) {
										for (
											var e = this, n = arguments.length ? t : e.rawTime();
											e;

										)
											(n = e._start + n / (e._ts || 1)), (e = e._dp);
										return n;
									}),
									(e.repeat = function (t) {
										return arguments.length
											? ((this._repeat = t === 1 / 0 ? -2 : t), Xt(this))
											: -2 === this._repeat
											? 1 / 0
											: this._repeat;
									}),
									(e.repeatDelay = function (t) {
										return arguments.length
											? ((this._rDelay = t), Xt(this))
											: this._rDelay;
									}),
									(e.yoyo = function (t) {
										return arguments.length
											? ((this._yoyo = t), this)
											: this._yoyo;
									}),
									(e.seek = function (t, e) {
										return this.totalTime(te(this, t), G(e));
									}),
									(e.restart = function (t, e) {
										return this.play().totalTime(t ? -this._delay : 0, G(e));
									}),
									(e.play = function (t, e) {
										return (
											null != t && this.seek(t, e), this.reversed(!1).paused(!1)
										);
									}),
									(e.reverse = function (t, e) {
										return (
											null != t && this.seek(t || this.totalDuration(), e),
											this.reversed(!0).paused(!1)
										);
									}),
									(e.pause = function (t, e) {
										return null != t && this.seek(t, e), this.paused(!0);
									}),
									(e.resume = function () {
										return this.paused(!1);
									}),
									(e.reversed = function (t) {
										return arguments.length
											? (!!t !== this.reversed() &&
													this.timeScale(-this._rts || (t ? -1e-8 : 0)),
											  this)
											: this._rts < 0;
									}),
									(e.invalidate = function () {
										return (
											(this._initted = this._act = 0),
											(this._zTime = -1e-8),
											this
										);
									}),
									(e.isActive = function () {
										var t,
											e = this.parent || this._dp,
											n = this._start;
										return !(
											e &&
											!(
												this._ts &&
												this._initted &&
												e.isActive() &&
												(t = e.rawTime(!0)) >= n &&
												t < this.endTime(!0) - W
											)
										);
									}),
									(e.eventCallback = function (t, e, n) {
										var i = this.vars;
										return arguments.length > 1
											? (e
													? ((i[t] = e),
													  n && (i[t + "Params"] = n),
													  "onUpdate" === t && (this._onUpdate = e))
													: delete i[t],
											  this)
											: i[t];
									}),
									(e.then = function (t) {
										var e = this;
										return new Promise(function (n) {
											var i = D(t) ? t : Ot,
												r = function () {
													var t = e.then;
													(e.then = null),
														D(i) &&
															(i = i(e)) &&
															(i.then || i === e) &&
															(e.then = t),
														n(i),
														(e.then = t);
												};
											(e._initted && 1 === e.totalProgress() && e._ts >= 0) ||
											(!e._tTime && e._ts < 0)
												? r()
												: (e._prom = r);
										});
									}),
									(e.kill = function () {
										Se(this);
									}),
									t
								);
							})();
						bt(De.prototype, {
							_time: 0,
							_start: 0,
							_end: 0,
							_tTime: 0,
							_tDur: 0,
							_dirty: 0,
							_repeat: 0,
							_yoyo: !1,
							parent: null,
							_initted: !1,
							_rDelay: 0,
							_ts: 1,
							_dp: 0,
							ratio: 0,
							_zTime: -1e-8,
							_prom: 0,
							_ps: !1,
							_rts: 1,
						});
						var Ae = (function (n) {
							function i(e, i) {
								var r;
								return (
									void 0 === e && (e = {}),
									((r = n.call(this, e, i) || this).labels = {}),
									(r.smoothChildTiming = !!e.smoothChildTiming),
									(r.autoRemoveChildren = !!e.autoRemoveChildren),
									(r._sort = G(e.sortChildren)),
									r.parent && Gt(r.parent, t(r)),
									e.scrollTrigger && _t(t(r), e.scrollTrigger),
									r
								);
							}
							e(i, n);
							var o = i.prototype;
							return (
								(o.to = function (t, e, n) {
									return (
										new Xe(
											t,
											kt(arguments, 0, this),
											te(this, A(e) ? arguments[3] : n)
										),
										this
									);
								}),
								(o.from = function (t, e, n) {
									return (
										new Xe(
											t,
											kt(arguments, 1, this),
											te(this, A(e) ? arguments[3] : n)
										),
										this
									);
								}),
								(o.fromTo = function (t, e, n, i) {
									return (
										new Xe(
											t,
											kt(arguments, 2, this),
											te(this, A(e) ? arguments[4] : i)
										),
										this
									);
								}),
								(o.set = function (t, e, n) {
									return (
										(e.duration = 0),
										(e.parent = this),
										Et(e).repeatDelay || (e.repeat = 0),
										(e.immediateRender = !!e.immediateRender),
										new Xe(t, e, te(this, n), 1),
										this
									);
								}),
								(o.call = function (t, e, n) {
									return Qt(this, Xe.delayedCall(0, t, e), te(this, n));
								}),
								(o.staggerTo = function (t, e, n, i, r, o, a) {
									return (
										(n.duration = e),
										(n.stagger = n.stagger || i),
										(n.onComplete = o),
										(n.onCompleteParams = a),
										(n.parent = this),
										new Xe(t, n, te(this, r)),
										this
									);
								}),
								(o.staggerFrom = function (t, e, n, i, r, o, a) {
									return (
										(n.runBackwards = 1),
										(Et(n).immediateRender = G(n.immediateRender)),
										this.staggerTo(t, e, n, i, r, o, a)
									);
								}),
								(o.staggerFromTo = function (t, e, n, i, r, o, a, s) {
									return (
										(i.startAt = n),
										(Et(i).immediateRender = G(i.immediateRender)),
										this.staggerTo(t, e, i, r, o, a, s)
									);
								}),
								(o.render = function (t, e, n) {
									var i,
										o,
										a,
										s,
										c,
										l,
										h,
										p,
										u,
										d,
										m,
										f,
										g = this._time,
										S = this._dirty ? this.totalDuration() : this._tDur,
										y = this._dur,
										V = this !== r && t > S - W && t >= 0 ? S : t < W ? 0 : t,
										q = this._zTime < 0 != t < 0 && (this._initted || !y);
									if (V !== this._tTime || n || q) {
										if (
											(g !== this._time &&
												y &&
												((V += this._time - g), (t += this._time - g)),
											(i = V),
											(u = this._start),
											(l = !(p = this._ts)),
											q &&
												(y || (g = this._zTime),
												(t || !e) && (this._zTime = t)),
											this._repeat)
										) {
											if (
												((m = this._yoyo),
												(c = y + this._rDelay),
												this._repeat < -1 && t < 0)
											)
												return this.totalTime(100 * c + t, e, n);
											if (
												((i = It(V % c)),
												V === S
													? ((s = this._repeat), (i = y))
													: ((s = ~~(V / c)) && s === V / c && ((i = y), s--),
													  i > y && (i = y)),
												(d = Dt(this._tTime, c)),
												!g && this._tTime && d !== s && (d = s),
												m && 1 & s && ((i = y - i), (f = 1)),
												s !== d && !this._lock)
											) {
												var R = m && 1 & d,
													M = R === (m && 1 & s);
												if (
													(s < d && (R = !R),
													(g = R ? 0 : y),
													(this._lock = 1),
													(this.render(
														g || (f ? 0 : It(s * c)),
														e,
														!y
													)._lock = 0),
													!e && this.parent && ge(this, "onRepeat"),
													this.vars.repeatRefresh &&
														!f &&
														(this.invalidate()._lock = 1),
													(g && g !== this._time) ||
														l !== !this._ts ||
														(this.vars.onRepeat && !this.parent && !this._act))
												)
													return this;
												if (
													((y = this._dur),
													(S = this._tDur),
													M &&
														((this._lock = 2),
														(g = R ? y : -1e-4),
														this.render(g, !0)),
													(this._lock = 0),
													!this._ts && !l)
												)
													return this;
												Ee(this, f);
											}
										}
										if (
											(this._hasPause &&
												!this._forcing &&
												this._lock < 2 &&
												(h = (function (t, e, n) {
													var i;
													if (n > e)
														for (i = t._first; i && i._start <= n; ) {
															if (
																!i._dur &&
																"isPause" === i.data &&
																i._start > e
															)
																return i;
															i = i._next;
														}
													else
														for (i = t._last; i && i._start >= n; ) {
															if (
																!i._dur &&
																"isPause" === i.data &&
																i._start < e
															)
																return i;
															i = i._prev;
														}
												})(this, It(g), It(i))) &&
												(V -= i - (i = h._start)),
											(this._tTime = V),
											(this._time = i),
											(this._act = !p),
											this._initted ||
												((this._onUpdate = this.vars.onUpdate),
												(this._initted = 1),
												(this._zTime = t),
												(g = 0)),
											!g && i && !e && ge(this, "onStart"),
											i >= g && t >= 0)
										)
											for (o = this._first; o; ) {
												if (
													((a = o._next),
													(o._act || i >= o._start) && o._ts && h !== o)
												) {
													if (o.parent !== this) return this.render(t, e, n);
													if (
														(o.render(
															o._ts > 0
																? (i - o._start) * o._ts
																: (o._dirty ? o.totalDuration() : o._tDur) +
																		(i - o._start) * o._ts,
															e,
															n
														),
														i !== this._time || (!this._ts && !l))
													) {
														(h = 0), a && (V += this._zTime = -1e-8);
														break;
													}
												}
												o = a;
											}
										else {
											o = this._last;
											for (var I = t < 0 ? t : i; o; ) {
												if (
													((a = o._prev),
													(o._act || I <= o._end) && o._ts && h !== o)
												) {
													if (o.parent !== this) return this.render(t, e, n);
													if (
														(o.render(
															o._ts > 0
																? (I - o._start) * o._ts
																: (o._dirty ? o.totalDuration() : o._tDur) +
																		(I - o._start) * o._ts,
															e,
															n
														),
														i !== this._time || (!this._ts && !l))
													) {
														(h = 0), a && (V += this._zTime = I ? -1e-8 : W);
														break;
													}
												}
												o = a;
											}
										}
										if (
											h &&
											!e &&
											(this.pause(),
											(h.render(i >= g ? 0 : -1e-8)._zTime = i >= g ? 1 : -1),
											this._ts)
										)
											return (this._start = u), Lt(this), this.render(t, e, n);
										this._onUpdate && !e && ge(this, "onUpdate", !0),
											((V === S && S >= this.totalDuration()) || (!V && g)) &&
												((u !== this._start &&
													Math.abs(p) === Math.abs(this._ts)) ||
													this._lock ||
													((t || !y) &&
														((V === S && this._ts > 0) ||
															(!V && this._ts < 0)) &&
														Ft(this, 1),
													e ||
														(t < 0 && !g) ||
														(!V && !g) ||
														(ge(
															this,
															V === S ? "onComplete" : "onReverseComplete",
															!0
														),
														this._prom &&
															!(V < S && this.timeScale() > 0) &&
															this._prom())));
									}
									return this;
								}),
								(o.add = function (t, e) {
									var n = this;
									if ((A(e) || (e = te(this, e)), !(t instanceof De))) {
										if (J(t))
											return (
												t.forEach(function (t) {
													return n.add(t, e);
												}),
												this
											);
										if (j(t)) return this.addLabel(t, e);
										if (!D(t)) return this;
										t = Xe.delayedCall(0, t);
									}
									return this !== t ? Qt(this, t, e) : this;
								}),
								(o.getChildren = function (t, e, n, i) {
									void 0 === t && (t = !0),
										void 0 === e && (e = !0),
										void 0 === n && (n = !0),
										void 0 === i && (i = -z);
									for (var r = [], o = this._first; o; )
										o._start >= i &&
											(o instanceof Xe
												? e && r.push(o)
												: (n && r.push(o),
												  t && r.push.apply(r, o.getChildren(!0, e, n)))),
											(o = o._next);
									return r;
								}),
								(o.getById = function (t) {
									for (var e = this.getChildren(1, 1, 1), n = e.length; n--; )
										if (e[n].vars.id === t) return e[n];
								}),
								(o.remove = function (t) {
									return j(t)
										? this.removeLabel(t)
										: D(t)
										? this.killTweensOf(t)
										: (Ct(this, t),
										  t === this._recent && (this._recent = this._last),
										  Zt(this));
								}),
								(o.totalTime = function (t, e) {
									return arguments.length
										? ((this._forcing = 1),
										  !this._dp &&
												this._ts &&
												(this._start = It(
													xe.time -
														(this._ts > 0
															? t / this._ts
															: (this.totalDuration() - t) / -this._ts)
												)),
										  n.prototype.totalTime.call(this, t, e),
										  (this._forcing = 0),
										  this)
										: this._tTime;
								}),
								(o.addLabel = function (t, e) {
									return (this.labels[t] = te(this, e)), this;
								}),
								(o.removeLabel = function (t) {
									return delete this.labels[t], this;
								}),
								(o.addPause = function (t, e, n) {
									var i = Xe.delayedCall(0, e || ht, n);
									return (
										(i.data = "isPause"),
										(this._hasPause = 1),
										Qt(this, i, te(this, t))
									);
								}),
								(o.removePause = function (t) {
									var e = this._first;
									for (t = te(this, t); e; )
										e._start === t && "isPause" === e.data && Ft(e),
											(e = e._next);
								}),
								(o.killTweensOf = function (t, e, n) {
									for (var i = this.getTweensOf(t, n), r = i.length; r--; )
										Le !== i[r] && i[r].kill(t, e);
									return this;
								}),
								(o.getTweensOf = function (t, e) {
									for (var n, i = [], r = ae(t), o = this._first, a = A(e); o; )
										o instanceof Xe
											? vt(o._targets, r) &&
											  (a
													? (!Le || (o._initted && o._ts)) &&
													  o.globalTime(0) <= e &&
													  o.globalTime(o.totalDuration()) > e
													: !e || o.isActive()) &&
											  i.push(o)
											: (n = o.getTweensOf(r, e)).length && i.push.apply(i, n),
											(o = o._next);
									return i;
								}),
								(o.tweenTo = function (t, e) {
									e = e || {};
									var n = this,
										i = te(n, t),
										r = e,
										o = r.startAt,
										a = r.onStart,
										s = r.onStartParams,
										c = r.immediateRender,
										l = Xe.to(
											n,
											bt(
												{
													ease: e.ease || "none",
													lazy: !1,
													immediateRender: !1,
													time: i,
													overwrite: "auto",
													duration:
														e.duration ||
														Math.abs(
															(i - (o && "time" in o ? o.time : n._time)) /
																n.timeScale()
														) ||
														W,
													onStart: function () {
														n.pause();
														var t =
															e.duration ||
															Math.abs((i - n._time) / n.timeScale());
														l._dur !== t &&
															Yt(l, t, 0, 1).render(l._time, !0, !0),
															a && a.apply(l, s || []);
													},
												},
												e
											)
										);
									return c ? l.render(0) : l;
								}),
								(o.tweenFromTo = function (t, e, n) {
									return this.tweenTo(
										e,
										bt({ startAt: { time: te(this, t) } }, n)
									);
								}),
								(o.recent = function () {
									return this._recent;
								}),
								(o.nextLabel = function (t) {
									return (
										void 0 === t && (t = this._time), fe(this, te(this, t))
									);
								}),
								(o.previousLabel = function (t) {
									return (
										void 0 === t && (t = this._time), fe(this, te(this, t), 1)
									);
								}),
								(o.currentLabel = function (t) {
									return arguments.length
										? this.seek(t, !0)
										: this.previousLabel(this._time + W);
								}),
								(o.shiftChildren = function (t, e, n) {
									void 0 === n && (n = 0);
									for (var i, r = this._first, o = this.labels; r; )
										r._start >= n && ((r._start += t), (r._end += t)),
											(r = r._next);
									if (e) for (i in o) o[i] >= n && (o[i] += t);
									return Zt(this);
								}),
								(o.invalidate = function () {
									var t = this._first;
									for (this._lock = 0; t; ) t.invalidate(), (t = t._next);
									return n.prototype.invalidate.call(this);
								}),
								(o.clear = function (t) {
									void 0 === t && (t = !0);
									for (var e, n = this._first; n; )
										(e = n._next), this.remove(n), (n = e);
									return (
										this._dp && (this._time = this._tTime = this._pTime = 0),
										t && (this.labels = {}),
										Zt(this)
									);
								}),
								(o.totalDuration = function (t) {
									var e,
										n,
										i,
										o = 0,
										a = this,
										s = a._last,
										c = z;
									if (arguments.length)
										return a.timeScale(
											(a._repeat < 0 ? a.duration() : a.totalDuration()) /
												(a.reversed() ? -t : t)
										);
									if (a._dirty) {
										for (i = a.parent; s; )
											(e = s._prev),
												s._dirty && s.totalDuration(),
												(n = s._start) > c && a._sort && s._ts && !a._lock
													? ((a._lock = 1),
													  (Qt(a, s, n - s._delay, 1)._lock = 0))
													: (c = n),
												n < 0 &&
													s._ts &&
													((o -= n),
													((!i && !a._dp) || (i && i.smoothChildTiming)) &&
														((a._start += n / a._ts),
														(a._time -= n),
														(a._tTime -= n)),
													a.shiftChildren(-n, !1, -Infinity),
													(c = 0)),
												s._end > o && s._ts && (o = s._end),
												(s = e);
										Yt(a, a === r && a._time > o ? a._time : o, 1, 1),
											(a._dirty = 0);
									}
									return a._tDur;
								}),
								(i.updateRoot = function (t) {
									if (
										(r._ts && (wt(r, At(t, r)), (l = xe.frame)), xe.frame >= gt)
									) {
										gt += K.autoSleep || 120;
										var e = r._first;
										if (
											(!e || !e._ts) &&
											K.autoSleep &&
											xe._listeners.length < 2
										) {
											for (; e && !e._ts; ) e = e._next;
											e || xe.sleep();
										}
									}
								}),
								i
							);
						})(De);
						bt(Ae.prototype, { _lock: 0, _hasPause: 0, _forcing: 0 });
						var Le,
							Be = function (t, e, n, i, r, o, a) {
								var s,
									c,
									l,
									h,
									p,
									u,
									d,
									m,
									f = new dn(this._pt, t, e, 0, 1, sn, null, r),
									g = 0,
									S = 0;
								for (
									f.b = n,
										f.e = i,
										n += "",
										(d = ~(i += "").indexOf("random(")) && (i = de(i)),
										o && (o((m = [n, i]), t, e), (n = m[0]), (i = m[1])),
										c = n.match(tt) || [];
									(s = tt.exec(i));

								)
									(h = s[0]),
										(p = i.substring(g, s.index)),
										l ? (l = (l + 1) % 5) : "rgba(" === p.substr(-5) && (l = 1),
										h !== c[S++] &&
											((u = parseFloat(c[S - 1]) || 0),
											(f._pt = {
												_next: f._pt,
												p: p || 1 === S ? p : ",",
												s: u,
												c:
													"=" === h.charAt(1)
														? parseFloat(h.substr(2)) *
														  ("-" === h.charAt(0) ? -1 : 1)
														: parseFloat(h) - u,
												m: l && l < 4 ? Math.round : 0,
											}),
											(g = tt.lastIndex));
								return (
									(f.c = g < i.length ? i.substring(g, i.length) : ""),
									(f.fp = a),
									(et.test(i) || d) && (f.e = 0),
									(this._pt = f),
									f
								);
							},
							Ge = function (t, e, n, i, r, o, a, s, c) {
								D(i) && (i = i(r || 0, t, o));
								var l,
									h = t[e],
									p =
										"get" !== n
											? n
											: D(h)
											? c
												? t[
														e.indexOf("set") || !D(t["get" + e.substr(3)])
															? e
															: "get" + e.substr(3)
												  ](c)
												: t[e]()
											: h,
									u = D(h) ? (c ? en : tn) : $e;
								if (
									(j(i) &&
										(~i.indexOf("random(") && (i = de(i)),
										"=" === i.charAt(1) &&
											(i =
												parseFloat(p) +
												parseFloat(i.substr(2)) *
													("-" === i.charAt(0) ? -1 : 1) +
												(ie(p) || 0))),
									p !== i)
								)
									return isNaN(p * i)
										? (!h && !(e in t) && st(e, i),
										  Be.call(this, t, e, p, i, u, s || K.stringFilter, c))
										: ((l = new dn(
												this._pt,
												t,
												e,
												+p || 0,
												i - (p || 0),
												"boolean" == typeof h ? an : on,
												0,
												u
										  )),
										  c && (l.fp = c),
										  a && l.modifier(a, this, t),
										  (this._pt = l));
							},
							Qe = function (t, e, n, i, r, o) {
								var a, s, c, l;
								if (
									mt[t] &&
									!1 !==
										(a = new mt[t]()).init(
											r,
											a.rawVars
												? e[t]
												: (function (t, e, n, i, r) {
														if (
															(D(t) && (t = Pe(t, r, e, n, i)),
															!B(t) || (t.style && t.nodeType) || J(t) || P(t))
														)
															return j(t) ? Pe(t, r, e, n, i) : t;
														var o,
															a = {};
														for (o in t) a[o] = Pe(t[o], r, e, n, i);
														return a;
												  })(e[t], i, r, o, n),
											n,
											i,
											o
										) &&
									((n._pt = s =
										new dn(n._pt, r, t, 0, 1, a.render, a, 0, a.priority)),
									n !== h)
								)
									for (
										c = n._ptLookup[n._targets.indexOf(r)], l = a._props.length;
										l--;

									)
										c[a._props[l]] = s;
								return a;
							},
							_e = function t(e, n) {
								var o,
									a,
									s,
									c,
									l,
									h,
									p,
									u,
									d,
									m,
									f,
									g,
									S,
									y = e.vars,
									V = y.ease,
									q = y.startAt,
									R = y.immediateRender,
									M = y.lazy,
									I = y.onUpdate,
									v = y.onUpdateParams,
									k = y.callbackScope,
									U = y.runBackwards,
									w = y.yoyoEase,
									x = y.keyframes,
									O = y.autoRevert,
									b = e._dur,
									K = e._startAt,
									z = e._targets,
									E = e.parent,
									C = E && "nested" === E.data ? E.parent._targets : z,
									F = "auto" === e._overwrite && !i,
									Z = e.timeline;
								if (
									(Z && (!x || !V) && (V = "none"),
									(e._ease = Ce(V, T.ease)),
									(e._yEase = w ? We(Ce(!0 === w ? V : w, T.ease)) : 0),
									w &&
										e._yoyo &&
										!e._repeat &&
										((w = e._yEase), (e._yEase = e._ease), (e._ease = w)),
									!Z)
								) {
									if (
										((g = (u = z[0] ? qt(z[0]).harness : 0) && y[u.prop]),
										(o = Wt(y, pt)),
										K && K.render(-1, !0).kill(),
										q)
									)
										if (
											(Ft(
												(e._startAt = Xe.set(
													z,
													bt(
														{
															data: "isStart",
															overwrite: !1,
															parent: E,
															immediateRender: !0,
															lazy: G(M),
															startAt: null,
															delay: 0,
															onUpdate: I,
															onUpdateParams: v,
															callbackScope: k,
															stagger: 0,
														},
														q
													)
												))
											),
											R)
										) {
											if (n > 0) O || (e._startAt = 0);
											else if (b && !(n < 0 && K))
												return void (n && (e._zTime = n));
										} else !1 === O && (e._startAt = 0);
									else if (U && b)
										if (K) !O && (e._startAt = 0);
										else if (
											(n && (R = !1),
											(s = bt(
												{
													overwrite: !1,
													data: "isFromStart",
													lazy: R && G(M),
													immediateRender: R,
													stagger: 0,
													parent: E,
												},
												o
											)),
											g && (s[u.prop] = g),
											Ft((e._startAt = Xe.set(z, s))),
											R)
										) {
											if (!n) return;
										} else t(e._startAt, W);
									for (
										e._pt = 0, M = (b && G(M)) || (M && !b), a = 0;
										a < z.length;
										a++
									) {
										if (
											((p = (l = z[a])._gsap || Vt(z)[a]._gsap),
											(e._ptLookup[a] = m = {}),
											dt[p.id] && ut.length && Ut(),
											(f = C === z ? a : C.indexOf(l)),
											u &&
												!1 !== (d = new u()).init(l, g || o, e, f, C) &&
												((e._pt = c =
													new dn(
														e._pt,
														l,
														d.name,
														0,
														1,
														d.render,
														d,
														0,
														d.priority
													)),
												d._props.forEach(function (t) {
													m[t] = c;
												}),
												d.priority && (h = 1)),
											!u || g)
										)
											for (s in o)
												mt[s] && (d = Qe(s, o, e, f, l, C))
													? d.priority && (h = 1)
													: (m[s] = c =
															Ge.call(
																e,
																l,
																s,
																"get",
																o[s],
																f,
																C,
																0,
																y.stringFilter
															));
										e._op && e._op[a] && e.kill(l, e._op[a]),
											F &&
												e._pt &&
												((Le = e),
												r.killTweensOf(l, m, e.globalTime(0)),
												(S = !e.parent),
												(Le = 0)),
											e._pt && M && (dt[p.id] = 1);
									}
									h && un(e), e._onInit && e._onInit(e);
								}
								(e._from = !Z && !!y.runBackwards),
									(e._onUpdate = I),
									(e._initted = (!e._op || e._pt) && !S);
							},
							Pe = function (t, e, n, i, r) {
								return D(t)
									? t.call(e, n, i, r)
									: j(t) && ~t.indexOf("random(")
									? de(t)
									: t;
							},
							Je = yt + "repeat,repeatDelay,yoyo,repeatRefresh,yoyoEase",
							Ye = (
								Je + ",id,stagger,delay,duration,paused,scrollTrigger"
							).split(","),
							Xe = (function (n) {
								function o(e, o, a, s) {
									var c;
									"number" == typeof o &&
										((a.duration = o), (o = a), (a = null));
									var l,
										h,
										p,
										u,
										d,
										m,
										f,
										g,
										S = (c = n.call(this, s ? o : Et(o), a) || this).vars,
										y = S.duration,
										V = S.delay,
										q = S.immediateRender,
										R = S.stagger,
										M = S.overwrite,
										I = S.keyframes,
										v = S.defaults,
										k = S.scrollTrigger,
										U = S.yoyoEase,
										w = c.parent,
										x = (J(e) || P(e) ? A(e[0]) : "length" in o) ? [e] : ae(e);
									if (
										((c._targets = x.length
											? Vt(x)
											: ct(
													"GSAP target " +
														e +
														" not found. https://greensock.com",
													!K.nullTargetWarn
											  ) || []),
										(c._ptLookup = []),
										(c._overwrite = M),
										I || R || _(y) || _(V))
									) {
										if (
											((o = c.vars),
											(l = c.timeline =
												new Ae({ data: "nested", defaults: v || {} })).kill(),
											(l.parent = l._dp = t(c)),
											(l._start = 0),
											I)
										)
											bt(l.vars.defaults, { ease: "none" }),
												I.forEach(function (t) {
													return l.to(x, t, ">");
												});
										else {
											if (((u = x.length), (f = R ? ce(R) : ht), B(R)))
												for (d in R)
													~Je.indexOf(d) && (g || (g = {}), (g[d] = R[d]));
											for (h = 0; h < u; h++) {
												for (d in ((p = {}), o))
													Ye.indexOf(d) < 0 && (p[d] = o[d]);
												(p.stagger = 0),
													U && (p.yoyoEase = U),
													g && Tt(p, g),
													(m = x[h]),
													(p.duration = +Pe(y, t(c), h, m, x)),
													(p.delay = (+Pe(V, t(c), h, m, x) || 0) - c._delay),
													!R &&
														1 === u &&
														p.delay &&
														((c._delay = V = p.delay),
														(c._start += V),
														(p.delay = 0)),
													l.to(m, p, f(h, m, x));
											}
											l.duration() ? (y = V = 0) : (c.timeline = 0);
										}
										y || c.duration((y = l.duration()));
									} else c.timeline = 0;
									return (
										!0 !== M || i || ((Le = t(c)), r.killTweensOf(x), (Le = 0)),
										w && Gt(w, t(c)),
										(q ||
											(!y &&
												!I &&
												c._start === It(w._time) &&
												G(q) &&
												Nt(t(c)) &&
												"nested" !== w.data)) &&
											((c._tTime = -1e-8), c.render(Math.max(0, -V))),
										k && _t(t(c), k),
										c
									);
								}
								e(o, n);
								var a = o.prototype;
								return (
									(a.render = function (t, e, n) {
										var i,
											r,
											o,
											a,
											s,
											c,
											l,
											h,
											p,
											u = this._time,
											d = this._tDur,
											m = this._dur,
											f = t > d - W && t >= 0 ? d : t < W ? 0 : t;
										if (m) {
											if (
												f !== this._tTime ||
												!t ||
												n ||
												(!this._initted && this._tTime) ||
												(this._startAt && this._zTime < 0 != t < 0)
											) {
												if (((i = f), (h = this.timeline), this._repeat)) {
													if (
														((a = m + this._rDelay), this._repeat < -1 && t < 0)
													)
														return this.totalTime(100 * a + t, e, n);
													if (
														((i = It(f % a)),
														f === d
															? ((o = this._repeat), (i = m))
															: ((o = ~~(f / a)) &&
																	o === f / a &&
																	((i = m), o--),
															  i > m && (i = m)),
														(c = this._yoyo && 1 & o) &&
															((p = this._yEase), (i = m - i)),
														(s = Dt(this._tTime, a)),
														i === u && !n && this._initted)
													)
														return this;
													o !== s &&
														(h && this._yEase && Ee(h, c),
														!this.vars.repeatRefresh ||
															c ||
															this._lock ||
															((this._lock = n = 1),
															(this.render(
																It(a * o),
																!0
															).invalidate()._lock = 0)));
												}
												if (!this._initted) {
													if (Pt(this, t < 0 ? t : i, n, e))
														return (this._tTime = 0), this;
													if (m !== this._dur) return this.render(t, e, n);
												}
												for (
													this._tTime = f,
														this._time = i,
														!this._act &&
															this._ts &&
															((this._act = 1), (this._lazy = 0)),
														this.ratio = l = (p || this._ease)(i / m),
														this._from && (this.ratio = l = 1 - l),
														i && !u && !e && ge(this, "onStart"),
														r = this._pt;
													r;

												)
													r.r(l, r.d), (r = r._next);
												(h &&
													h.render(
														t < 0 ? t : !i && c ? -1e-8 : h._dur * l,
														e,
														n
													)) ||
													(this._startAt && (this._zTime = t)),
													this._onUpdate &&
														!e &&
														(t < 0 &&
															this._startAt &&
															this._startAt.render(t, !0, n),
														ge(this, "onUpdate")),
													this._repeat &&
														o !== s &&
														this.vars.onRepeat &&
														!e &&
														this.parent &&
														ge(this, "onRepeat"),
													(f !== this._tDur && f) ||
														this._tTime !== f ||
														(t < 0 &&
															this._startAt &&
															!this._onUpdate &&
															this._startAt.render(t, !0, !0),
														(t || !m) &&
															((f === this._tDur && this._ts > 0) ||
																(!f && this._ts < 0)) &&
															Ft(this, 1),
														e ||
															(t < 0 && !u) ||
															(!f && !u) ||
															(ge(
																this,
																f === d ? "onComplete" : "onReverseComplete",
																!0
															),
															this._prom &&
																!(f < d && this.timeScale() > 0) &&
																this._prom()));
											}
										} else
											!(function (t, e, n, i) {
												var r,
													o,
													a,
													s = t.ratio,
													c =
														e < 0 ||
														(!e &&
															((!t._start && Jt(t)) ||
																((t._ts < 0 || t._dp._ts < 0) &&
																	"isFromStart" !== t.data &&
																	"isStart" !== t.data)))
															? 0
															: 1,
													l = t._rDelay,
													h = 0;
												if (
													(l &&
														t._repeat &&
														((h = ne(0, t._tDur, e)),
														(o = Dt(h, l)),
														(a = Dt(t._tTime, l)),
														t._yoyo && 1 & o && (c = 1 - c),
														o !== a &&
															((s = 1 - c),
															t.vars.repeatRefresh &&
																t._initted &&
																t.invalidate())),
													c !== s || i || t._zTime === W || (!e && t._zTime))
												) {
													if (!t._initted && Pt(t, e, i, n)) return;
													for (
														a = t._zTime,
															t._zTime = e || (n ? W : 0),
															n || (n = e && !a),
															t.ratio = c,
															t._from && (c = 1 - c),
															t._time = 0,
															t._tTime = h,
															r = t._pt;
														r;

													)
														r.r(c, r.d), (r = r._next);
													t._startAt && e < 0 && t._startAt.render(e, !0, !0),
														t._onUpdate && !n && ge(t, "onUpdate"),
														h &&
															t._repeat &&
															!n &&
															t.parent &&
															ge(t, "onRepeat"),
														(e >= t._tDur || e < 0) &&
															t.ratio === c &&
															(c && Ft(t, 1),
															n ||
																(ge(
																	t,
																	c ? "onComplete" : "onReverseComplete",
																	!0
																),
																t._prom && t._prom()));
												} else t._zTime || (t._zTime = e);
											})(this, t, e, n);
										return this;
									}),
									(a.targets = function () {
										return this._targets;
									}),
									(a.invalidate = function () {
										return (
											(this._pt =
												this._op =
												this._startAt =
												this._onUpdate =
												this._lazy =
												this.ratio =
													0),
											(this._ptLookup = []),
											this.timeline && this.timeline.invalidate(),
											n.prototype.invalidate.call(this)
										);
									}),
									(a.kill = function (t, e) {
										if (
											(void 0 === e && (e = "all"), !(t || (e && "all" !== e)))
										)
											return (
												(this._lazy = this._pt = 0),
												this.parent ? Se(this) : this
											);
										if (this.timeline) {
											var n = this.timeline.totalDuration();
											return (
												this.timeline.killTweensOf(
													t,
													e,
													Le && !0 !== Le.vars.overwrite
												)._first || Se(this),
												this.parent &&
													n !== this.timeline.totalDuration() &&
													Yt(this, (this._dur * this.timeline._tDur) / n, 0, 1),
												this
											);
										}
										var i,
											r,
											o,
											a,
											s,
											c,
											l,
											h = this._targets,
											p = t ? ae(t) : h,
											u = this._ptLookup,
											d = this._pt;
										if (
											(!e || "all" === e) &&
											(function (t, e) {
												for (
													var n = t.length, i = n === e.length;
													i && n-- && t[n] === e[n];

												);
												return n < 0;
											})(h, p)
										)
											return "all" === e && (this._pt = 0), Se(this);
										for (
											i = this._op = this._op || [],
												"all" !== e &&
													(j(e) &&
														((s = {}),
														Mt(e, function (t) {
															return (s[t] = 1);
														}),
														(e = s)),
													(e = (function (t, e) {
														var n,
															i,
															r,
															o,
															a = t[0] ? qt(t[0]).harness : 0,
															s = a && a.aliases;
														if (!s) return e;
														for (i in ((n = Tt({}, e)), s))
															if ((i in n))
																for (r = (o = s[i].split(",")).length; r--; )
																	n[o[r]] = n[i];
														return n;
													})(h, e))),
												l = h.length;
											l--;

										)
											if (~p.indexOf(h[l]))
												for (s in ((r = u[l]),
												"all" === e
													? ((i[l] = e), (a = r), (o = {}))
													: ((o = i[l] = i[l] || {}), (a = e)),
												a))
													(c = r && r[s]) &&
														(("kill" in c.d && !0 !== c.d.kill(s)) ||
															Ct(this, c, "_pt"),
														delete r[s]),
														"all" !== o && (o[s] = 1);
										return this._initted && !this._pt && d && Se(this), this;
									}),
									(o.to = function (t, e) {
										return new o(t, e, arguments[2]);
									}),
									(o.from = function (t, e) {
										return new o(t, kt(arguments, 1));
									}),
									(o.delayedCall = function (t, e, n, i) {
										return new o(e, 0, {
											immediateRender: !1,
											lazy: !1,
											overwrite: !1,
											delay: t,
											onComplete: e,
											onReverseComplete: e,
											onCompleteParams: n,
											onReverseCompleteParams: n,
											callbackScope: i,
										});
									}),
									(o.fromTo = function (t, e, n) {
										return new o(t, kt(arguments, 2));
									}),
									(o.set = function (t, e) {
										return (
											(e.duration = 0),
											e.repeatDelay || (e.repeat = 0),
											new o(t, e)
										);
									}),
									(o.killTweensOf = function (t, e, n) {
										return r.killTweensOf(t, e, n);
									}),
									o
								);
							})(De);
						bt(Xe.prototype, {
							_targets: [],
							_lazy: 0,
							_startAt: 0,
							_op: 0,
							_onInit: 0,
						}),
							Mt("staggerTo,staggerFrom,staggerFromTo", function (t) {
								Xe[t] = function () {
									var e = new Ae(),
										n = re.call(arguments, 0);
									return (
										n.splice("staggerFromTo" === t ? 5 : 4, 0, 0),
										e[t].apply(e, n)
									);
								};
							});
						var $e = function (t, e, n) {
								return (t[e] = n);
							},
							tn = function (t, e, n) {
								return t[e](n);
							},
							en = function (t, e, n, i) {
								return t[e](i.fp, n);
							},
							nn = function (t, e, n) {
								return t.setAttribute(e, n);
							},
							rn = function (t, e) {
								return D(t[e]) ? tn : L(t[e]) && t.setAttribute ? nn : $e;
							},
							on = function (t, e) {
								return e.set(
									e.t,
									e.p,
									Math.round(1e4 * (e.s + e.c * t)) / 1e4,
									e
								);
							},
							an = function (t, e) {
								return e.set(e.t, e.p, !!(e.s + e.c * t), e);
							},
							sn = function (t, e) {
								var n = e._pt,
									i = "";
								if (!t && e.b) i = e.b;
								else if (1 === t && e.e) i = e.e;
								else {
									for (; n; )
										(i =
											n.p +
											(n.m
												? n.m(n.s + n.c * t)
												: Math.round(1e4 * (n.s + n.c * t)) / 1e4) +
											i),
											(n = n._next);
									i += e.c;
								}
								e.set(e.t, e.p, i, e);
							},
							cn = function (t, e) {
								for (var n = e._pt; n; ) n.r(t, n.d), (n = n._next);
							},
							ln = function (t, e, n, i) {
								for (var r, o = this._pt; o; )
									(r = o._next), o.p === i && o.modifier(t, e, n), (o = r);
							},
							hn = function (t) {
								for (var e, n, i = this._pt; i; )
									(n = i._next),
										(i.p === t && !i.op) || i.op === t
											? Ct(this, i, "_pt")
											: i.dep || (e = 1),
										(i = n);
								return !e;
							},
							pn = function (t, e, n, i) {
								i.mSet(t, e, i.m.call(i.tween, n, i.mt), i);
							},
							un = function (t) {
								for (var e, n, i, r, o = t._pt; o; ) {
									for (e = o._next, n = i; n && n.pr > o.pr; ) n = n._next;
									(o._prev = n ? n._prev : r) ? (o._prev._next = o) : (i = o),
										(o._next = n) ? (n._prev = o) : (r = o),
										(o = e);
								}
								t._pt = i;
							},
							dn = (function () {
								function t(t, e, n, i, r, o, a, s, c) {
									(this.t = e),
										(this.s = i),
										(this.c = r),
										(this.p = n),
										(this.r = o || on),
										(this.d = a || this),
										(this.set = s || $e),
										(this.pr = c || 0),
										(this._next = t),
										t && (t._prev = this);
								}
								return (
									(t.prototype.modifier = function (t, e, n) {
										(this.mSet = this.mSet || this.set),
											(this.set = pn),
											(this.m = t),
											(this.mt = n),
											(this.tween = e);
									}),
									t
								);
							})();
						Mt(
							yt +
								"parent,duration,ease,delay,overwrite,runBackwards,startAt,yoyo,immediateRender,repeat,repeatDelay,data,paused,reversed,lazy,callbackScope,stringFilter,id,yoyoEase,stagger,inherit,repeatRefresh,keyframes,autoRevert,scrollTrigger",
							function (t) {
								return (pt[t] = 1);
							}
						),
							(rt.TweenMax = rt.TweenLite = Xe),
							(rt.TimelineLite = rt.TimelineMax = Ae),
							(r = new Ae({
								sortChildren: !1,
								defaults: T,
								autoRemoveChildren: !0,
								id: "root",
								smoothChildTiming: !0,
							})),
							(K.stringFilter = we);
						var mn = {
							registerPlugin: function () {
								for (
									var t = arguments.length, e = new Array(t), n = 0;
									n < t;
									n++
								)
									e[n] = arguments[n];
								e.forEach(function (t) {
									return ye(t);
								});
							},
							timeline: function (t) {
								return new Ae(t);
							},
							getTweensOf: function (t, e) {
								return r.getTweensOf(t, e);
							},
							getProperty: function (t, e, n, i) {
								j(t) && (t = ae(t)[0]);
								var r = qt(t || {}).get,
									o = n ? Ot : xt;
								return (
									"native" === n && (n = ""),
									t
										? e
											? o(((mt[e] && mt[e].get) || r)(t, e, n, i))
											: function (e, n, i) {
													return o(((mt[e] && mt[e].get) || r)(t, e, n, i));
											  }
										: t
								);
							},
							quickSetter: function (t, e, n) {
								if ((t = ae(t)).length > 1) {
									var i = t.map(function (t) {
											return Sn.quickSetter(t, e, n);
										}),
										r = i.length;
									return function (t) {
										for (var e = r; e--; ) i[e](t);
									};
								}
								t = t[0] || {};
								var o = mt[e],
									a = qt(t),
									s = (a.harness && (a.harness.aliases || {})[e]) || e,
									c = o
										? function (e) {
												var i = new o();
												(h._pt = 0),
													i.init(t, n ? e + n : e, h, 0, [t]),
													i.render(1, i),
													h._pt && cn(1, h);
										  }
										: a.set(t, s);
								return o
									? c
									: function (e) {
											return c(t, s, n ? e + n : e, a, 1);
									  };
							},
							isTweening: function (t) {
								return r.getTweensOf(t, !0).length > 0;
							},
							defaults: function (t) {
								return (
									t && t.ease && (t.ease = Ce(t.ease, T.ease)), zt(T, t || {})
								);
							},
							config: function (t) {
								return zt(K, t || {});
							},
							registerEffect: function (t) {
								var e = t.name,
									n = t.effect,
									i = t.plugins,
									r = t.defaults,
									o = t.extendTimeline;
								(i || "").split(",").forEach(function (t) {
									return (
										t &&
										!mt[t] &&
										!rt[t] &&
										ct(e + " effect requires " + t + " plugin.")
									);
								}),
									(ft[e] = function (t, e, i) {
										return n(ae(t), bt(e || {}, r), i);
									}),
									o &&
										(Ae.prototype[e] = function (t, n, i) {
											return this.add(
												ft[e](t, B(n) ? n : (i = n) && {}, this),
												i
											);
										});
							},
							registerEase: function (t, e) {
								be[t] = Ce(e);
							},
							parseEase: function (t, e) {
								return arguments.length ? Ce(t, e) : be;
							},
							getById: function (t) {
								return r.getById(t);
							},
							exportRoot: function (t, e) {
								void 0 === t && (t = {});
								var n,
									i,
									o = new Ae(t);
								for (
									o.smoothChildTiming = G(t.smoothChildTiming),
										r.remove(o),
										o._dp = 0,
										o._time = o._tTime = r._time,
										n = r._first;
									n;

								)
									(i = n._next),
										(!e &&
											!n._dur &&
											n instanceof Xe &&
											n.vars.onComplete === n._targets[0]) ||
											Qt(o, n, n._start - n._delay),
										(n = i);
								return Qt(r, o, 0), o;
							},
							utils: {
								wrap: function t(e, n, i) {
									var r = n - e;
									return J(e)
										? ue(e, t(0, e.length), n)
										: ee(i, function (t) {
												return ((r + ((t - e) % r)) % r) + e;
										  });
								},
								wrapYoyo: function t(e, n, i) {
									var r = n - e,
										o = 2 * r;
									return J(e)
										? ue(e, t(0, e.length - 1), n)
										: ee(i, function (t) {
												return (
													e +
													((t = (o + ((t - e) % o)) % o || 0) > r ? o - t : t)
												);
										  });
								},
								distribute: ce,
								random: pe,
								snap: he,
								normalize: function (t, e, n) {
									return me(t, e, 0, 1, n);
								},
								getUnit: ie,
								clamp: function (t, e, n) {
									return ee(n, function (n) {
										return ne(t, e, n);
									});
								},
								splitColor: Me,
								toArray: ae,
								mapRange: me,
								pipe: function () {
									for (
										var t = arguments.length, e = new Array(t), n = 0;
										n < t;
										n++
									)
										e[n] = arguments[n];
									return function (t) {
										return e.reduce(function (t, e) {
											return e(t);
										}, t);
									};
								},
								unitize: function (t, e) {
									return function (n) {
										return t(parseFloat(n)) + (e || ie(n));
									};
								},
								interpolate: function t(e, n, i, r) {
									var o = isNaN(e + n)
										? 0
										: function (t) {
												return (1 - t) * e + t * n;
										  };
									if (!o) {
										var a,
											s,
											c,
											l,
											h,
											p = j(e),
											u = {};
										if ((!0 === i && (r = 1) && (i = null), p))
											(e = { p: e }), (n = { p: n });
										else if (J(e) && !J(n)) {
											for (c = [], l = e.length, h = l - 2, s = 1; s < l; s++)
												c.push(t(e[s - 1], e[s]));
											l--,
												(o = function (t) {
													t *= l;
													var e = Math.min(h, ~~t);
													return c[e](t - e);
												}),
												(i = n);
										} else r || (e = Tt(J(e) ? [] : {}, e));
										if (!c) {
											for (a in n) Ge.call(u, e, a, "get", n[a]);
											o = function (t) {
												return cn(t, u) || (p ? e.p : e);
											};
										}
									}
									return ee(i, o);
								},
								shuffle: se,
							},
							install: at,
							effects: ft,
							ticker: xe,
							updateRoot: Ae.updateRoot,
							plugins: mt,
							globalTimeline: r,
							core: {
								PropTween: dn,
								globals: lt,
								Tween: Xe,
								Timeline: Ae,
								Animation: De,
								getCache: qt,
								_removeLinkedListItem: Ct,
								suppressOverwrites: function (t) {
									return (i = t);
								},
							},
						};
						Mt("to,from,fromTo,delayedCall,set,killTweensOf", function (t) {
							return (mn[t] = Xe[t]);
						}),
							xe.add(Ae.updateRoot),
							(h = mn.to({}, { duration: 0 }));
						var fn = function (t, e) {
								for (
									var n = t._pt;
									n && n.p !== e && n.op !== e && n.fp !== e;

								)
									n = n._next;
								return n;
							},
							gn = function (t, e) {
								return {
									name: t,
									rawVars: 1,
									init: function (t, n, i) {
										i._onInit = function (t) {
											var i, r;
											if (
												(j(n) &&
													((i = {}),
													Mt(n, function (t) {
														return (i[t] = 1);
													}),
													(n = i)),
												e)
											) {
												for (r in ((i = {}), n)) i[r] = e(n[r]);
												n = i;
											}
											!(function (t, e) {
												var n,
													i,
													r,
													o = t._targets;
												for (n in e)
													for (i = o.length; i--; )
														(r = t._ptLookup[i][n]) &&
															(r = r.d) &&
															(r._pt && (r = fn(r, n)),
															r && r.modifier && r.modifier(e[n], t, o[i], n));
											})(t, n);
										};
									},
								};
							},
							Sn =
								mn.registerPlugin(
									{
										name: "attr",
										init: function (t, e, n, i, r) {
											var o, a;
											for (o in e)
												(a = this.add(
													t,
													"setAttribute",
													(t.getAttribute(o) || 0) + "",
													e[o],
													i,
													r,
													0,
													0,
													o
												)) && (a.op = o),
													this._props.push(o);
										},
									},
									{
										name: "endArray",
										init: function (t, e) {
											for (var n = e.length; n--; )
												this.add(t, n, t[n] || 0, e[n]);
										},
									},
									gn("roundProps", le),
									gn("modifiers"),
									gn("snap", he)
								) || mn;
						(Xe.version = Ae.version = Sn.version = "3.6.1"),
							(c = 1),
							Q() && Oe(),
							be.Power0,
							be.Power1,
							be.Power2,
							be.Power3,
							be.Power4,
							be.Linear,
							be.Quad;
						var yn,
							Vn,
							qn,
							Rn,
							Mn,
							In,
							vn,
							kn = be.Cubic,
							Un = be.Quart,
							wn =
								(be.Quint,
								be.Strong,
								be.Elastic,
								be.Back,
								be.SteppedEase,
								be.Bounce,
								be.Sine,
								be.Expo),
							xn = (be.Circ, {}),
							On = 180 / Math.PI,
							bn = Math.PI / 180,
							Kn = Math.atan2,
							Tn = /([A-Z])/g,
							zn = /(?:left|right|width|margin|padding|x)/i,
							Wn = /[\s,\(]\S/,
							En = {
								autoAlpha: "opacity,visibility",
								scale: "scaleX,scaleY",
								alpha: "opacity",
							},
							Cn = function (t, e) {
								return e.set(
									e.t,
									e.p,
									Math.round(1e4 * (e.s + e.c * t)) / 1e4 + e.u,
									e
								);
							},
							Fn = function (t, e) {
								return e.set(
									e.t,
									e.p,
									1 === t ? e.e : Math.round(1e4 * (e.s + e.c * t)) / 1e4 + e.u,
									e
								);
							},
							Zn = function (t, e) {
								return e.set(
									e.t,
									e.p,
									t ? Math.round(1e4 * (e.s + e.c * t)) / 1e4 + e.u : e.b,
									e
								);
							},
							Hn = function (t, e) {
								var n = e.s + e.c * t;
								e.set(e.t, e.p, ~~(n + (n < 0 ? -0.5 : 0.5)) + e.u, e);
							},
							Nn = function (t, e) {
								return e.set(e.t, e.p, t ? e.e : e.b, e);
							},
							jn = function (t, e) {
								return e.set(e.t, e.p, 1 !== t ? e.b : e.e, e);
							},
							Dn = function (t, e, n) {
								return (t.style[e] = n);
							},
							An = function (t, e, n) {
								return t.style.setProperty(e, n);
							},
							Ln = function (t, e, n) {
								return (t._gsap[e] = n);
							},
							Bn = function (t, e, n) {
								return (t._gsap.scaleX = t._gsap.scaleY = n);
							},
							Gn = function (t, e, n, i, r) {
								var o = t._gsap;
								(o.scaleX = o.scaleY = n), o.renderTransform(r, o);
							},
							Qn = function (t, e, n, i, r) {
								var o = t._gsap;
								(o[e] = n), o.renderTransform(r, o);
							},
							_n = "transform",
							Pn = _n + "Origin",
							Jn = function (t, e) {
								var n = Vn.createElementNS
									? Vn.createElementNS(
											(e || "http://www.w3.org/1999/xhtml").replace(
												/^https/,
												"http"
											),
											t
									  )
									: Vn.createElement(t);
								return n.style ? n : Vn.createElement(t);
							},
							Yn = function t(e, n, i) {
								var r = getComputedStyle(e);
								return (
									r[n] ||
									r.getPropertyValue(n.replace(Tn, "-$1").toLowerCase()) ||
									r.getPropertyValue(n) ||
									(!i && t(e, $n(n) || n, 1)) ||
									""
								);
							},
							Xn = "O,Moz,ms,Ms,Webkit".split(","),
							$n = function (t, e, n) {
								var i = (e || Mn).style,
									r = 5;
								if (t in i && !n) return t;
								for (
									t = t.charAt(0).toUpperCase() + t.substr(1);
									r-- && !(Xn[r] + t in i);

								);
								return r < 0
									? null
									: (3 === r ? "ms" : r >= 0 ? Xn[r] : "") + t;
							},
							ti = function () {
								"undefined" != typeof window &&
									window.document &&
									((yn = window),
									(Vn = yn.document),
									(qn = Vn.documentElement),
									(Mn = Jn("div") || { style: {} }),
									Jn("div"),
									(_n = $n(_n)),
									(Pn = _n + "Origin"),
									(Mn.style.cssText =
										"border-width:0;line-height:0;position:absolute;padding:0"),
									(vn = !!$n("perspective")),
									(Rn = 1));
							},
							ei = function t(e) {
								var n,
									i = Jn(
										"svg",
										(this.ownerSVGElement &&
											this.ownerSVGElement.getAttribute("xmlns")) ||
											"http://www.w3.org/2000/svg"
									),
									r = this.parentNode,
									o = this.nextSibling,
									a = this.style.cssText;
								if (
									(qn.appendChild(i),
									i.appendChild(this),
									(this.style.display = "block"),
									e)
								)
									try {
										(n = this.getBBox()),
											(this._gsapBBox = this.getBBox),
											(this.getBBox = t);
									} catch (t) {}
								else this._gsapBBox && (n = this._gsapBBox());
								return (
									r && (o ? r.insertBefore(this, o) : r.appendChild(this)),
									qn.removeChild(i),
									(this.style.cssText = a),
									n
								);
							},
							ni = function (t, e) {
								for (var n = e.length; n--; )
									if (t.hasAttribute(e[n])) return t.getAttribute(e[n]);
							},
							ii = function (t) {
								var e;
								try {
									e = t.getBBox();
								} catch (n) {
									e = ei.call(t, !0);
								}
								return (
									(e && (e.width || e.height)) ||
										t.getBBox === ei ||
										(e = ei.call(t, !0)),
									!e || e.width || e.x || e.y
										? e
										: {
												x: +ni(t, ["x", "cx", "x1"]) || 0,
												y: +ni(t, ["y", "cy", "y1"]) || 0,
												width: 0,
												height: 0,
										  }
								);
							},
							ri = function (t) {
								return !(
									!t.getCTM ||
									(t.parentNode && !t.ownerSVGElement) ||
									!ii(t)
								);
							},
							oi = function (t, e) {
								if (e) {
									var n = t.style;
									e in xn && e !== Pn && (e = _n),
										n.removeProperty
											? (("ms" !== e.substr(0, 2) &&
													"webkit" !== e.substr(0, 6)) ||
													(e = "-" + e),
											  n.removeProperty(e.replace(Tn, "-$1").toLowerCase()))
											: n.removeAttribute(e);
								}
							},
							ai = function (t, e, n, i, r, o) {
								var a = new dn(t._pt, e, n, 0, 1, o ? jn : Nn);
								return (t._pt = a), (a.b = i), (a.e = r), t._props.push(n), a;
							},
							si = { deg: 1, rad: 1, turn: 1 },
							ci = function t(e, n, i, r) {
								var o,
									a,
									s,
									c,
									l = parseFloat(i) || 0,
									h = (i + "").trim().substr((l + "").length) || "px",
									p = Mn.style,
									u = zn.test(n),
									d = "svg" === e.tagName.toLowerCase(),
									m = (d ? "client" : "offset") + (u ? "Width" : "Height"),
									f = 100,
									g = "px" === r,
									S = "%" === r;
								return r === h || !l || si[r] || si[h]
									? l
									: ("px" !== h && !g && (l = t(e, n, i, "px")),
									  (c = e.getCTM && ri(e)),
									  (!S && "%" !== h) || (!xn[n] && !~n.indexOf("adius"))
											? ((p[u ? "width" : "height"] = f + (g ? h : r)),
											  (a =
													~n.indexOf("adius") ||
													("em" === r && e.appendChild && !d)
														? e
														: e.parentNode),
											  c && (a = (e.ownerSVGElement || {}).parentNode),
											  (a && a !== Vn && a.appendChild) || (a = Vn.body),
											  (s = a._gsap) && S && s.width && u && s.time === xe.time
													? It((l / s.width) * f)
													: ((S || "%" === h) &&
															(p.position = Yn(e, "position")),
													  a === e && (p.position = "static"),
													  a.appendChild(Mn),
													  (o = Mn[m]),
													  a.removeChild(Mn),
													  (p.position = "absolute"),
													  u &&
															S &&
															(((s = qt(a)).time = xe.time), (s.width = a[m])),
													  It(g ? (o * l) / f : o && l ? (f / o) * l : 0)))
											: ((o = c ? e.getBBox()[u ? "width" : "height"] : e[m]),
											  It(S ? (l / o) * f : (l / 100) * o)));
							},
							li = function (t, e, n, i) {
								var r;
								return (
									Rn || ti(),
									e in En &&
										"transform" !== e &&
										~(e = En[e]).indexOf(",") &&
										(e = e.split(",")[0]),
									xn[e] && "transform" !== e
										? ((r = qi(t, i)),
										  (r =
												"transformOrigin" !== e
													? r[e]
													: Ri(Yn(t, Pn)) + " " + r.zOrigin + "px"))
										: (!(r = t.style[e]) ||
												"auto" === r ||
												i ||
												~(r + "").indexOf("calc(")) &&
										  (r =
												(di[e] && di[e](t, e, n)) ||
												Yn(t, e) ||
												Rt(t, e) ||
												("opacity" === e ? 1 : 0)),
									n && !~(r + "").trim().indexOf(" ") ? ci(t, e, r, n) + n : r
								);
							},
							hi = function (t, e, n, i) {
								if (!n || "none" === n) {
									var r = $n(e, t, 1),
										o = r && Yn(t, r, 1);
									o && o !== n
										? ((e = r), (n = o))
										: "borderColor" === e && (n = Yn(t, "borderTopColor"));
								}
								var a,
									s,
									c,
									l,
									h,
									p,
									u,
									d,
									m,
									f,
									g,
									S,
									y = new dn(this._pt, t.style, e, 0, 1, sn),
									V = 0,
									q = 0;
								if (
									((y.b = n),
									(y.e = i),
									(n += ""),
									"auto" == (i += "") &&
										((t.style[e] = i), (i = Yn(t, e) || i), (t.style[e] = n)),
									we((a = [n, i])),
									(i = a[1]),
									(c = (n = a[0]).match($) || []),
									(i.match($) || []).length)
								) {
									for (; (s = $.exec(i)); )
										(u = s[0]),
											(m = i.substring(V, s.index)),
											h
												? (h = (h + 1) % 5)
												: ("rgba(" !== m.substr(-5) &&
														"hsla(" !== m.substr(-5)) ||
												  (h = 1),
											u !== (p = c[q++] || "") &&
												((l = parseFloat(p) || 0),
												(g = p.substr((l + "").length)),
												(S = "=" === u.charAt(1) ? +(u.charAt(0) + "1") : 0) &&
													(u = u.substr(2)),
												(d = parseFloat(u)),
												(f = u.substr((d + "").length)),
												(V = $.lastIndex - f.length),
												f ||
													((f = f || K.units[e] || g),
													V === i.length && ((i += f), (y.e += f))),
												g !== f && (l = ci(t, e, p, f) || 0),
												(y._pt = {
													_next: y._pt,
													p: m || 1 === q ? m : ",",
													s: l,
													c: S ? S * d : d - l,
													m: (h && h < 4) || "zIndex" === e ? Math.round : 0,
												}));
									y.c = V < i.length ? i.substring(V, i.length) : "";
								} else y.r = "display" === e && "none" === i ? jn : Nn;
								return et.test(i) && (y.e = 0), (this._pt = y), y;
							},
							pi = {
								top: "0%",
								bottom: "100%",
								left: "0%",
								right: "100%",
								center: "50%",
							},
							ui = function (t, e) {
								if (e.tween && e.tween._time === e.tween._dur) {
									var n,
										i,
										r,
										o = e.t,
										a = o.style,
										s = e.u,
										c = o._gsap;
									if ("all" === s || !0 === s) (a.cssText = ""), (i = 1);
									else
										for (r = (s = s.split(",")).length; --r > -1; )
											(n = s[r]),
												xn[n] &&
													((i = 1), (n = "transformOrigin" === n ? Pn : _n)),
												oi(o, n);
									i &&
										(oi(o, _n),
										c &&
											(c.svg && o.removeAttribute("transform"),
											qi(o, 1),
											(c.uncache = 1)));
								}
							},
							di = {
								clearProps: function (t, e, n, i, r) {
									if ("isFromStart" !== r.data) {
										var o = (t._pt = new dn(t._pt, e, n, 0, 0, ui));
										return (
											(o.u = i),
											(o.pr = -10),
											(o.tween = r),
											t._props.push(n),
											1
										);
									}
								},
							},
							mi = [1, 0, 0, 1, 0, 0],
							fi = {},
							gi = function (t) {
								return "matrix(1, 0, 0, 1, 0, 0)" === t || "none" === t || !t;
							},
							Si = function (t) {
								var e = Yn(t, _n);
								return gi(e) ? mi : e.substr(7).match(X).map(It);
							},
							yi = function (t, e) {
								var n,
									i,
									r,
									o,
									a = t._gsap || qt(t),
									s = t.style,
									c = Si(t);
								return a.svg && t.getAttribute("transform")
									? "1,0,0,1,0,0" ===
									  (c = [
											(r = t.transform.baseVal.consolidate().matrix).a,
											r.b,
											r.c,
											r.d,
											r.e,
											r.f,
									  ]).join(",")
										? mi
										: c
									: (c !== mi ||
											t.offsetParent ||
											t === qn ||
											a.svg ||
											((r = s.display),
											(s.display = "block"),
											((n = t.parentNode) && t.offsetParent) ||
												((o = 1), (i = t.nextSibling), qn.appendChild(t)),
											(c = Si(t)),
											r ? (s.display = r) : oi(t, "display"),
											o &&
												(i
													? n.insertBefore(t, i)
													: n
													? n.appendChild(t)
													: qn.removeChild(t))),
									  e && c.length > 6
											? [c[0], c[1], c[4], c[5], c[12], c[13]]
											: c);
							},
							Vi = function (t, e, n, i, r, o) {
								var a,
									s,
									c,
									l = t._gsap,
									h = r || yi(t, !0),
									p = l.xOrigin || 0,
									u = l.yOrigin || 0,
									d = l.xOffset || 0,
									m = l.yOffset || 0,
									f = h[0],
									g = h[1],
									S = h[2],
									y = h[3],
									V = h[4],
									q = h[5],
									R = e.split(" "),
									M = parseFloat(R[0]) || 0,
									I = parseFloat(R[1]) || 0;
								n
									? h !== mi &&
									  (s = f * y - g * S) &&
									  ((c = M * (-g / s) + I * (f / s) - (f * q - g * V) / s),
									  (M = M * (y / s) + I * (-S / s) + (S * q - y * V) / s),
									  (I = c))
									: ((M =
											(a = ii(t)).x +
											(~R[0].indexOf("%") ? (M / 100) * a.width : M)),
									  (I =
											a.y +
											(~(R[1] || R[0]).indexOf("%")
												? (I / 100) * a.height
												: I))),
									i || (!1 !== i && l.smooth)
										? ((V = M - p),
										  (q = I - u),
										  (l.xOffset = d + (V * f + q * S) - V),
										  (l.yOffset = m + (V * g + q * y) - q))
										: (l.xOffset = l.yOffset = 0),
									(l.xOrigin = M),
									(l.yOrigin = I),
									(l.smooth = !!i),
									(l.origin = e),
									(l.originIsAbsolute = !!n),
									(t.style[Pn] = "0px 0px"),
									o &&
										(ai(o, l, "xOrigin", p, M),
										ai(o, l, "yOrigin", u, I),
										ai(o, l, "xOffset", d, l.xOffset),
										ai(o, l, "yOffset", m, l.yOffset)),
									t.setAttribute("data-svg-origin", M + " " + I);
							},
							qi = function (t, e) {
								var n = t._gsap || new je(t);
								if ("x" in n && !e && !n.uncache) return n;
								var i,
									r,
									o,
									a,
									s,
									c,
									l,
									h,
									p,
									u,
									d,
									m,
									f,
									g,
									S,
									y,
									V,
									q,
									R,
									M,
									I,
									v,
									k,
									U,
									w,
									x,
									O,
									b,
									T,
									z,
									W,
									E,
									C = t.style,
									F = n.scaleX < 0,
									Z = "px",
									H = "deg",
									N = Yn(t, Pn) || "0";
								return (
									(i = r = o = c = l = h = p = u = d = 0),
									(a = s = 1),
									(n.svg = !(!t.getCTM || !ri(t))),
									(g = yi(t, n.svg)),
									n.svg &&
										((U =
											!n.uncache && !e && t.getAttribute("data-svg-origin")),
										Vi(
											t,
											U || N,
											!!U || n.originIsAbsolute,
											!1 !== n.smooth,
											g
										)),
									(m = n.xOrigin || 0),
									(f = n.yOrigin || 0),
									g !== mi &&
										((q = g[0]),
										(R = g[1]),
										(M = g[2]),
										(I = g[3]),
										(i = v = g[4]),
										(r = k = g[5]),
										6 === g.length
											? ((a = Math.sqrt(q * q + R * R)),
											  (s = Math.sqrt(I * I + M * M)),
											  (c = q || R ? Kn(R, q) * On : 0),
											  (p = M || I ? Kn(M, I) * On + c : 0) &&
													(s *= Math.abs(Math.cos(p * bn))),
											  n.svg &&
													((i -= m - (m * q + f * M)),
													(r -= f - (m * R + f * I))))
											: ((E = g[6]),
											  (z = g[7]),
											  (O = g[8]),
											  (b = g[9]),
											  (T = g[10]),
											  (W = g[11]),
											  (i = g[12]),
											  (r = g[13]),
											  (o = g[14]),
											  (l = (S = Kn(E, T)) * On),
											  S &&
													((U =
														v * (y = Math.cos(-S)) + O * (V = Math.sin(-S))),
													(w = k * y + b * V),
													(x = E * y + T * V),
													(O = v * -V + O * y),
													(b = k * -V + b * y),
													(T = E * -V + T * y),
													(W = z * -V + W * y),
													(v = U),
													(k = w),
													(E = x)),
											  (h = (S = Kn(-M, T)) * On),
											  S &&
													((y = Math.cos(-S)),
													(W = I * (V = Math.sin(-S)) + W * y),
													(q = U = q * y - O * V),
													(R = w = R * y - b * V),
													(M = x = M * y - T * V)),
											  (c = (S = Kn(R, q)) * On),
											  S &&
													((U = q * (y = Math.cos(S)) + R * (V = Math.sin(S))),
													(w = v * y + k * V),
													(R = R * y - q * V),
													(k = k * y - v * V),
													(q = U),
													(v = w)),
											  l &&
													Math.abs(l) + Math.abs(c) > 359.9 &&
													((l = c = 0), (h = 180 - h)),
											  (a = It(Math.sqrt(q * q + R * R + M * M))),
											  (s = It(Math.sqrt(k * k + E * E))),
											  (S = Kn(v, k)),
											  (p = Math.abs(S) > 2e-4 ? S * On : 0),
											  (d = W ? 1 / (W < 0 ? -W : W) : 0)),
										n.svg &&
											((U = t.getAttribute("transform")),
											(n.forceCSS =
												t.setAttribute("transform", "") || !gi(Yn(t, _n))),
											U && t.setAttribute("transform", U))),
									Math.abs(p) > 90 &&
										Math.abs(p) < 270 &&
										(F
											? ((a *= -1),
											  (p += c <= 0 ? 180 : -180),
											  (c += c <= 0 ? 180 : -180))
											: ((s *= -1), (p += p <= 0 ? 180 : -180))),
									(n.x =
										i -
										((n.xPercent =
											i &&
											(n.xPercent ||
												(Math.round(t.offsetWidth / 2) === Math.round(-i)
													? -50
													: 0)))
											? (t.offsetWidth * n.xPercent) / 100
											: 0) +
										Z),
									(n.y =
										r -
										((n.yPercent =
											r &&
											(n.yPercent ||
												(Math.round(t.offsetHeight / 2) === Math.round(-r)
													? -50
													: 0)))
											? (t.offsetHeight * n.yPercent) / 100
											: 0) +
										Z),
									(n.z = o + Z),
									(n.scaleX = It(a)),
									(n.scaleY = It(s)),
									(n.rotation = It(c) + H),
									(n.rotationX = It(l) + H),
									(n.rotationY = It(h) + H),
									(n.skewX = p + H),
									(n.skewY = u + H),
									(n.transformPerspective = d + Z),
									(n.zOrigin = parseFloat(N.split(" ")[2]) || 0) &&
										(C[Pn] = Ri(N)),
									(n.xOffset = n.yOffset = 0),
									(n.force3D = K.force3D),
									(n.renderTransform = n.svg ? xi : vn ? wi : Ii),
									(n.uncache = 0),
									n
								);
							},
							Ri = function (t) {
								return (t = t.split(" "))[0] + " " + t[1];
							},
							Mi = function (t, e, n) {
								var i = ie(e);
								return (
									It(parseFloat(e) + parseFloat(ci(t, "x", n + "px", i))) + i
								);
							},
							Ii = function (t, e) {
								(e.z = "0px"),
									(e.rotationY = e.rotationX = "0deg"),
									(e.force3D = 0),
									wi(t, e);
							},
							vi = "0deg",
							ki = "0px",
							Ui = ") ",
							wi = function (t, e) {
								var n = e || this,
									i = n.xPercent,
									r = n.yPercent,
									o = n.x,
									a = n.y,
									s = n.z,
									c = n.rotation,
									l = n.rotationY,
									h = n.rotationX,
									p = n.skewX,
									u = n.skewY,
									d = n.scaleX,
									m = n.scaleY,
									f = n.transformPerspective,
									g = n.force3D,
									S = n.target,
									y = n.zOrigin,
									V = "",
									q = ("auto" === g && t && 1 !== t) || !0 === g;
								if (y && (h !== vi || l !== vi)) {
									var R,
										M = parseFloat(l) * bn,
										I = Math.sin(M),
										v = Math.cos(M);
									(M = parseFloat(h) * bn),
										(R = Math.cos(M)),
										(o = Mi(S, o, I * R * -y)),
										(a = Mi(S, a, -Math.sin(M) * -y)),
										(s = Mi(S, s, v * R * -y + y));
								}
								f !== ki && (V += "perspective(" + f + Ui),
									(i || r) && (V += "translate(" + i + "%, " + r + "%) "),
									(q || o !== ki || a !== ki || s !== ki) &&
										(V +=
											s !== ki || q
												? "translate3d(" + o + ", " + a + ", " + s + ") "
												: "translate(" + o + ", " + a + Ui),
									c !== vi && (V += "rotate(" + c + Ui),
									l !== vi && (V += "rotateY(" + l + Ui),
									h !== vi && (V += "rotateX(" + h + Ui),
									(p === vi && u === vi) || (V += "skew(" + p + ", " + u + Ui),
									(1 === d && 1 === m) || (V += "scale(" + d + ", " + m + Ui),
									(S.style[_n] = V || "translate(0, 0)");
							},
							xi = function (t, e) {
								var n,
									i,
									r,
									o,
									a,
									s = e || this,
									c = s.xPercent,
									l = s.yPercent,
									h = s.x,
									p = s.y,
									u = s.rotation,
									d = s.skewX,
									m = s.skewY,
									f = s.scaleX,
									g = s.scaleY,
									S = s.target,
									y = s.xOrigin,
									V = s.yOrigin,
									q = s.xOffset,
									R = s.yOffset,
									M = s.forceCSS,
									I = parseFloat(h),
									v = parseFloat(p);
								(u = parseFloat(u)),
									(d = parseFloat(d)),
									(m = parseFloat(m)) && ((d += m = parseFloat(m)), (u += m)),
									u || d
										? ((u *= bn),
										  (d *= bn),
										  (n = Math.cos(u) * f),
										  (i = Math.sin(u) * f),
										  (r = Math.sin(u - d) * -g),
										  (o = Math.cos(u - d) * g),
										  d &&
												((m *= bn),
												(a = Math.tan(d - m)),
												(r *= a = Math.sqrt(1 + a * a)),
												(o *= a),
												m &&
													((a = Math.tan(m)),
													(n *= a = Math.sqrt(1 + a * a)),
													(i *= a))),
										  (n = It(n)),
										  (i = It(i)),
										  (r = It(r)),
										  (o = It(o)))
										: ((n = f), (o = g), (i = r = 0)),
									((I && !~(h + "").indexOf("px")) ||
										(v && !~(p + "").indexOf("px"))) &&
										((I = ci(S, "x", h, "px")), (v = ci(S, "y", p, "px"))),
									(y || V || q || R) &&
										((I = It(I + y - (y * n + V * r) + q)),
										(v = It(v + V - (y * i + V * o) + R))),
									(c || l) &&
										((a = S.getBBox()),
										(I = It(I + (c / 100) * a.width)),
										(v = It(v + (l / 100) * a.height))),
									(a =
										"matrix(" +
										n +
										"," +
										i +
										"," +
										r +
										"," +
										o +
										"," +
										I +
										"," +
										v +
										")"),
									S.setAttribute("transform", a),
									M && (S.style[_n] = a);
							},
							Oi = function (t, e, n, i, r, o) {
								var a,
									s,
									c = 360,
									l = j(r),
									h = parseFloat(r) * (l && ~r.indexOf("rad") ? On : 1),
									p = o ? h * o : h - i,
									u = i + p + "deg";
								return (
									l &&
										("short" === (a = r.split("_")[1]) &&
											(p %= c) != p % 180 &&
											(p += p < 0 ? c : -360),
										"cw" === a && p < 0
											? (p = ((p + 36e9) % c) - ~~(p / c) * c)
											: "ccw" === a &&
											  p > 0 &&
											  (p = ((p - 36e9) % c) - ~~(p / c) * c)),
									(t._pt = s = new dn(t._pt, e, n, i, p, Fn)),
									(s.e = u),
									(s.u = "deg"),
									t._props.push(n),
									s
								);
							},
							bi = function (t, e) {
								for (var n in e) t[n] = e[n];
								return t;
							},
							Ki = function (t, e, n) {
								var i,
									r,
									o,
									a,
									s,
									c,
									l,
									h = bi({}, n._gsap),
									p = n.style;
								for (r in (h.svg
									? ((o = n.getAttribute("transform")),
									  n.setAttribute("transform", ""),
									  (p[_n] = e),
									  (i = qi(n, 1)),
									  oi(n, _n),
									  n.setAttribute("transform", o))
									: ((o = getComputedStyle(n)[_n]),
									  (p[_n] = e),
									  (i = qi(n, 1)),
									  (p[_n] = o)),
								xn))
									(o = h[r]) !== (a = i[r]) &&
										"perspective,force3D,transformOrigin,svgOrigin".indexOf(r) <
											0 &&
										((s =
											ie(o) !== (l = ie(a)) ? ci(n, r, o, l) : parseFloat(o)),
										(c = parseFloat(a)),
										(t._pt = new dn(t._pt, i, r, s, c - s, Cn)),
										(t._pt.u = l || 0),
										t._props.push(r));
								bi(i, h);
							};
						Mt("padding,margin,Width,Radius", function (t, e) {
							var n = "Top",
								i = "Right",
								r = "Bottom",
								o = "Left",
								a = (e < 3 ? [n, i, r, o] : [n + o, n + i, r + i, r + o]).map(
									function (n) {
										return e < 2 ? t + n : "border" + n + t;
									}
								);
							di[e > 1 ? "border" + t : t] = function (t, e, n, i, r) {
								var o, s;
								if (arguments.length < 4)
									return (
										(o = a.map(function (e) {
											return li(t, e, n);
										})),
										5 === (s = o.join(" ")).split(o[0]).length ? o[0] : s
									);
								(o = (i + "").split(" ")),
									(s = {}),
									a.forEach(function (t, e) {
										return (s[t] = o[e] = o[e] || o[((e - 1) / 2) | 0]);
									}),
									t.init(e, s, r);
							};
						});
						var Ti,
							zi,
							Wi = {
								name: "css",
								register: ti,
								targetTest: function (t) {
									return t.style && t.nodeType;
								},
								init: function (t, e, n, i, r) {
									var o,
										a,
										s,
										c,
										l,
										h,
										p,
										u,
										d,
										m,
										f,
										g,
										S,
										y,
										V,
										q,
										R,
										M,
										I,
										v = this._props,
										k = t.style,
										U = n.vars.startAt;
									for (p in (Rn || ti(), e))
										if (
											"autoRound" !== p &&
											((a = e[p]), !mt[p] || !Qe(p, e, n, i, t, r))
										)
											if (
												((l = typeof a),
												(h = di[p]),
												"function" === l &&
													(l = typeof (a = a.call(n, i, t, r))),
												"string" === l && ~a.indexOf("random(") && (a = de(a)),
												h)
											)
												h(this, t, p, a, n) && (V = 1);
											else if ("--" === p.substr(0, 2))
												(o = (
													getComputedStyle(t).getPropertyValue(p) + ""
												).trim()),
													(a += ""),
													(ke.lastIndex = 0),
													ke.test(o) || ((u = ie(o)), (d = ie(a))),
													d
														? u !== d && (o = ci(t, p, o, d) + d)
														: u && (a += u),
													this.add(k, "setProperty", o, a, i, r, 0, 0, p);
											else if ("undefined" !== l) {
												if (
													(U && p in U
														? ((o =
																"function" == typeof U[p]
																	? U[p].call(n, i, t, r)
																	: U[p]),
														  p in K.units && !ie(o) && (o += K.units[p]),
														  "=" === (o + "").charAt(1) && (o = li(t, p)))
														: (o = li(t, p)),
													(c = parseFloat(o)),
													(m =
														"string" === l && "=" === a.charAt(1)
															? +(a.charAt(0) + "1")
															: 0) && (a = a.substr(2)),
													(s = parseFloat(a)),
													p in En &&
														("autoAlpha" === p &&
															(1 === c &&
																"hidden" === li(t, "visibility") &&
																s &&
																(c = 0),
															ai(
																this,
																k,
																"visibility",
																c ? "inherit" : "hidden",
																s ? "inherit" : "hidden",
																!s
															)),
														"scale" !== p &&
															"transform" !== p &&
															~(p = En[p]).indexOf(",") &&
															(p = p.split(",")[0])),
													(f = p in xn))
												)
													if (
														(g ||
															(((S = t._gsap).renderTransform &&
																!e.parseTransform) ||
																qi(t, e.parseTransform),
															(y = !1 !== e.smoothOrigin && S.smooth),
															((g = this._pt =
																new dn(
																	this._pt,
																	k,
																	_n,
																	0,
																	1,
																	S.renderTransform,
																	S,
																	0,
																	-1
																)).dep = 1)),
														"scale" === p)
													)
														(this._pt = new dn(
															this._pt,
															S,
															"scaleY",
															S.scaleY,
															m ? m * s : s - S.scaleY
														)),
															v.push("scaleY", p),
															(p += "X");
													else {
														if ("transformOrigin" === p) {
															(R = void 0),
																(M = void 0),
																(I = void 0),
																(M = (R = (q = a).split(" "))[0]),
																(I = R[1] || "50%"),
																("top" !== M &&
																	"bottom" !== M &&
																	"left" !== I &&
																	"right" !== I) ||
																	((q = M), (M = I), (I = q)),
																(R[0] = pi[M] || M),
																(R[1] = pi[I] || I),
																(a = R.join(" ")),
																S.svg
																	? Vi(t, a, 0, y, 0, this)
																	: ((d = parseFloat(a.split(" ")[2]) || 0) !==
																			S.zOrigin &&
																			ai(this, S, "zOrigin", S.zOrigin, d),
																	  ai(this, k, p, Ri(o), Ri(a)));
															continue;
														}
														if ("svgOrigin" === p) {
															Vi(t, a, 1, y, 0, this);
															continue;
														}
														if (p in fi) {
															Oi(this, S, p, c, a, m);
															continue;
														}
														if ("smoothOrigin" === p) {
															ai(this, S, "smooth", S.smooth, a);
															continue;
														}
														if ("force3D" === p) {
															S[p] = a;
															continue;
														}
														if ("transform" === p) {
															Ki(this, a, t);
															continue;
														}
													}
												else p in k || (p = $n(p) || p);
												if (
													f ||
													((s || 0 === s) &&
														(c || 0 === c) &&
														!Wn.test(a) &&
														p in k)
												)
													s || (s = 0),
														(u = (o + "").substr((c + "").length)) !==
															(d = ie(a) || (p in K.units ? K.units[p] : u)) &&
															(c = ci(t, p, o, d)),
														(this._pt = new dn(
															this._pt,
															f ? S : k,
															p,
															c,
															m ? m * s : s - c,
															f ||
															("px" !== d && "zIndex" !== p) ||
															!1 === e.autoRound
																? Cn
																: Hn
														)),
														(this._pt.u = d || 0),
														u !== d && ((this._pt.b = o), (this._pt.r = Zn));
												else if (p in k) hi.call(this, t, p, o, a);
												else {
													if (!(p in t)) {
														st(p, a);
														continue;
													}
													this.add(t, p, t[p], a, i, r);
												}
												v.push(p);
											}
									V && un(this);
								},
								get: li,
								aliases: En,
								getSetter: function (t, e, n) {
									var i = En[e];
									return (
										i && i.indexOf(",") < 0 && (e = i),
										e in xn && e !== Pn && (t._gsap.x || li(t, "x"))
											? n && In === n
												? "scale" === e
													? Bn
													: Ln
												: (In = n || {}) && ("scale" === e ? Gn : Qn)
											: t.style && !L(t.style[e])
											? Dn
											: ~e.indexOf("-")
											? An
											: rn(t, e)
									);
								},
								core: { _removeProperty: oi, _getMatrix: yi },
							};
						(Sn.utils.checkPrefix = $n),
							(zi = Mt(
								"x,y,z,scale,scaleX,scaleY,xPercent,yPercent" +
									"," +
									(Ti = "rotation,rotationX,rotationY,skewX,skewY") +
									",transform,transformOrigin,svgOrigin,force3D,smoothOrigin,transformPerspective",
								function (t) {
									xn[t] = 1;
								}
							)),
							Mt(Ti, function (t) {
								(K.units[t] = "deg"), (fi[t] = 1);
							}),
							(En[zi[13]] =
								"x,y,z,scale,scaleX,scaleY,xPercent,yPercent," + Ti),
							Mt(
								"0:translateX,1:translateY,2:translateZ,8:rotate,8:rotationZ,8:rotateZ,9:rotateX,10:rotateY",
								function (t) {
									var e = t.split(":");
									En[e[1]] = zi[e[0]];
								}
							),
							Mt(
								"x,y,z,top,right,bottom,left,width,height,fontSize,padding,margin,perspective",
								function (t) {
									K.units[t] = "px";
								}
							),
							Sn.registerPlugin(Wi);
						var Ei = Sn.registerPlugin(Wi) || Sn;
						Ei.core.Tween,
							void 0 === Number.EPSILON && (Number.EPSILON = Math.pow(2, -52)),
							void 0 === Number.isInteger &&
								(Number.isInteger = function (t) {
									return (
										"number" == typeof t && isFinite(t) && Math.floor(t) === t
									);
								}),
							void 0 === Math.sign &&
								(Math.sign = function (t) {
									return t < 0 ? -1 : t > 0 ? 1 : +t;
								}),
							"name" in Function.prototype == 0 &&
								Object.defineProperty(Function.prototype, "name", {
									get: function () {
										return this.toString().match(
											/^\s*function\s*([^\(\s]*)/
										)[1];
									},
								}),
							void 0 === Object.assign &&
								(Object.assign = function (t) {
									if (null == t)
										throw new TypeError(
											"Cannot convert undefined or null to object"
										);
									const e = Object(t);
									for (let t = 1; t < arguments.length; t++) {
										const n = arguments[t];
										if (null != n)
											for (const t in n)
												Object.prototype.hasOwnProperty.call(n, t) &&
													(e[t] = n[t]);
									}
									return e;
								});
						const Ci = 100,
							Fi = 306,
							Zi = 307,
							Hi = 1e3,
							Ni = 1001,
							ji = 1002,
							Di = 1003,
							Ai = 1004,
							Li = 1005,
							Bi = 1006,
							Gi = 1008,
							Qi = 1009,
							_i = 1012,
							Pi = 1014,
							Ji = 1015,
							Yi = 1016,
							Xi = 1020,
							$i = 1022,
							tr = 1023,
							er = 1026,
							nr = 1027,
							ir = 2300,
							rr = 2301,
							or = 2302,
							ar = 2400,
							sr = 2401,
							cr = 2402,
							lr = 2500,
							hr = 3e3,
							pr = 3001,
							ur = 3007,
							dr = 3002,
							mr = 7680,
							fr = 35044,
							gr = 35048;
						function Sr() {}
						Object.assign(Sr.prototype, {
							addEventListener: function (t, e) {
								void 0 === this._listeners && (this._listeners = {});
								const n = this._listeners;
								void 0 === n[t] && (n[t] = []),
									-1 === n[t].indexOf(e) && n[t].push(e);
							},
							hasEventListener: function (t, e) {
								if (void 0 === this._listeners) return !1;
								const n = this._listeners;
								return void 0 !== n[t] && -1 !== n[t].indexOf(e);
							},
							removeEventListener: function (t, e) {
								if (void 0 === this._listeners) return;
								const n = this._listeners[t];
								if (void 0 !== n) {
									const t = n.indexOf(e);
									-1 !== t && n.splice(t, 1);
								}
							},
							dispatchEvent: function (t) {
								if (void 0 === this._listeners) return;
								const e = this._listeners[t.type];
								if (void 0 !== e) {
									t.target = this;
									const n = e.slice(0);
									for (let e = 0, i = n.length; e < i; e++) n[e].call(this, t);
								}
							},
						});
						const yr = [];
						for (let t = 0; t < 256; t++)
							yr[t] = (t < 16 ? "0" : "") + t.toString(16);
						let Vr = 1234567;
						const qr = {
							DEG2RAD: Math.PI / 180,
							RAD2DEG: 180 / Math.PI,
							generateUUID: function () {
								const t = (4294967295 * Math.random()) | 0,
									e = (4294967295 * Math.random()) | 0,
									n = (4294967295 * Math.random()) | 0,
									i = (4294967295 * Math.random()) | 0;
								return (
									yr[255 & t] +
									yr[(t >> 8) & 255] +
									yr[(t >> 16) & 255] +
									yr[(t >> 24) & 255] +
									"-" +
									yr[255 & e] +
									yr[(e >> 8) & 255] +
									"-" +
									yr[((e >> 16) & 15) | 64] +
									yr[(e >> 24) & 255] +
									"-" +
									yr[(63 & n) | 128] +
									yr[(n >> 8) & 255] +
									"-" +
									yr[(n >> 16) & 255] +
									yr[(n >> 24) & 255] +
									yr[255 & i] +
									yr[(i >> 8) & 255] +
									yr[(i >> 16) & 255] +
									yr[(i >> 24) & 255]
								).toUpperCase();
							},
							clamp: function (t, e, n) {
								return Math.max(e, Math.min(n, t));
							},
							euclideanModulo: function (t, e) {
								return ((t % e) + e) % e;
							},
							mapLinear: function (t, e, n, i, r) {
								return i + ((t - e) * (r - i)) / (n - e);
							},
							lerp: function (t, e, n) {
								return (1 - n) * t + n * e;
							},
							smoothstep: function (t, e, n) {
								return t <= e
									? 0
									: t >= n
									? 1
									: (t = (t - e) / (n - e)) * t * (3 - 2 * t);
							},
							smootherstep: function (t, e, n) {
								return t <= e
									? 0
									: t >= n
									? 1
									: (t = (t - e) / (n - e)) * t * t * (t * (6 * t - 15) + 10);
							},
							randInt: function (t, e) {
								return t + Math.floor(Math.random() * (e - t + 1));
							},
							randFloat: function (t, e) {
								return t + Math.random() * (e - t);
							},
							randFloatSpread: function (t) {
								return t * (0.5 - Math.random());
							},
							seededRandom: function (t) {
								return (
									void 0 !== t && (Vr = t % 2147483647),
									(Vr = (16807 * Vr) % 2147483647),
									(Vr - 1) / 2147483646
								);
							},
							degToRad: function (t) {
								return t * qr.DEG2RAD;
							},
							radToDeg: function (t) {
								return t * qr.RAD2DEG;
							},
							isPowerOfTwo: function (t) {
								return 0 == (t & (t - 1)) && 0 !== t;
							},
							ceilPowerOfTwo: function (t) {
								return Math.pow(2, Math.ceil(Math.log(t) / Math.LN2));
							},
							floorPowerOfTwo: function (t) {
								return Math.pow(2, Math.floor(Math.log(t) / Math.LN2));
							},
							setQuaternionFromProperEuler: function (t, e, n, i, r) {
								const o = Math.cos,
									a = Math.sin,
									s = o(n / 2),
									c = a(n / 2),
									l = o((e + i) / 2),
									h = a((e + i) / 2),
									p = o((e - i) / 2),
									u = a((e - i) / 2),
									d = o((i - e) / 2),
									m = a((i - e) / 2);
								switch (r) {
									case "XYX":
										t.set(s * h, c * p, c * u, s * l);
										break;
									case "YZY":
										t.set(c * u, s * h, c * p, s * l);
										break;
									case "ZXZ":
										t.set(c * p, c * u, s * h, s * l);
										break;
									case "XZX":
										t.set(s * h, c * m, c * d, s * l);
										break;
									case "YXY":
										t.set(c * d, s * h, c * m, s * l);
										break;
									case "ZYZ":
										t.set(c * m, c * d, s * h, s * l);
										break;
									default:
										console.warn(
											"THREE.MathUtils: .setQuaternionFromProperEuler() encountered an unknown order: " +
												r
										);
								}
							},
						};
						function Rr(t = 0, e = 0) {
							(this.x = t), (this.y = e);
						}
						function Mr() {
							(this.elements = [1, 0, 0, 0, 1, 0, 0, 0, 1]),
								arguments.length > 0 &&
									console.error(
										"THREE.Matrix3: the constructor no longer reads arguments. use .set() instead."
									);
						}
						let Ir;
						Object.defineProperties(Rr.prototype, {
							width: {
								get: function () {
									return this.x;
								},
								set: function (t) {
									this.x = t;
								},
							},
							height: {
								get: function () {
									return this.y;
								},
								set: function (t) {
									this.y = t;
								},
							},
						}),
							Object.assign(Rr.prototype, {
								isVector2: !0,
								set: function (t, e) {
									return (this.x = t), (this.y = e), this;
								},
								setScalar: function (t) {
									return (this.x = t), (this.y = t), this;
								},
								setX: function (t) {
									return (this.x = t), this;
								},
								setY: function (t) {
									return (this.y = t), this;
								},
								setComponent: function (t, e) {
									switch (t) {
										case 0:
											this.x = e;
											break;
										case 1:
											this.y = e;
											break;
										default:
											throw new Error("index is out of range: " + t);
									}
									return this;
								},
								getComponent: function (t) {
									switch (t) {
										case 0:
											return this.x;
										case 1:
											return this.y;
										default:
											throw new Error("index is out of range: " + t);
									}
								},
								clone: function () {
									return new this.constructor(this.x, this.y);
								},
								copy: function (t) {
									return (this.x = t.x), (this.y = t.y), this;
								},
								add: function (t, e) {
									return void 0 !== e
										? (console.warn(
												"THREE.Vector2: .add() now only accepts one argument. Use .addVectors( a, b ) instead."
										  ),
										  this.addVectors(t, e))
										: ((this.x += t.x), (this.y += t.y), this);
								},
								addScalar: function (t) {
									return (this.x += t), (this.y += t), this;
								},
								addVectors: function (t, e) {
									return (this.x = t.x + e.x), (this.y = t.y + e.y), this;
								},
								addScaledVector: function (t, e) {
									return (this.x += t.x * e), (this.y += t.y * e), this;
								},
								sub: function (t, e) {
									return void 0 !== e
										? (console.warn(
												"THREE.Vector2: .sub() now only accepts one argument. Use .subVectors( a, b ) instead."
										  ),
										  this.subVectors(t, e))
										: ((this.x -= t.x), (this.y -= t.y), this);
								},
								subScalar: function (t) {
									return (this.x -= t), (this.y -= t), this;
								},
								subVectors: function (t, e) {
									return (this.x = t.x - e.x), (this.y = t.y - e.y), this;
								},
								multiply: function (t) {
									return (this.x *= t.x), (this.y *= t.y), this;
								},
								multiplyScalar: function (t) {
									return (this.x *= t), (this.y *= t), this;
								},
								divide: function (t) {
									return (this.x /= t.x), (this.y /= t.y), this;
								},
								divideScalar: function (t) {
									return this.multiplyScalar(1 / t);
								},
								applyMatrix3: function (t) {
									const e = this.x,
										n = this.y,
										i = t.elements;
									return (
										(this.x = i[0] * e + i[3] * n + i[6]),
										(this.y = i[1] * e + i[4] * n + i[7]),
										this
									);
								},
								min: function (t) {
									return (
										(this.x = Math.min(this.x, t.x)),
										(this.y = Math.min(this.y, t.y)),
										this
									);
								},
								max: function (t) {
									return (
										(this.x = Math.max(this.x, t.x)),
										(this.y = Math.max(this.y, t.y)),
										this
									);
								},
								clamp: function (t, e) {
									return (
										(this.x = Math.max(t.x, Math.min(e.x, this.x))),
										(this.y = Math.max(t.y, Math.min(e.y, this.y))),
										this
									);
								},
								clampScalar: function (t, e) {
									return (
										(this.x = Math.max(t, Math.min(e, this.x))),
										(this.y = Math.max(t, Math.min(e, this.y))),
										this
									);
								},
								clampLength: function (t, e) {
									const n = this.length();
									return this.divideScalar(n || 1).multiplyScalar(
										Math.max(t, Math.min(e, n))
									);
								},
								floor: function () {
									return (
										(this.x = Math.floor(this.x)),
										(this.y = Math.floor(this.y)),
										this
									);
								},
								ceil: function () {
									return (
										(this.x = Math.ceil(this.x)),
										(this.y = Math.ceil(this.y)),
										this
									);
								},
								round: function () {
									return (
										(this.x = Math.round(this.x)),
										(this.y = Math.round(this.y)),
										this
									);
								},
								roundToZero: function () {
									return (
										(this.x =
											this.x < 0 ? Math.ceil(this.x) : Math.floor(this.x)),
										(this.y =
											this.y < 0 ? Math.ceil(this.y) : Math.floor(this.y)),
										this
									);
								},
								negate: function () {
									return (this.x = -this.x), (this.y = -this.y), this;
								},
								dot: function (t) {
									return this.x * t.x + this.y * t.y;
								},
								cross: function (t) {
									return this.x * t.y - this.y * t.x;
								},
								lengthSq: function () {
									return this.x * this.x + this.y * this.y;
								},
								length: function () {
									return Math.sqrt(this.x * this.x + this.y * this.y);
								},
								manhattanLength: function () {
									return Math.abs(this.x) + Math.abs(this.y);
								},
								normalize: function () {
									return this.divideScalar(this.length() || 1);
								},
								angle: function () {
									return Math.atan2(-this.y, -this.x) + Math.PI;
								},
								distanceTo: function (t) {
									return Math.sqrt(this.distanceToSquared(t));
								},
								distanceToSquared: function (t) {
									const e = this.x - t.x,
										n = this.y - t.y;
									return e * e + n * n;
								},
								manhattanDistanceTo: function (t) {
									return Math.abs(this.x - t.x) + Math.abs(this.y - t.y);
								},
								setLength: function (t) {
									return this.normalize().multiplyScalar(t);
								},
								lerp: function (t, e) {
									return (
										(this.x += (t.x - this.x) * e),
										(this.y += (t.y - this.y) * e),
										this
									);
								},
								lerpVectors: function (t, e, n) {
									return (
										(this.x = t.x + (e.x - t.x) * n),
										(this.y = t.y + (e.y - t.y) * n),
										this
									);
								},
								equals: function (t) {
									return t.x === this.x && t.y === this.y;
								},
								fromArray: function (t, e) {
									return (
										void 0 === e && (e = 0),
										(this.x = t[e]),
										(this.y = t[e + 1]),
										this
									);
								},
								toArray: function (t, e) {
									return (
										void 0 === t && (t = []),
										void 0 === e && (e = 0),
										(t[e] = this.x),
										(t[e + 1] = this.y),
										t
									);
								},
								fromBufferAttribute: function (t, e, n) {
									return (
										void 0 !== n &&
											console.warn(
												"THREE.Vector2: offset has been removed from .fromBufferAttribute()."
											),
										(this.x = t.getX(e)),
										(this.y = t.getY(e)),
										this
									);
								},
								rotateAround: function (t, e) {
									const n = Math.cos(e),
										i = Math.sin(e),
										r = this.x - t.x,
										o = this.y - t.y;
									return (
										(this.x = r * n - o * i + t.x),
										(this.y = r * i + o * n + t.y),
										this
									);
								},
								random: function () {
									return (
										(this.x = Math.random()), (this.y = Math.random()), this
									);
								},
							}),
							Object.assign(Mr.prototype, {
								isMatrix3: !0,
								set: function (t, e, n, i, r, o, a, s, c) {
									const l = this.elements;
									return (
										(l[0] = t),
										(l[1] = i),
										(l[2] = a),
										(l[3] = e),
										(l[4] = r),
										(l[5] = s),
										(l[6] = n),
										(l[7] = o),
										(l[8] = c),
										this
									);
								},
								identity: function () {
									return this.set(1, 0, 0, 0, 1, 0, 0, 0, 1), this;
								},
								clone: function () {
									return new this.constructor().fromArray(this.elements);
								},
								copy: function (t) {
									const e = this.elements,
										n = t.elements;
									return (
										(e[0] = n[0]),
										(e[1] = n[1]),
										(e[2] = n[2]),
										(e[3] = n[3]),
										(e[4] = n[4]),
										(e[5] = n[5]),
										(e[6] = n[6]),
										(e[7] = n[7]),
										(e[8] = n[8]),
										this
									);
								},
								extractBasis: function (t, e, n) {
									return (
										t.setFromMatrix3Column(this, 0),
										e.setFromMatrix3Column(this, 1),
										n.setFromMatrix3Column(this, 2),
										this
									);
								},
								setFromMatrix4: function (t) {
									const e = t.elements;
									return (
										this.set(
											e[0],
											e[4],
											e[8],
											e[1],
											e[5],
											e[9],
											e[2],
											e[6],
											e[10]
										),
										this
									);
								},
								multiply: function (t) {
									return this.multiplyMatrices(this, t);
								},
								premultiply: function (t) {
									return this.multiplyMatrices(t, this);
								},
								multiplyMatrices: function (t, e) {
									const n = t.elements,
										i = e.elements,
										r = this.elements,
										o = n[0],
										a = n[3],
										s = n[6],
										c = n[1],
										l = n[4],
										h = n[7],
										p = n[2],
										u = n[5],
										d = n[8],
										m = i[0],
										f = i[3],
										g = i[6],
										S = i[1],
										y = i[4],
										V = i[7],
										q = i[2],
										R = i[5],
										M = i[8];
									return (
										(r[0] = o * m + a * S + s * q),
										(r[3] = o * f + a * y + s * R),
										(r[6] = o * g + a * V + s * M),
										(r[1] = c * m + l * S + h * q),
										(r[4] = c * f + l * y + h * R),
										(r[7] = c * g + l * V + h * M),
										(r[2] = p * m + u * S + d * q),
										(r[5] = p * f + u * y + d * R),
										(r[8] = p * g + u * V + d * M),
										this
									);
								},
								multiplyScalar: function (t) {
									const e = this.elements;
									return (
										(e[0] *= t),
										(e[3] *= t),
										(e[6] *= t),
										(e[1] *= t),
										(e[4] *= t),
										(e[7] *= t),
										(e[2] *= t),
										(e[5] *= t),
										(e[8] *= t),
										this
									);
								},
								determinant: function () {
									const t = this.elements,
										e = t[0],
										n = t[1],
										i = t[2],
										r = t[3],
										o = t[4],
										a = t[5],
										s = t[6],
										c = t[7],
										l = t[8];
									return (
										e * o * l -
										e * a * c -
										n * r * l +
										n * a * s +
										i * r * c -
										i * o * s
									);
								},
								getInverse: function (t, e) {
									void 0 !== e &&
										console.warn(
											"THREE.Matrix3: .getInverse() can no longer be configured to throw on degenerate."
										);
									const n = t.elements,
										i = this.elements,
										r = n[0],
										o = n[1],
										a = n[2],
										s = n[3],
										c = n[4],
										l = n[5],
										h = n[6],
										p = n[7],
										u = n[8],
										d = u * c - l * p,
										m = l * h - u * s,
										f = p * s - c * h,
										g = r * d + o * m + a * f;
									if (0 === g) return this.set(0, 0, 0, 0, 0, 0, 0, 0, 0);
									const S = 1 / g;
									return (
										(i[0] = d * S),
										(i[1] = (a * p - u * o) * S),
										(i[2] = (l * o - a * c) * S),
										(i[3] = m * S),
										(i[4] = (u * r - a * h) * S),
										(i[5] = (a * s - l * r) * S),
										(i[6] = f * S),
										(i[7] = (o * h - p * r) * S),
										(i[8] = (c * r - o * s) * S),
										this
									);
								},
								transpose: function () {
									let t;
									const e = this.elements;
									return (
										(t = e[1]),
										(e[1] = e[3]),
										(e[3] = t),
										(t = e[2]),
										(e[2] = e[6]),
										(e[6] = t),
										(t = e[5]),
										(e[5] = e[7]),
										(e[7] = t),
										this
									);
								},
								getNormalMatrix: function (t) {
									return this.setFromMatrix4(t).getInverse(this).transpose();
								},
								transposeIntoArray: function (t) {
									const e = this.elements;
									return (
										(t[0] = e[0]),
										(t[1] = e[3]),
										(t[2] = e[6]),
										(t[3] = e[1]),
										(t[4] = e[4]),
										(t[5] = e[7]),
										(t[6] = e[2]),
										(t[7] = e[5]),
										(t[8] = e[8]),
										this
									);
								},
								setUvTransform: function (t, e, n, i, r, o, a) {
									const s = Math.cos(r),
										c = Math.sin(r);
									this.set(
										n * s,
										n * c,
										-n * (s * o + c * a) + o + t,
										-i * c,
										i * s,
										-i * (-c * o + s * a) + a + e,
										0,
										0,
										1
									);
								},
								scale: function (t, e) {
									const n = this.elements;
									return (
										(n[0] *= t),
										(n[3] *= t),
										(n[6] *= t),
										(n[1] *= e),
										(n[4] *= e),
										(n[7] *= e),
										this
									);
								},
								rotate: function (t) {
									const e = Math.cos(t),
										n = Math.sin(t),
										i = this.elements,
										r = i[0],
										o = i[3],
										a = i[6],
										s = i[1],
										c = i[4],
										l = i[7];
									return (
										(i[0] = e * r + n * s),
										(i[3] = e * o + n * c),
										(i[6] = e * a + n * l),
										(i[1] = -n * r + e * s),
										(i[4] = -n * o + e * c),
										(i[7] = -n * a + e * l),
										this
									);
								},
								translate: function (t, e) {
									const n = this.elements;
									return (
										(n[0] += t * n[2]),
										(n[3] += t * n[5]),
										(n[6] += t * n[8]),
										(n[1] += e * n[2]),
										(n[4] += e * n[5]),
										(n[7] += e * n[8]),
										this
									);
								},
								equals: function (t) {
									const e = this.elements,
										n = t.elements;
									for (let t = 0; t < 9; t++) if (e[t] !== n[t]) return !1;
									return !0;
								},
								fromArray: function (t, e) {
									void 0 === e && (e = 0);
									for (let n = 0; n < 9; n++) this.elements[n] = t[n + e];
									return this;
								},
								toArray: function (t, e) {
									void 0 === t && (t = []), void 0 === e && (e = 0);
									const n = this.elements;
									return (
										(t[e] = n[0]),
										(t[e + 1] = n[1]),
										(t[e + 2] = n[2]),
										(t[e + 3] = n[3]),
										(t[e + 4] = n[4]),
										(t[e + 5] = n[5]),
										(t[e + 6] = n[6]),
										(t[e + 7] = n[7]),
										(t[e + 8] = n[8]),
										t
									);
								},
							});
						const vr = {
							getDataURL: function (t) {
								if (/^data:/i.test(t.src)) return t.src;
								if ("undefined" == typeof HTMLCanvasElement) return t.src;
								let e;
								if (t instanceof HTMLCanvasElement) e = t;
								else {
									void 0 === Ir &&
										(Ir = document.createElementNS(
											"http://www.w3.org/1999/xhtml",
											"canvas"
										)),
										(Ir.width = t.width),
										(Ir.height = t.height);
									const n = Ir.getContext("2d");
									t instanceof ImageData
										? n.putImageData(t, 0, 0)
										: n.drawImage(t, 0, 0, t.width, t.height),
										(e = Ir);
								}
								return e.width > 2048 || e.height > 2048
									? e.toDataURL("image/jpeg", 0.6)
									: e.toDataURL("image/png");
							},
						};
						let kr = 0;
						function Ur(t, e, n, i, r, o, a, s, c, l) {
							Object.defineProperty(this, "id", { value: kr++ }),
								(this.uuid = qr.generateUUID()),
								(this.name = ""),
								(this.image = void 0 !== t ? t : Ur.DEFAULT_IMAGE),
								(this.mipmaps = []),
								(this.mapping = void 0 !== e ? e : Ur.DEFAULT_MAPPING),
								(this.wrapS = void 0 !== n ? n : Ni),
								(this.wrapT = void 0 !== i ? i : Ni),
								(this.magFilter = void 0 !== r ? r : Bi),
								(this.minFilter = void 0 !== o ? o : Gi),
								(this.anisotropy = void 0 !== c ? c : 1),
								(this.format = void 0 !== a ? a : tr),
								(this.internalFormat = null),
								(this.type = void 0 !== s ? s : Qi),
								(this.offset = new Rr(0, 0)),
								(this.repeat = new Rr(1, 1)),
								(this.center = new Rr(0, 0)),
								(this.rotation = 0),
								(this.matrixAutoUpdate = !0),
								(this.matrix = new Mr()),
								(this.generateMipmaps = !0),
								(this.premultiplyAlpha = !1),
								(this.flipY = !0),
								(this.unpackAlignment = 4),
								(this.encoding = void 0 !== l ? l : hr),
								(this.version = 0),
								(this.onUpdate = null);
						}
						function wr(t = 0, e = 0, n = 0, i = 1) {
							(this.x = t), (this.y = e), (this.z = n), (this.w = i);
						}
						function xr(t, e, n) {
							(this.width = t),
								(this.height = e),
								(this.scissor = new wr(0, 0, t, e)),
								(this.scissorTest = !1),
								(this.viewport = new wr(0, 0, t, e)),
								(n = n || {}),
								(this.texture = new Ur(
									void 0,
									n.mapping,
									n.wrapS,
									n.wrapT,
									n.magFilter,
									n.minFilter,
									n.format,
									n.type,
									n.anisotropy,
									n.encoding
								)),
								(this.texture.image = {}),
								(this.texture.image.width = t),
								(this.texture.image.height = e),
								(this.texture.generateMipmaps =
									void 0 !== n.generateMipmaps && n.generateMipmaps),
								(this.texture.minFilter =
									void 0 !== n.minFilter ? n.minFilter : Bi),
								(this.depthBuffer = void 0 === n.depthBuffer || n.depthBuffer),
								(this.stencilBuffer =
									void 0 === n.stencilBuffer || n.stencilBuffer),
								(this.depthTexture =
									void 0 !== n.depthTexture ? n.depthTexture : null);
						}
						function Or(t, e, n) {
							xr.call(this, t, e, n), (this.samples = 4);
						}
						function br(t = 0, e = 0, n = 0, i = 1) {
							(this._x = t), (this._y = e), (this._z = n), (this._w = i);
						}
						(Ur.DEFAULT_IMAGE = void 0),
							(Ur.DEFAULT_MAPPING = 300),
							(Ur.prototype = Object.assign(Object.create(Sr.prototype), {
								constructor: Ur,
								isTexture: !0,
								updateMatrix: function () {
									this.matrix.setUvTransform(
										this.offset.x,
										this.offset.y,
										this.repeat.x,
										this.repeat.y,
										this.rotation,
										this.center.x,
										this.center.y
									);
								},
								clone: function () {
									return new this.constructor().copy(this);
								},
								copy: function (t) {
									return (
										(this.name = t.name),
										(this.image = t.image),
										(this.mipmaps = t.mipmaps.slice(0)),
										(this.mapping = t.mapping),
										(this.wrapS = t.wrapS),
										(this.wrapT = t.wrapT),
										(this.magFilter = t.magFilter),
										(this.minFilter = t.minFilter),
										(this.anisotropy = t.anisotropy),
										(this.format = t.format),
										(this.internalFormat = t.internalFormat),
										(this.type = t.type),
										this.offset.copy(t.offset),
										this.repeat.copy(t.repeat),
										this.center.copy(t.center),
										(this.rotation = t.rotation),
										(this.matrixAutoUpdate = t.matrixAutoUpdate),
										this.matrix.copy(t.matrix),
										(this.generateMipmaps = t.generateMipmaps),
										(this.premultiplyAlpha = t.premultiplyAlpha),
										(this.flipY = t.flipY),
										(this.unpackAlignment = t.unpackAlignment),
										(this.encoding = t.encoding),
										this
									);
								},
								toJSON: function (t) {
									const e = void 0 === t || "string" == typeof t;
									if (!e && void 0 !== t.textures[this.uuid])
										return t.textures[this.uuid];
									const n = {
										metadata: {
											version: 4.5,
											type: "Texture",
											generator: "Texture.toJSON",
										},
										uuid: this.uuid,
										name: this.name,
										mapping: this.mapping,
										repeat: [this.repeat.x, this.repeat.y],
										offset: [this.offset.x, this.offset.y],
										center: [this.center.x, this.center.y],
										rotation: this.rotation,
										wrap: [this.wrapS, this.wrapT],
										format: this.format,
										type: this.type,
										encoding: this.encoding,
										minFilter: this.minFilter,
										magFilter: this.magFilter,
										anisotropy: this.anisotropy,
										flipY: this.flipY,
										premultiplyAlpha: this.premultiplyAlpha,
										unpackAlignment: this.unpackAlignment,
									};
									if (void 0 !== this.image) {
										const i = this.image;
										if (
											(void 0 === i.uuid && (i.uuid = qr.generateUUID()),
											!e && void 0 === t.images[i.uuid])
										) {
											let e;
											if (Array.isArray(i)) {
												e = [];
												for (let t = 0, n = i.length; t < n; t++)
													e.push(vr.getDataURL(i[t]));
											} else e = vr.getDataURL(i);
											t.images[i.uuid] = { uuid: i.uuid, url: e };
										}
										n.image = i.uuid;
									}
									return e || (t.textures[this.uuid] = n), n;
								},
								dispose: function () {
									this.dispatchEvent({ type: "dispose" });
								},
								transformUv: function (t) {
									if (300 !== this.mapping) return t;
									if ((t.applyMatrix3(this.matrix), t.x < 0 || t.x > 1))
										switch (this.wrapS) {
											case Hi:
												t.x = t.x - Math.floor(t.x);
												break;
											case Ni:
												t.x = t.x < 0 ? 0 : 1;
												break;
											case ji:
												1 === Math.abs(Math.floor(t.x) % 2)
													? (t.x = Math.ceil(t.x) - t.x)
													: (t.x = t.x - Math.floor(t.x));
										}
									if (t.y < 0 || t.y > 1)
										switch (this.wrapT) {
											case Hi:
												t.y = t.y - Math.floor(t.y);
												break;
											case Ni:
												t.y = t.y < 0 ? 0 : 1;
												break;
											case ji:
												1 === Math.abs(Math.floor(t.y) % 2)
													? (t.y = Math.ceil(t.y) - t.y)
													: (t.y = t.y - Math.floor(t.y));
										}
									return this.flipY && (t.y = 1 - t.y), t;
								},
							})),
							Object.defineProperty(Ur.prototype, "needsUpdate", {
								set: function (t) {
									!0 === t && this.version++;
								},
							}),
							Object.defineProperties(wr.prototype, {
								width: {
									get: function () {
										return this.z;
									},
									set: function (t) {
										this.z = t;
									},
								},
								height: {
									get: function () {
										return this.w;
									},
									set: function (t) {
										this.w = t;
									},
								},
							}),
							Object.assign(wr.prototype, {
								isVector4: !0,
								set: function (t, e, n, i) {
									return (
										(this.x = t), (this.y = e), (this.z = n), (this.w = i), this
									);
								},
								setScalar: function (t) {
									return (
										(this.x = t), (this.y = t), (this.z = t), (this.w = t), this
									);
								},
								setX: function (t) {
									return (this.x = t), this;
								},
								setY: function (t) {
									return (this.y = t), this;
								},
								setZ: function (t) {
									return (this.z = t), this;
								},
								setW: function (t) {
									return (this.w = t), this;
								},
								setComponent: function (t, e) {
									switch (t) {
										case 0:
											this.x = e;
											break;
										case 1:
											this.y = e;
											break;
										case 2:
											this.z = e;
											break;
										case 3:
											this.w = e;
											break;
										default:
											throw new Error("index is out of range: " + t);
									}
									return this;
								},
								getComponent: function (t) {
									switch (t) {
										case 0:
											return this.x;
										case 1:
											return this.y;
										case 2:
											return this.z;
										case 3:
											return this.w;
										default:
											throw new Error("index is out of range: " + t);
									}
								},
								clone: function () {
									return new this.constructor(this.x, this.y, this.z, this.w);
								},
								copy: function (t) {
									return (
										(this.x = t.x),
										(this.y = t.y),
										(this.z = t.z),
										(this.w = void 0 !== t.w ? t.w : 1),
										this
									);
								},
								add: function (t, e) {
									return void 0 !== e
										? (console.warn(
												"THREE.Vector4: .add() now only accepts one argument. Use .addVectors( a, b ) instead."
										  ),
										  this.addVectors(t, e))
										: ((this.x += t.x),
										  (this.y += t.y),
										  (this.z += t.z),
										  (this.w += t.w),
										  this);
								},
								addScalar: function (t) {
									return (
										(this.x += t),
										(this.y += t),
										(this.z += t),
										(this.w += t),
										this
									);
								},
								addVectors: function (t, e) {
									return (
										(this.x = t.x + e.x),
										(this.y = t.y + e.y),
										(this.z = t.z + e.z),
										(this.w = t.w + e.w),
										this
									);
								},
								addScaledVector: function (t, e) {
									return (
										(this.x += t.x * e),
										(this.y += t.y * e),
										(this.z += t.z * e),
										(this.w += t.w * e),
										this
									);
								},
								sub: function (t, e) {
									return void 0 !== e
										? (console.warn(
												"THREE.Vector4: .sub() now only accepts one argument. Use .subVectors( a, b ) instead."
										  ),
										  this.subVectors(t, e))
										: ((this.x -= t.x),
										  (this.y -= t.y),
										  (this.z -= t.z),
										  (this.w -= t.w),
										  this);
								},
								subScalar: function (t) {
									return (
										(this.x -= t),
										(this.y -= t),
										(this.z -= t),
										(this.w -= t),
										this
									);
								},
								subVectors: function (t, e) {
									return (
										(this.x = t.x - e.x),
										(this.y = t.y - e.y),
										(this.z = t.z - e.z),
										(this.w = t.w - e.w),
										this
									);
								},
								multiplyScalar: function (t) {
									return (
										(this.x *= t),
										(this.y *= t),
										(this.z *= t),
										(this.w *= t),
										this
									);
								},
								applyMatrix4: function (t) {
									const e = this.x,
										n = this.y,
										i = this.z,
										r = this.w,
										o = t.elements;
									return (
										(this.x = o[0] * e + o[4] * n + o[8] * i + o[12] * r),
										(this.y = o[1] * e + o[5] * n + o[9] * i + o[13] * r),
										(this.z = o[2] * e + o[6] * n + o[10] * i + o[14] * r),
										(this.w = o[3] * e + o[7] * n + o[11] * i + o[15] * r),
										this
									);
								},
								divideScalar: function (t) {
									return this.multiplyScalar(1 / t);
								},
								setAxisAngleFromQuaternion: function (t) {
									this.w = 2 * Math.acos(t.w);
									const e = Math.sqrt(1 - t.w * t.w);
									return (
										e < 1e-4
											? ((this.x = 1), (this.y = 0), (this.z = 0))
											: ((this.x = t.x / e),
											  (this.y = t.y / e),
											  (this.z = t.z / e)),
										this
									);
								},
								setAxisAngleFromRotationMatrix: function (t) {
									let e, n, i, r;
									const o = 0.01,
										a = 0.1,
										s = t.elements,
										c = s[0],
										l = s[4],
										h = s[8],
										p = s[1],
										u = s[5],
										d = s[9],
										m = s[2],
										f = s[6],
										g = s[10];
									if (
										Math.abs(l - p) < o &&
										Math.abs(h - m) < o &&
										Math.abs(d - f) < o
									) {
										if (
											Math.abs(l + p) < a &&
											Math.abs(h + m) < a &&
											Math.abs(d + f) < a &&
											Math.abs(c + u + g - 3) < a
										)
											return this.set(1, 0, 0, 0), this;
										e = Math.PI;
										const t = (c + 1) / 2,
											s = (u + 1) / 2,
											S = (g + 1) / 2,
											y = (l + p) / 4,
											V = (h + m) / 4,
											q = (d + f) / 4;
										return (
											t > s && t > S
												? t < o
													? ((n = 0), (i = 0.707106781), (r = 0.707106781))
													: ((n = Math.sqrt(t)), (i = y / n), (r = V / n))
												: s > S
												? s < o
													? ((n = 0.707106781), (i = 0), (r = 0.707106781))
													: ((i = Math.sqrt(s)), (n = y / i), (r = q / i))
												: S < o
												? ((n = 0.707106781), (i = 0.707106781), (r = 0))
												: ((r = Math.sqrt(S)), (n = V / r), (i = q / r)),
											this.set(n, i, r, e),
											this
										);
									}
									let S = Math.sqrt(
										(f - d) * (f - d) + (h - m) * (h - m) + (p - l) * (p - l)
									);
									return (
										Math.abs(S) < 0.001 && (S = 1),
										(this.x = (f - d) / S),
										(this.y = (h - m) / S),
										(this.z = (p - l) / S),
										(this.w = Math.acos((c + u + g - 1) / 2)),
										this
									);
								},
								min: function (t) {
									return (
										(this.x = Math.min(this.x, t.x)),
										(this.y = Math.min(this.y, t.y)),
										(this.z = Math.min(this.z, t.z)),
										(this.w = Math.min(this.w, t.w)),
										this
									);
								},
								max: function (t) {
									return (
										(this.x = Math.max(this.x, t.x)),
										(this.y = Math.max(this.y, t.y)),
										(this.z = Math.max(this.z, t.z)),
										(this.w = Math.max(this.w, t.w)),
										this
									);
								},
								clamp: function (t, e) {
									return (
										(this.x = Math.max(t.x, Math.min(e.x, this.x))),
										(this.y = Math.max(t.y, Math.min(e.y, this.y))),
										(this.z = Math.max(t.z, Math.min(e.z, this.z))),
										(this.w = Math.max(t.w, Math.min(e.w, this.w))),
										this
									);
								},
								clampScalar: function (t, e) {
									return (
										(this.x = Math.max(t, Math.min(e, this.x))),
										(this.y = Math.max(t, Math.min(e, this.y))),
										(this.z = Math.max(t, Math.min(e, this.z))),
										(this.w = Math.max(t, Math.min(e, this.w))),
										this
									);
								},
								clampLength: function (t, e) {
									const n = this.length();
									return this.divideScalar(n || 1).multiplyScalar(
										Math.max(t, Math.min(e, n))
									);
								},
								floor: function () {
									return (
										(this.x = Math.floor(this.x)),
										(this.y = Math.floor(this.y)),
										(this.z = Math.floor(this.z)),
										(this.w = Math.floor(this.w)),
										this
									);
								},
								ceil: function () {
									return (
										(this.x = Math.ceil(this.x)),
										(this.y = Math.ceil(this.y)),
										(this.z = Math.ceil(this.z)),
										(this.w = Math.ceil(this.w)),
										this
									);
								},
								round: function () {
									return (
										(this.x = Math.round(this.x)),
										(this.y = Math.round(this.y)),
										(this.z = Math.round(this.z)),
										(this.w = Math.round(this.w)),
										this
									);
								},
								roundToZero: function () {
									return (
										(this.x =
											this.x < 0 ? Math.ceil(this.x) : Math.floor(this.x)),
										(this.y =
											this.y < 0 ? Math.ceil(this.y) : Math.floor(this.y)),
										(this.z =
											this.z < 0 ? Math.ceil(this.z) : Math.floor(this.z)),
										(this.w =
											this.w < 0 ? Math.ceil(this.w) : Math.floor(this.w)),
										this
									);
								},
								negate: function () {
									return (
										(this.x = -this.x),
										(this.y = -this.y),
										(this.z = -this.z),
										(this.w = -this.w),
										this
									);
								},
								dot: function (t) {
									return (
										this.x * t.x + this.y * t.y + this.z * t.z + this.w * t.w
									);
								},
								lengthSq: function () {
									return (
										this.x * this.x +
										this.y * this.y +
										this.z * this.z +
										this.w * this.w
									);
								},
								length: function () {
									return Math.sqrt(
										this.x * this.x +
											this.y * this.y +
											this.z * this.z +
											this.w * this.w
									);
								},
								manhattanLength: function () {
									return (
										Math.abs(this.x) +
										Math.abs(this.y) +
										Math.abs(this.z) +
										Math.abs(this.w)
									);
								},
								normalize: function () {
									return this.divideScalar(this.length() || 1);
								},
								setLength: function (t) {
									return this.normalize().multiplyScalar(t);
								},
								lerp: function (t, e) {
									return (
										(this.x += (t.x - this.x) * e),
										(this.y += (t.y - this.y) * e),
										(this.z += (t.z - this.z) * e),
										(this.w += (t.w - this.w) * e),
										this
									);
								},
								lerpVectors: function (t, e, n) {
									return (
										(this.x = t.x + (e.x - t.x) * n),
										(this.y = t.y + (e.y - t.y) * n),
										(this.z = t.z + (e.z - t.z) * n),
										(this.w = t.w + (e.w - t.w) * n),
										this
									);
								},
								equals: function (t) {
									return (
										t.x === this.x &&
										t.y === this.y &&
										t.z === this.z &&
										t.w === this.w
									);
								},
								fromArray: function (t, e) {
									return (
										void 0 === e && (e = 0),
										(this.x = t[e]),
										(this.y = t[e + 1]),
										(this.z = t[e + 2]),
										(this.w = t[e + 3]),
										this
									);
								},
								toArray: function (t, e) {
									return (
										void 0 === t && (t = []),
										void 0 === e && (e = 0),
										(t[e] = this.x),
										(t[e + 1] = this.y),
										(t[e + 2] = this.z),
										(t[e + 3] = this.w),
										t
									);
								},
								fromBufferAttribute: function (t, e, n) {
									return (
										void 0 !== n &&
											console.warn(
												"THREE.Vector4: offset has been removed from .fromBufferAttribute()."
											),
										(this.x = t.getX(e)),
										(this.y = t.getY(e)),
										(this.z = t.getZ(e)),
										(this.w = t.getW(e)),
										this
									);
								},
								random: function () {
									return (
										(this.x = Math.random()),
										(this.y = Math.random()),
										(this.z = Math.random()),
										(this.w = Math.random()),
										this
									);
								},
							}),
							(xr.prototype = Object.assign(Object.create(Sr.prototype), {
								constructor: xr,
								isWebGLRenderTarget: !0,
								setSize: function (t, e) {
									(this.width === t && this.height === e) ||
										((this.width = t),
										(this.height = e),
										(this.texture.image.width = t),
										(this.texture.image.height = e),
										this.dispose()),
										this.viewport.set(0, 0, t, e),
										this.scissor.set(0, 0, t, e);
								},
								clone: function () {
									return new this.constructor().copy(this);
								},
								copy: function (t) {
									return (
										(this.width = t.width),
										(this.height = t.height),
										this.viewport.copy(t.viewport),
										(this.texture = t.texture.clone()),
										(this.depthBuffer = t.depthBuffer),
										(this.stencilBuffer = t.stencilBuffer),
										(this.depthTexture = t.depthTexture),
										this
									);
								},
								dispose: function () {
									this.dispatchEvent({ type: "dispose" });
								},
							})),
							(Or.prototype = Object.assign(Object.create(xr.prototype), {
								constructor: Or,
								isWebGLMultisampleRenderTarget: !0,
								copy: function (t) {
									return (
										xr.prototype.copy.call(this, t),
										(this.samples = t.samples),
										this
									);
								},
							})),
							Object.assign(br, {
								slerp: function (t, e, n, i) {
									return n.copy(t).slerp(e, i);
								},
								slerpFlat: function (t, e, n, i, r, o, a) {
									let s = n[i + 0],
										c = n[i + 1],
										l = n[i + 2],
										h = n[i + 3];
									const p = r[o + 0],
										u = r[o + 1],
										d = r[o + 2],
										m = r[o + 3];
									if (h !== m || s !== p || c !== u || l !== d) {
										let t = 1 - a,
											e = s * p + c * u + l * d + h * m,
											n = e >= 0 ? 1 : -1,
											i = 1 - e * e;
										if (i > Number.EPSILON) {
											const r = Math.sqrt(i),
												o = Math.atan2(r, e * n);
											(t = Math.sin(t * o) / r), (a = Math.sin(a * o) / r);
										}
										const r = a * n;
										if (
											((s = s * t + p * r),
											(c = c * t + u * r),
											(l = l * t + d * r),
											(h = h * t + m * r),
											t === 1 - a)
										) {
											const t = 1 / Math.sqrt(s * s + c * c + l * l + h * h);
											(s *= t), (c *= t), (l *= t), (h *= t);
										}
									}
									(t[e] = s), (t[e + 1] = c), (t[e + 2] = l), (t[e + 3] = h);
								},
								multiplyQuaternionsFlat: function (t, e, n, i, r, o) {
									const a = n[i],
										s = n[i + 1],
										c = n[i + 2],
										l = n[i + 3],
										h = r[o],
										p = r[o + 1],
										u = r[o + 2],
										d = r[o + 3];
									return (
										(t[e] = a * d + l * h + s * u - c * p),
										(t[e + 1] = s * d + l * p + c * h - a * u),
										(t[e + 2] = c * d + l * u + a * p - s * h),
										(t[e + 3] = l * d - a * h - s * p - c * u),
										t
									);
								},
							}),
							Object.defineProperties(br.prototype, {
								x: {
									get: function () {
										return this._x;
									},
									set: function (t) {
										(this._x = t), this._onChangeCallback();
									},
								},
								y: {
									get: function () {
										return this._y;
									},
									set: function (t) {
										(this._y = t), this._onChangeCallback();
									},
								},
								z: {
									get: function () {
										return this._z;
									},
									set: function (t) {
										(this._z = t), this._onChangeCallback();
									},
								},
								w: {
									get: function () {
										return this._w;
									},
									set: function (t) {
										(this._w = t), this._onChangeCallback();
									},
								},
							}),
							Object.assign(br.prototype, {
								isQuaternion: !0,
								set: function (t, e, n, i) {
									return (
										(this._x = t),
										(this._y = e),
										(this._z = n),
										(this._w = i),
										this._onChangeCallback(),
										this
									);
								},
								clone: function () {
									return new this.constructor(
										this._x,
										this._y,
										this._z,
										this._w
									);
								},
								copy: function (t) {
									return (
										(this._x = t.x),
										(this._y = t.y),
										(this._z = t.z),
										(this._w = t.w),
										this._onChangeCallback(),
										this
									);
								},
								setFromEuler: function (t, e) {
									if (!t || !t.isEuler)
										throw new Error(
											"THREE.Quaternion: .setFromEuler() now expects an Euler rotation rather than a Vector3 and order."
										);
									const n = t._x,
										i = t._y,
										r = t._z,
										o = t.order,
										a = Math.cos,
										s = Math.sin,
										c = a(n / 2),
										l = a(i / 2),
										h = a(r / 2),
										p = s(n / 2),
										u = s(i / 2),
										d = s(r / 2);
									switch (o) {
										case "XYZ":
											(this._x = p * l * h + c * u * d),
												(this._y = c * u * h - p * l * d),
												(this._z = c * l * d + p * u * h),
												(this._w = c * l * h - p * u * d);
											break;
										case "YXZ":
											(this._x = p * l * h + c * u * d),
												(this._y = c * u * h - p * l * d),
												(this._z = c * l * d - p * u * h),
												(this._w = c * l * h + p * u * d);
											break;
										case "ZXY":
											(this._x = p * l * h - c * u * d),
												(this._y = c * u * h + p * l * d),
												(this._z = c * l * d + p * u * h),
												(this._w = c * l * h - p * u * d);
											break;
										case "ZYX":
											(this._x = p * l * h - c * u * d),
												(this._y = c * u * h + p * l * d),
												(this._z = c * l * d - p * u * h),
												(this._w = c * l * h + p * u * d);
											break;
										case "YZX":
											(this._x = p * l * h + c * u * d),
												(this._y = c * u * h + p * l * d),
												(this._z = c * l * d - p * u * h),
												(this._w = c * l * h - p * u * d);
											break;
										case "XZY":
											(this._x = p * l * h - c * u * d),
												(this._y = c * u * h - p * l * d),
												(this._z = c * l * d + p * u * h),
												(this._w = c * l * h + p * u * d);
											break;
										default:
											console.warn(
												"THREE.Quaternion: .setFromEuler() encountered an unknown order: " +
													o
											);
									}
									return !1 !== e && this._onChangeCallback(), this;
								},
								setFromAxisAngle: function (t, e) {
									const n = e / 2,
										i = Math.sin(n);
									return (
										(this._x = t.x * i),
										(this._y = t.y * i),
										(this._z = t.z * i),
										(this._w = Math.cos(n)),
										this._onChangeCallback(),
										this
									);
								},
								setFromRotationMatrix: function (t) {
									const e = t.elements,
										n = e[0],
										i = e[4],
										r = e[8],
										o = e[1],
										a = e[5],
										s = e[9],
										c = e[2],
										l = e[6],
										h = e[10],
										p = n + a + h;
									if (p > 0) {
										const t = 0.5 / Math.sqrt(p + 1);
										(this._w = 0.25 / t),
											(this._x = (l - s) * t),
											(this._y = (r - c) * t),
											(this._z = (o - i) * t);
									} else if (n > a && n > h) {
										const t = 2 * Math.sqrt(1 + n - a - h);
										(this._w = (l - s) / t),
											(this._x = 0.25 * t),
											(this._y = (i + o) / t),
											(this._z = (r + c) / t);
									} else if (a > h) {
										const t = 2 * Math.sqrt(1 + a - n - h);
										(this._w = (r - c) / t),
											(this._x = (i + o) / t),
											(this._y = 0.25 * t),
											(this._z = (s + l) / t);
									} else {
										const t = 2 * Math.sqrt(1 + h - n - a);
										(this._w = (o - i) / t),
											(this._x = (r + c) / t),
											(this._y = (s + l) / t),
											(this._z = 0.25 * t);
									}
									return this._onChangeCallback(), this;
								},
								setFromUnitVectors: function (t, e) {
									let n = t.dot(e) + 1;
									return (
										n < 1e-6
											? ((n = 0),
											  Math.abs(t.x) > Math.abs(t.z)
													? ((this._x = -t.y),
													  (this._y = t.x),
													  (this._z = 0),
													  (this._w = n))
													: ((this._x = 0),
													  (this._y = -t.z),
													  (this._z = t.y),
													  (this._w = n)))
											: ((this._x = t.y * e.z - t.z * e.y),
											  (this._y = t.z * e.x - t.x * e.z),
											  (this._z = t.x * e.y - t.y * e.x),
											  (this._w = n)),
										this.normalize()
									);
								},
								angleTo: function (t) {
									return 2 * Math.acos(Math.abs(qr.clamp(this.dot(t), -1, 1)));
								},
								rotateTowards: function (t, e) {
									const n = this.angleTo(t);
									if (0 === n) return this;
									const i = Math.min(1, e / n);
									return this.slerp(t, i), this;
								},
								identity: function () {
									return this.set(0, 0, 0, 1);
								},
								inverse: function () {
									return this.conjugate();
								},
								conjugate: function () {
									return (
										(this._x *= -1),
										(this._y *= -1),
										(this._z *= -1),
										this._onChangeCallback(),
										this
									);
								},
								dot: function (t) {
									return (
										this._x * t._x +
										this._y * t._y +
										this._z * t._z +
										this._w * t._w
									);
								},
								lengthSq: function () {
									return (
										this._x * this._x +
										this._y * this._y +
										this._z * this._z +
										this._w * this._w
									);
								},
								length: function () {
									return Math.sqrt(
										this._x * this._x +
											this._y * this._y +
											this._z * this._z +
											this._w * this._w
									);
								},
								normalize: function () {
									let t = this.length();
									return (
										0 === t
											? ((this._x = 0),
											  (this._y = 0),
											  (this._z = 0),
											  (this._w = 1))
											: ((t = 1 / t),
											  (this._x = this._x * t),
											  (this._y = this._y * t),
											  (this._z = this._z * t),
											  (this._w = this._w * t)),
										this._onChangeCallback(),
										this
									);
								},
								multiply: function (t, e) {
									return void 0 !== e
										? (console.warn(
												"THREE.Quaternion: .multiply() now only accepts one argument. Use .multiplyQuaternions( a, b ) instead."
										  ),
										  this.multiplyQuaternions(t, e))
										: this.multiplyQuaternions(this, t);
								},
								premultiply: function (t) {
									return this.multiplyQuaternions(t, this);
								},
								multiplyQuaternions: function (t, e) {
									const n = t._x,
										i = t._y,
										r = t._z,
										o = t._w,
										a = e._x,
										s = e._y,
										c = e._z,
										l = e._w;
									return (
										(this._x = n * l + o * a + i * c - r * s),
										(this._y = i * l + o * s + r * a - n * c),
										(this._z = r * l + o * c + n * s - i * a),
										(this._w = o * l - n * a - i * s - r * c),
										this._onChangeCallback(),
										this
									);
								},
								slerp: function (t, e) {
									if (0 === e) return this;
									if (1 === e) return this.copy(t);
									const n = this._x,
										i = this._y,
										r = this._z,
										o = this._w;
									let a = o * t._w + n * t._x + i * t._y + r * t._z;
									if (
										(a < 0
											? ((this._w = -t._w),
											  (this._x = -t._x),
											  (this._y = -t._y),
											  (this._z = -t._z),
											  (a = -a))
											: this.copy(t),
										a >= 1)
									)
										return (
											(this._w = o),
											(this._x = n),
											(this._y = i),
											(this._z = r),
											this
										);
									const s = 1 - a * a;
									if (s <= Number.EPSILON) {
										const t = 1 - e;
										return (
											(this._w = t * o + e * this._w),
											(this._x = t * n + e * this._x),
											(this._y = t * i + e * this._y),
											(this._z = t * r + e * this._z),
											this.normalize(),
											this._onChangeCallback(),
											this
										);
									}
									const c = Math.sqrt(s),
										l = Math.atan2(c, a),
										h = Math.sin((1 - e) * l) / c,
										p = Math.sin(e * l) / c;
									return (
										(this._w = o * h + this._w * p),
										(this._x = n * h + this._x * p),
										(this._y = i * h + this._y * p),
										(this._z = r * h + this._z * p),
										this._onChangeCallback(),
										this
									);
								},
								equals: function (t) {
									return (
										t._x === this._x &&
										t._y === this._y &&
										t._z === this._z &&
										t._w === this._w
									);
								},
								fromArray: function (t, e) {
									return (
										void 0 === e && (e = 0),
										(this._x = t[e]),
										(this._y = t[e + 1]),
										(this._z = t[e + 2]),
										(this._w = t[e + 3]),
										this._onChangeCallback(),
										this
									);
								},
								toArray: function (t, e) {
									return (
										void 0 === t && (t = []),
										void 0 === e && (e = 0),
										(t[e] = this._x),
										(t[e + 1] = this._y),
										(t[e + 2] = this._z),
										(t[e + 3] = this._w),
										t
									);
								},
								fromBufferAttribute: function (t, e) {
									return (
										(this._x = t.getX(e)),
										(this._y = t.getY(e)),
										(this._z = t.getZ(e)),
										(this._w = t.getW(e)),
										this
									);
								},
								_onChange: function (t) {
									return (this._onChangeCallback = t), this;
								},
								_onChangeCallback: function () {},
							});
						const Kr = new zr(),
							Tr = new br();
						function zr(t = 0, e = 0, n = 0) {
							(this.x = t), (this.y = e), (this.z = n);
						}
						Object.assign(zr.prototype, {
							isVector3: !0,
							set: function (t, e, n) {
								return (
									void 0 === n && (n = this.z),
									(this.x = t),
									(this.y = e),
									(this.z = n),
									this
								);
							},
							setScalar: function (t) {
								return (this.x = t), (this.y = t), (this.z = t), this;
							},
							setX: function (t) {
								return (this.x = t), this;
							},
							setY: function (t) {
								return (this.y = t), this;
							},
							setZ: function (t) {
								return (this.z = t), this;
							},
							setComponent: function (t, e) {
								switch (t) {
									case 0:
										this.x = e;
										break;
									case 1:
										this.y = e;
										break;
									case 2:
										this.z = e;
										break;
									default:
										throw new Error("index is out of range: " + t);
								}
								return this;
							},
							getComponent: function (t) {
								switch (t) {
									case 0:
										return this.x;
									case 1:
										return this.y;
									case 2:
										return this.z;
									default:
										throw new Error("index is out of range: " + t);
								}
							},
							clone: function () {
								return new this.constructor(this.x, this.y, this.z);
							},
							copy: function (t) {
								return (this.x = t.x), (this.y = t.y), (this.z = t.z), this;
							},
							add: function (t, e) {
								return void 0 !== e
									? (console.warn(
											"THREE.Vector3: .add() now only accepts one argument. Use .addVectors( a, b ) instead."
									  ),
									  this.addVectors(t, e))
									: ((this.x += t.x), (this.y += t.y), (this.z += t.z), this);
							},
							addScalar: function (t) {
								return (this.x += t), (this.y += t), (this.z += t), this;
							},
							addVectors: function (t, e) {
								return (
									(this.x = t.x + e.x),
									(this.y = t.y + e.y),
									(this.z = t.z + e.z),
									this
								);
							},
							addScaledVector: function (t, e) {
								return (
									(this.x += t.x * e),
									(this.y += t.y * e),
									(this.z += t.z * e),
									this
								);
							},
							sub: function (t, e) {
								return void 0 !== e
									? (console.warn(
											"THREE.Vector3: .sub() now only accepts one argument. Use .subVectors( a, b ) instead."
									  ),
									  this.subVectors(t, e))
									: ((this.x -= t.x), (this.y -= t.y), (this.z -= t.z), this);
							},
							subScalar: function (t) {
								return (this.x -= t), (this.y -= t), (this.z -= t), this;
							},
							subVectors: function (t, e) {
								return (
									(this.x = t.x - e.x),
									(this.y = t.y - e.y),
									(this.z = t.z - e.z),
									this
								);
							},
							multiply: function (t, e) {
								return void 0 !== e
									? (console.warn(
											"THREE.Vector3: .multiply() now only accepts one argument. Use .multiplyVectors( a, b ) instead."
									  ),
									  this.multiplyVectors(t, e))
									: ((this.x *= t.x), (this.y *= t.y), (this.z *= t.z), this);
							},
							multiplyScalar: function (t) {
								return (this.x *= t), (this.y *= t), (this.z *= t), this;
							},
							multiplyVectors: function (t, e) {
								return (
									(this.x = t.x * e.x),
									(this.y = t.y * e.y),
									(this.z = t.z * e.z),
									this
								);
							},
							applyEuler: function (t) {
								return (
									(t && t.isEuler) ||
										console.error(
											"THREE.Vector3: .applyEuler() now expects an Euler rotation rather than a Vector3 and order."
										),
									this.applyQuaternion(Tr.setFromEuler(t))
								);
							},
							applyAxisAngle: function (t, e) {
								return this.applyQuaternion(Tr.setFromAxisAngle(t, e));
							},
							applyMatrix3: function (t) {
								const e = this.x,
									n = this.y,
									i = this.z,
									r = t.elements;
								return (
									(this.x = r[0] * e + r[3] * n + r[6] * i),
									(this.y = r[1] * e + r[4] * n + r[7] * i),
									(this.z = r[2] * e + r[5] * n + r[8] * i),
									this
								);
							},
							applyNormalMatrix: function (t) {
								return this.applyMatrix3(t).normalize();
							},
							applyMatrix4: function (t) {
								const e = this.x,
									n = this.y,
									i = this.z,
									r = t.elements,
									o = 1 / (r[3] * e + r[7] * n + r[11] * i + r[15]);
								return (
									(this.x = (r[0] * e + r[4] * n + r[8] * i + r[12]) * o),
									(this.y = (r[1] * e + r[5] * n + r[9] * i + r[13]) * o),
									(this.z = (r[2] * e + r[6] * n + r[10] * i + r[14]) * o),
									this
								);
							},
							applyQuaternion: function (t) {
								const e = this.x,
									n = this.y,
									i = this.z,
									r = t.x,
									o = t.y,
									a = t.z,
									s = t.w,
									c = s * e + o * i - a * n,
									l = s * n + a * e - r * i,
									h = s * i + r * n - o * e,
									p = -r * e - o * n - a * i;
								return (
									(this.x = c * s + p * -r + l * -a - h * -o),
									(this.y = l * s + p * -o + h * -r - c * -a),
									(this.z = h * s + p * -a + c * -o - l * -r),
									this
								);
							},
							project: function (t) {
								return this.applyMatrix4(t.matrixWorldInverse).applyMatrix4(
									t.projectionMatrix
								);
							},
							unproject: function (t) {
								return this.applyMatrix4(
									t.projectionMatrixInverse
								).applyMatrix4(t.matrixWorld);
							},
							transformDirection: function (t) {
								const e = this.x,
									n = this.y,
									i = this.z,
									r = t.elements;
								return (
									(this.x = r[0] * e + r[4] * n + r[8] * i),
									(this.y = r[1] * e + r[5] * n + r[9] * i),
									(this.z = r[2] * e + r[6] * n + r[10] * i),
									this.normalize()
								);
							},
							divide: function (t) {
								return (this.x /= t.x), (this.y /= t.y), (this.z /= t.z), this;
							},
							divideScalar: function (t) {
								return this.multiplyScalar(1 / t);
							},
							min: function (t) {
								return (
									(this.x = Math.min(this.x, t.x)),
									(this.y = Math.min(this.y, t.y)),
									(this.z = Math.min(this.z, t.z)),
									this
								);
							},
							max: function (t) {
								return (
									(this.x = Math.max(this.x, t.x)),
									(this.y = Math.max(this.y, t.y)),
									(this.z = Math.max(this.z, t.z)),
									this
								);
							},
							clamp: function (t, e) {
								return (
									(this.x = Math.max(t.x, Math.min(e.x, this.x))),
									(this.y = Math.max(t.y, Math.min(e.y, this.y))),
									(this.z = Math.max(t.z, Math.min(e.z, this.z))),
									this
								);
							},
							clampScalar: function (t, e) {
								return (
									(this.x = Math.max(t, Math.min(e, this.x))),
									(this.y = Math.max(t, Math.min(e, this.y))),
									(this.z = Math.max(t, Math.min(e, this.z))),
									this
								);
							},
							clampLength: function (t, e) {
								const n = this.length();
								return this.divideScalar(n || 1).multiplyScalar(
									Math.max(t, Math.min(e, n))
								);
							},
							floor: function () {
								return (
									(this.x = Math.floor(this.x)),
									(this.y = Math.floor(this.y)),
									(this.z = Math.floor(this.z)),
									this
								);
							},
							ceil: function () {
								return (
									(this.x = Math.ceil(this.x)),
									(this.y = Math.ceil(this.y)),
									(this.z = Math.ceil(this.z)),
									this
								);
							},
							round: function () {
								return (
									(this.x = Math.round(this.x)),
									(this.y = Math.round(this.y)),
									(this.z = Math.round(this.z)),
									this
								);
							},
							roundToZero: function () {
								return (
									(this.x =
										this.x < 0 ? Math.ceil(this.x) : Math.floor(this.x)),
									(this.y =
										this.y < 0 ? Math.ceil(this.y) : Math.floor(this.y)),
									(this.z =
										this.z < 0 ? Math.ceil(this.z) : Math.floor(this.z)),
									this
								);
							},
							negate: function () {
								return (
									(this.x = -this.x),
									(this.y = -this.y),
									(this.z = -this.z),
									this
								);
							},
							dot: function (t) {
								return this.x * t.x + this.y * t.y + this.z * t.z;
							},
							lengthSq: function () {
								return this.x * this.x + this.y * this.y + this.z * this.z;
							},
							length: function () {
								return Math.sqrt(
									this.x * this.x + this.y * this.y + this.z * this.z
								);
							},
							manhattanLength: function () {
								return Math.abs(this.x) + Math.abs(this.y) + Math.abs(this.z);
							},
							normalize: function () {
								return this.divideScalar(this.length() || 1);
							},
							setLength: function (t) {
								return this.normalize().multiplyScalar(t);
							},
							lerp: function (t, e) {
								return (
									(this.x += (t.x - this.x) * e),
									(this.y += (t.y - this.y) * e),
									(this.z += (t.z - this.z) * e),
									this
								);
							},
							lerpVectors: function (t, e, n) {
								return (
									(this.x = t.x + (e.x - t.x) * n),
									(this.y = t.y + (e.y - t.y) * n),
									(this.z = t.z + (e.z - t.z) * n),
									this
								);
							},
							cross: function (t, e) {
								return void 0 !== e
									? (console.warn(
											"THREE.Vector3: .cross() now only accepts one argument. Use .crossVectors( a, b ) instead."
									  ),
									  this.crossVectors(t, e))
									: this.crossVectors(this, t);
							},
							crossVectors: function (t, e) {
								const n = t.x,
									i = t.y,
									r = t.z,
									o = e.x,
									a = e.y,
									s = e.z;
								return (
									(this.x = i * s - r * a),
									(this.y = r * o - n * s),
									(this.z = n * a - i * o),
									this
								);
							},
							projectOnVector: function (t) {
								const e = t.lengthSq();
								if (0 === e) return this.set(0, 0, 0);
								const n = t.dot(this) / e;
								return this.copy(t).multiplyScalar(n);
							},
							projectOnPlane: function (t) {
								return Kr.copy(this).projectOnVector(t), this.sub(Kr);
							},
							reflect: function (t) {
								return this.sub(Kr.copy(t).multiplyScalar(2 * this.dot(t)));
							},
							angleTo: function (t) {
								const e = Math.sqrt(this.lengthSq() * t.lengthSq());
								if (0 === e) return Math.PI / 2;
								const n = this.dot(t) / e;
								return Math.acos(qr.clamp(n, -1, 1));
							},
							distanceTo: function (t) {
								return Math.sqrt(this.distanceToSquared(t));
							},
							distanceToSquared: function (t) {
								const e = this.x - t.x,
									n = this.y - t.y,
									i = this.z - t.z;
								return e * e + n * n + i * i;
							},
							manhattanDistanceTo: function (t) {
								return (
									Math.abs(this.x - t.x) +
									Math.abs(this.y - t.y) +
									Math.abs(this.z - t.z)
								);
							},
							setFromSpherical: function (t) {
								return this.setFromSphericalCoords(t.radius, t.phi, t.theta);
							},
							setFromSphericalCoords: function (t, e, n) {
								const i = Math.sin(e) * t;
								return (
									(this.x = i * Math.sin(n)),
									(this.y = Math.cos(e) * t),
									(this.z = i * Math.cos(n)),
									this
								);
							},
							setFromCylindrical: function (t) {
								return this.setFromCylindricalCoords(t.radius, t.theta, t.y);
							},
							setFromCylindricalCoords: function (t, e, n) {
								return (
									(this.x = t * Math.sin(e)),
									(this.y = n),
									(this.z = t * Math.cos(e)),
									this
								);
							},
							setFromMatrixPosition: function (t) {
								const e = t.elements;
								return (
									(this.x = e[12]), (this.y = e[13]), (this.z = e[14]), this
								);
							},
							setFromMatrixScale: function (t) {
								const e = this.setFromMatrixColumn(t, 0).length(),
									n = this.setFromMatrixColumn(t, 1).length(),
									i = this.setFromMatrixColumn(t, 2).length();
								return (this.x = e), (this.y = n), (this.z = i), this;
							},
							setFromMatrixColumn: function (t, e) {
								return this.fromArray(t.elements, 4 * e);
							},
							setFromMatrix3Column: function (t, e) {
								return this.fromArray(t.elements, 3 * e);
							},
							equals: function (t) {
								return t.x === this.x && t.y === this.y && t.z === this.z;
							},
							fromArray: function (t, e) {
								return (
									void 0 === e && (e = 0),
									(this.x = t[e]),
									(this.y = t[e + 1]),
									(this.z = t[e + 2]),
									this
								);
							},
							toArray: function (t, e) {
								return (
									void 0 === t && (t = []),
									void 0 === e && (e = 0),
									(t[e] = this.x),
									(t[e + 1] = this.y),
									(t[e + 2] = this.z),
									t
								);
							},
							fromBufferAttribute: function (t, e, n) {
								return (
									void 0 !== n &&
										console.warn(
											"THREE.Vector3: offset has been removed from .fromBufferAttribute()."
										),
									(this.x = t.getX(e)),
									(this.y = t.getY(e)),
									(this.z = t.getZ(e)),
									this
								);
							},
							random: function () {
								return (
									(this.x = Math.random()),
									(this.y = Math.random()),
									(this.z = Math.random()),
									this
								);
							},
						});
						const Wr = new zr(),
							Er = new jr(),
							Cr = new zr(0, 0, 0),
							Fr = new zr(1, 1, 1),
							Zr = new zr(),
							Hr = new zr(),
							Nr = new zr();
						function jr() {
							(this.elements = [
								1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1,
							]),
								arguments.length > 0 &&
									console.error(
										"THREE.Matrix4: the constructor no longer reads arguments. use .set() instead."
									);
						}
						Object.assign(jr.prototype, {
							isMatrix4: !0,
							set: function (t, e, n, i, r, o, a, s, c, l, h, p, u, d, m, f) {
								const g = this.elements;
								return (
									(g[0] = t),
									(g[4] = e),
									(g[8] = n),
									(g[12] = i),
									(g[1] = r),
									(g[5] = o),
									(g[9] = a),
									(g[13] = s),
									(g[2] = c),
									(g[6] = l),
									(g[10] = h),
									(g[14] = p),
									(g[3] = u),
									(g[7] = d),
									(g[11] = m),
									(g[15] = f),
									this
								);
							},
							identity: function () {
								return (
									this.set(1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1), this
								);
							},
							clone: function () {
								return new jr().fromArray(this.elements);
							},
							copy: function (t) {
								const e = this.elements,
									n = t.elements;
								return (
									(e[0] = n[0]),
									(e[1] = n[1]),
									(e[2] = n[2]),
									(e[3] = n[3]),
									(e[4] = n[4]),
									(e[5] = n[5]),
									(e[6] = n[6]),
									(e[7] = n[7]),
									(e[8] = n[8]),
									(e[9] = n[9]),
									(e[10] = n[10]),
									(e[11] = n[11]),
									(e[12] = n[12]),
									(e[13] = n[13]),
									(e[14] = n[14]),
									(e[15] = n[15]),
									this
								);
							},
							copyPosition: function (t) {
								const e = this.elements,
									n = t.elements;
								return (e[12] = n[12]), (e[13] = n[13]), (e[14] = n[14]), this;
							},
							extractBasis: function (t, e, n) {
								return (
									t.setFromMatrixColumn(this, 0),
									e.setFromMatrixColumn(this, 1),
									n.setFromMatrixColumn(this, 2),
									this
								);
							},
							makeBasis: function (t, e, n) {
								return (
									this.set(
										t.x,
										e.x,
										n.x,
										0,
										t.y,
										e.y,
										n.y,
										0,
										t.z,
										e.z,
										n.z,
										0,
										0,
										0,
										0,
										1
									),
									this
								);
							},
							extractRotation: function (t) {
								const e = this.elements,
									n = t.elements,
									i = 1 / Wr.setFromMatrixColumn(t, 0).length(),
									r = 1 / Wr.setFromMatrixColumn(t, 1).length(),
									o = 1 / Wr.setFromMatrixColumn(t, 2).length();
								return (
									(e[0] = n[0] * i),
									(e[1] = n[1] * i),
									(e[2] = n[2] * i),
									(e[3] = 0),
									(e[4] = n[4] * r),
									(e[5] = n[5] * r),
									(e[6] = n[6] * r),
									(e[7] = 0),
									(e[8] = n[8] * o),
									(e[9] = n[9] * o),
									(e[10] = n[10] * o),
									(e[11] = 0),
									(e[12] = 0),
									(e[13] = 0),
									(e[14] = 0),
									(e[15] = 1),
									this
								);
							},
							makeRotationFromEuler: function (t) {
								(t && t.isEuler) ||
									console.error(
										"THREE.Matrix4: .makeRotationFromEuler() now expects a Euler rotation rather than a Vector3 and order."
									);
								const e = this.elements,
									n = t.x,
									i = t.y,
									r = t.z,
									o = Math.cos(n),
									a = Math.sin(n),
									s = Math.cos(i),
									c = Math.sin(i),
									l = Math.cos(r),
									h = Math.sin(r);
								if ("XYZ" === t.order) {
									const t = o * l,
										n = o * h,
										i = a * l,
										r = a * h;
									(e[0] = s * l),
										(e[4] = -s * h),
										(e[8] = c),
										(e[1] = n + i * c),
										(e[5] = t - r * c),
										(e[9] = -a * s),
										(e[2] = r - t * c),
										(e[6] = i + n * c),
										(e[10] = o * s);
								} else if ("YXZ" === t.order) {
									const t = s * l,
										n = s * h,
										i = c * l,
										r = c * h;
									(e[0] = t + r * a),
										(e[4] = i * a - n),
										(e[8] = o * c),
										(e[1] = o * h),
										(e[5] = o * l),
										(e[9] = -a),
										(e[2] = n * a - i),
										(e[6] = r + t * a),
										(e[10] = o * s);
								} else if ("ZXY" === t.order) {
									const t = s * l,
										n = s * h,
										i = c * l,
										r = c * h;
									(e[0] = t - r * a),
										(e[4] = -o * h),
										(e[8] = i + n * a),
										(e[1] = n + i * a),
										(e[5] = o * l),
										(e[9] = r - t * a),
										(e[2] = -o * c),
										(e[6] = a),
										(e[10] = o * s);
								} else if ("ZYX" === t.order) {
									const t = o * l,
										n = o * h,
										i = a * l,
										r = a * h;
									(e[0] = s * l),
										(e[4] = i * c - n),
										(e[8] = t * c + r),
										(e[1] = s * h),
										(e[5] = r * c + t),
										(e[9] = n * c - i),
										(e[2] = -c),
										(e[6] = a * s),
										(e[10] = o * s);
								} else if ("YZX" === t.order) {
									const t = o * s,
										n = o * c,
										i = a * s,
										r = a * c;
									(e[0] = s * l),
										(e[4] = r - t * h),
										(e[8] = i * h + n),
										(e[1] = h),
										(e[5] = o * l),
										(e[9] = -a * l),
										(e[2] = -c * l),
										(e[6] = n * h + i),
										(e[10] = t - r * h);
								} else if ("XZY" === t.order) {
									const t = o * s,
										n = o * c,
										i = a * s,
										r = a * c;
									(e[0] = s * l),
										(e[4] = -h),
										(e[8] = c * l),
										(e[1] = t * h + r),
										(e[5] = o * l),
										(e[9] = n * h - i),
										(e[2] = i * h - n),
										(e[6] = a * l),
										(e[10] = r * h + t);
								}
								return (
									(e[3] = 0),
									(e[7] = 0),
									(e[11] = 0),
									(e[12] = 0),
									(e[13] = 0),
									(e[14] = 0),
									(e[15] = 1),
									this
								);
							},
							makeRotationFromQuaternion: function (t) {
								return this.compose(Cr, t, Fr);
							},
							lookAt: function (t, e, n) {
								const i = this.elements;
								return (
									Nr.subVectors(t, e),
									0 === Nr.lengthSq() && (Nr.z = 1),
									Nr.normalize(),
									Zr.crossVectors(n, Nr),
									0 === Zr.lengthSq() &&
										(1 === Math.abs(n.z) ? (Nr.x += 1e-4) : (Nr.z += 1e-4),
										Nr.normalize(),
										Zr.crossVectors(n, Nr)),
									Zr.normalize(),
									Hr.crossVectors(Nr, Zr),
									(i[0] = Zr.x),
									(i[4] = Hr.x),
									(i[8] = Nr.x),
									(i[1] = Zr.y),
									(i[5] = Hr.y),
									(i[9] = Nr.y),
									(i[2] = Zr.z),
									(i[6] = Hr.z),
									(i[10] = Nr.z),
									this
								);
							},
							multiply: function (t, e) {
								return void 0 !== e
									? (console.warn(
											"THREE.Matrix4: .multiply() now only accepts one argument. Use .multiplyMatrices( a, b ) instead."
									  ),
									  this.multiplyMatrices(t, e))
									: this.multiplyMatrices(this, t);
							},
							premultiply: function (t) {
								return this.multiplyMatrices(t, this);
							},
							multiplyMatrices: function (t, e) {
								const n = t.elements,
									i = e.elements,
									r = this.elements,
									o = n[0],
									a = n[4],
									s = n[8],
									c = n[12],
									l = n[1],
									h = n[5],
									p = n[9],
									u = n[13],
									d = n[2],
									m = n[6],
									f = n[10],
									g = n[14],
									S = n[3],
									y = n[7],
									V = n[11],
									q = n[15],
									R = i[0],
									M = i[4],
									I = i[8],
									v = i[12],
									k = i[1],
									U = i[5],
									w = i[9],
									x = i[13],
									O = i[2],
									b = i[6],
									K = i[10],
									T = i[14],
									z = i[3],
									W = i[7],
									E = i[11],
									C = i[15];
								return (
									(r[0] = o * R + a * k + s * O + c * z),
									(r[4] = o * M + a * U + s * b + c * W),
									(r[8] = o * I + a * w + s * K + c * E),
									(r[12] = o * v + a * x + s * T + c * C),
									(r[1] = l * R + h * k + p * O + u * z),
									(r[5] = l * M + h * U + p * b + u * W),
									(r[9] = l * I + h * w + p * K + u * E),
									(r[13] = l * v + h * x + p * T + u * C),
									(r[2] = d * R + m * k + f * O + g * z),
									(r[6] = d * M + m * U + f * b + g * W),
									(r[10] = d * I + m * w + f * K + g * E),
									(r[14] = d * v + m * x + f * T + g * C),
									(r[3] = S * R + y * k + V * O + q * z),
									(r[7] = S * M + y * U + V * b + q * W),
									(r[11] = S * I + y * w + V * K + q * E),
									(r[15] = S * v + y * x + V * T + q * C),
									this
								);
							},
							multiplyScalar: function (t) {
								const e = this.elements;
								return (
									(e[0] *= t),
									(e[4] *= t),
									(e[8] *= t),
									(e[12] *= t),
									(e[1] *= t),
									(e[5] *= t),
									(e[9] *= t),
									(e[13] *= t),
									(e[2] *= t),
									(e[6] *= t),
									(e[10] *= t),
									(e[14] *= t),
									(e[3] *= t),
									(e[7] *= t),
									(e[11] *= t),
									(e[15] *= t),
									this
								);
							},
							determinant: function () {
								const t = this.elements,
									e = t[0],
									n = t[4],
									i = t[8],
									r = t[12],
									o = t[1],
									a = t[5],
									s = t[9],
									c = t[13],
									l = t[2],
									h = t[6],
									p = t[10],
									u = t[14];
								return (
									t[3] *
										(+r * s * h -
											i * c * h -
											r * a * p +
											n * c * p +
											i * a * u -
											n * s * u) +
									t[7] *
										(+e * s * u -
											e * c * p +
											r * o * p -
											i * o * u +
											i * c * l -
											r * s * l) +
									t[11] *
										(+e * c * h -
											e * a * u -
											r * o * h +
											n * o * u +
											r * a * l -
											n * c * l) +
									t[15] *
										(-i * a * l -
											e * s * h +
											e * a * p +
											i * o * h -
											n * o * p +
											n * s * l)
								);
							},
							transpose: function () {
								const t = this.elements;
								let e;
								return (
									(e = t[1]),
									(t[1] = t[4]),
									(t[4] = e),
									(e = t[2]),
									(t[2] = t[8]),
									(t[8] = e),
									(e = t[6]),
									(t[6] = t[9]),
									(t[9] = e),
									(e = t[3]),
									(t[3] = t[12]),
									(t[12] = e),
									(e = t[7]),
									(t[7] = t[13]),
									(t[13] = e),
									(e = t[11]),
									(t[11] = t[14]),
									(t[14] = e),
									this
								);
							},
							setPosition: function (t, e, n) {
								const i = this.elements;
								return (
									t.isVector3
										? ((i[12] = t.x), (i[13] = t.y), (i[14] = t.z))
										: ((i[12] = t), (i[13] = e), (i[14] = n)),
									this
								);
							},
							getInverse: function (t, e) {
								void 0 !== e &&
									console.warn(
										"THREE.Matrix4: .getInverse() can no longer be configured to throw on degenerate."
									);
								const n = this.elements,
									i = t.elements,
									r = i[0],
									o = i[1],
									a = i[2],
									s = i[3],
									c = i[4],
									l = i[5],
									h = i[6],
									p = i[7],
									u = i[8],
									d = i[9],
									m = i[10],
									f = i[11],
									g = i[12],
									S = i[13],
									y = i[14],
									V = i[15],
									q =
										d * y * p -
										S * m * p +
										S * h * f -
										l * y * f -
										d * h * V +
										l * m * V,
									R =
										g * m * p -
										u * y * p -
										g * h * f +
										c * y * f +
										u * h * V -
										c * m * V,
									M =
										u * S * p -
										g * d * p +
										g * l * f -
										c * S * f -
										u * l * V +
										c * d * V,
									I =
										g * d * h -
										u * S * h -
										g * l * m +
										c * S * m +
										u * l * y -
										c * d * y,
									v = r * q + o * R + a * M + s * I;
								if (0 === v)
									return this.set(
										0,
										0,
										0,
										0,
										0,
										0,
										0,
										0,
										0,
										0,
										0,
										0,
										0,
										0,
										0,
										0
									);
								const k = 1 / v;
								return (
									(n[0] = q * k),
									(n[1] =
										(S * m * s -
											d * y * s -
											S * a * f +
											o * y * f +
											d * a * V -
											o * m * V) *
										k),
									(n[2] =
										(l * y * s -
											S * h * s +
											S * a * p -
											o * y * p -
											l * a * V +
											o * h * V) *
										k),
									(n[3] =
										(d * h * s -
											l * m * s -
											d * a * p +
											o * m * p +
											l * a * f -
											o * h * f) *
										k),
									(n[4] = R * k),
									(n[5] =
										(u * y * s -
											g * m * s +
											g * a * f -
											r * y * f -
											u * a * V +
											r * m * V) *
										k),
									(n[6] =
										(g * h * s -
											c * y * s -
											g * a * p +
											r * y * p +
											c * a * V -
											r * h * V) *
										k),
									(n[7] =
										(c * m * s -
											u * h * s +
											u * a * p -
											r * m * p -
											c * a * f +
											r * h * f) *
										k),
									(n[8] = M * k),
									(n[9] =
										(g * d * s -
											u * S * s -
											g * o * f +
											r * S * f +
											u * o * V -
											r * d * V) *
										k),
									(n[10] =
										(c * S * s -
											g * l * s +
											g * o * p -
											r * S * p -
											c * o * V +
											r * l * V) *
										k),
									(n[11] =
										(u * l * s -
											c * d * s -
											u * o * p +
											r * d * p +
											c * o * f -
											r * l * f) *
										k),
									(n[12] = I * k),
									(n[13] =
										(u * S * a -
											g * d * a +
											g * o * m -
											r * S * m -
											u * o * y +
											r * d * y) *
										k),
									(n[14] =
										(g * l * a -
											c * S * a -
											g * o * h +
											r * S * h +
											c * o * y -
											r * l * y) *
										k),
									(n[15] =
										(c * d * a -
											u * l * a +
											u * o * h -
											r * d * h -
											c * o * m +
											r * l * m) *
										k),
									this
								);
							},
							scale: function (t) {
								const e = this.elements,
									n = t.x,
									i = t.y,
									r = t.z;
								return (
									(e[0] *= n),
									(e[4] *= i),
									(e[8] *= r),
									(e[1] *= n),
									(e[5] *= i),
									(e[9] *= r),
									(e[2] *= n),
									(e[6] *= i),
									(e[10] *= r),
									(e[3] *= n),
									(e[7] *= i),
									(e[11] *= r),
									this
								);
							},
							getMaxScaleOnAxis: function () {
								const t = this.elements,
									e = t[0] * t[0] + t[1] * t[1] + t[2] * t[2],
									n = t[4] * t[4] + t[5] * t[5] + t[6] * t[6],
									i = t[8] * t[8] + t[9] * t[9] + t[10] * t[10];
								return Math.sqrt(Math.max(e, n, i));
							},
							makeTranslation: function (t, e, n) {
								return (
									this.set(1, 0, 0, t, 0, 1, 0, e, 0, 0, 1, n, 0, 0, 0, 1), this
								);
							},
							makeRotationX: function (t) {
								const e = Math.cos(t),
									n = Math.sin(t);
								return (
									this.set(1, 0, 0, 0, 0, e, -n, 0, 0, n, e, 0, 0, 0, 0, 1),
									this
								);
							},
							makeRotationY: function (t) {
								const e = Math.cos(t),
									n = Math.sin(t);
								return (
									this.set(e, 0, n, 0, 0, 1, 0, 0, -n, 0, e, 0, 0, 0, 0, 1),
									this
								);
							},
							makeRotationZ: function (t) {
								const e = Math.cos(t),
									n = Math.sin(t);
								return (
									this.set(e, -n, 0, 0, n, e, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1),
									this
								);
							},
							makeRotationAxis: function (t, e) {
								const n = Math.cos(e),
									i = Math.sin(e),
									r = 1 - n,
									o = t.x,
									a = t.y,
									s = t.z,
									c = r * o,
									l = r * a;
								return (
									this.set(
										c * o + n,
										c * a - i * s,
										c * s + i * a,
										0,
										c * a + i * s,
										l * a + n,
										l * s - i * o,
										0,
										c * s - i * a,
										l * s + i * o,
										r * s * s + n,
										0,
										0,
										0,
										0,
										1
									),
									this
								);
							},
							makeScale: function (t, e, n) {
								return (
									this.set(t, 0, 0, 0, 0, e, 0, 0, 0, 0, n, 0, 0, 0, 0, 1), this
								);
							},
							makeShear: function (t, e, n) {
								return (
									this.set(1, e, n, 0, t, 1, n, 0, t, e, 1, 0, 0, 0, 0, 1), this
								);
							},
							compose: function (t, e, n) {
								const i = this.elements,
									r = e._x,
									o = e._y,
									a = e._z,
									s = e._w,
									c = r + r,
									l = o + o,
									h = a + a,
									p = r * c,
									u = r * l,
									d = r * h,
									m = o * l,
									f = o * h,
									g = a * h,
									S = s * c,
									y = s * l,
									V = s * h,
									q = n.x,
									R = n.y,
									M = n.z;
								return (
									(i[0] = (1 - (m + g)) * q),
									(i[1] = (u + V) * q),
									(i[2] = (d - y) * q),
									(i[3] = 0),
									(i[4] = (u - V) * R),
									(i[5] = (1 - (p + g)) * R),
									(i[6] = (f + S) * R),
									(i[7] = 0),
									(i[8] = (d + y) * M),
									(i[9] = (f - S) * M),
									(i[10] = (1 - (p + m)) * M),
									(i[11] = 0),
									(i[12] = t.x),
									(i[13] = t.y),
									(i[14] = t.z),
									(i[15] = 1),
									this
								);
							},
							decompose: function (t, e, n) {
								const i = this.elements;
								let r = Wr.set(i[0], i[1], i[2]).length(),
									o = Wr.set(i[4], i[5], i[6]).length(),
									a = Wr.set(i[8], i[9], i[10]).length();
								this.determinant() < 0 && (r = -r),
									(t.x = i[12]),
									(t.y = i[13]),
									(t.z = i[14]),
									Er.copy(this);
								const s = 1 / r,
									c = 1 / o,
									l = 1 / a;
								return (
									(Er.elements[0] *= s),
									(Er.elements[1] *= s),
									(Er.elements[2] *= s),
									(Er.elements[4] *= c),
									(Er.elements[5] *= c),
									(Er.elements[6] *= c),
									(Er.elements[8] *= l),
									(Er.elements[9] *= l),
									(Er.elements[10] *= l),
									e.setFromRotationMatrix(Er),
									(n.x = r),
									(n.y = o),
									(n.z = a),
									this
								);
							},
							makePerspective: function (t, e, n, i, r, o) {
								void 0 === o &&
									console.warn(
										"THREE.Matrix4: .makePerspective() has been redefined and has a new signature. Please check the docs."
									);
								const a = this.elements,
									s = (2 * r) / (e - t),
									c = (2 * r) / (n - i),
									l = (e + t) / (e - t),
									h = (n + i) / (n - i),
									p = -(o + r) / (o - r),
									u = (-2 * o * r) / (o - r);
								return (
									(a[0] = s),
									(a[4] = 0),
									(a[8] = l),
									(a[12] = 0),
									(a[1] = 0),
									(a[5] = c),
									(a[9] = h),
									(a[13] = 0),
									(a[2] = 0),
									(a[6] = 0),
									(a[10] = p),
									(a[14] = u),
									(a[3] = 0),
									(a[7] = 0),
									(a[11] = -1),
									(a[15] = 0),
									this
								);
							},
							makeOrthographic: function (t, e, n, i, r, o) {
								const a = this.elements,
									s = 1 / (e - t),
									c = 1 / (n - i),
									l = 1 / (o - r),
									h = (e + t) * s,
									p = (n + i) * c,
									u = (o + r) * l;
								return (
									(a[0] = 2 * s),
									(a[4] = 0),
									(a[8] = 0),
									(a[12] = -h),
									(a[1] = 0),
									(a[5] = 2 * c),
									(a[9] = 0),
									(a[13] = -p),
									(a[2] = 0),
									(a[6] = 0),
									(a[10] = -2 * l),
									(a[14] = -u),
									(a[3] = 0),
									(a[7] = 0),
									(a[11] = 0),
									(a[15] = 1),
									this
								);
							},
							equals: function (t) {
								const e = this.elements,
									n = t.elements;
								for (let t = 0; t < 16; t++) if (e[t] !== n[t]) return !1;
								return !0;
							},
							fromArray: function (t, e) {
								void 0 === e && (e = 0);
								for (let n = 0; n < 16; n++) this.elements[n] = t[n + e];
								return this;
							},
							toArray: function (t, e) {
								void 0 === t && (t = []), void 0 === e && (e = 0);
								const n = this.elements;
								return (
									(t[e] = n[0]),
									(t[e + 1] = n[1]),
									(t[e + 2] = n[2]),
									(t[e + 3] = n[3]),
									(t[e + 4] = n[4]),
									(t[e + 5] = n[5]),
									(t[e + 6] = n[6]),
									(t[e + 7] = n[7]),
									(t[e + 8] = n[8]),
									(t[e + 9] = n[9]),
									(t[e + 10] = n[10]),
									(t[e + 11] = n[11]),
									(t[e + 12] = n[12]),
									(t[e + 13] = n[13]),
									(t[e + 14] = n[14]),
									(t[e + 15] = n[15]),
									t
								);
							},
						});
						const Dr = new jr(),
							Ar = new br();
						function Lr(t = 0, e = 0, n = 0, i = Lr.DefaultOrder) {
							(this._x = t), (this._y = e), (this._z = n), (this._order = i);
						}
						function Br() {
							this.mask = 1;
						}
						(Lr.RotationOrders = ["XYZ", "YZX", "ZXY", "XZY", "YXZ", "ZYX"]),
							(Lr.DefaultOrder = "XYZ"),
							Object.defineProperties(Lr.prototype, {
								x: {
									get: function () {
										return this._x;
									},
									set: function (t) {
										(this._x = t), this._onChangeCallback();
									},
								},
								y: {
									get: function () {
										return this._y;
									},
									set: function (t) {
										(this._y = t), this._onChangeCallback();
									},
								},
								z: {
									get: function () {
										return this._z;
									},
									set: function (t) {
										(this._z = t), this._onChangeCallback();
									},
								},
								order: {
									get: function () {
										return this._order;
									},
									set: function (t) {
										(this._order = t), this._onChangeCallback();
									},
								},
							}),
							Object.assign(Lr.prototype, {
								isEuler: !0,
								set: function (t, e, n, i) {
									return (
										(this._x = t),
										(this._y = e),
										(this._z = n),
										(this._order = i || this._order),
										this._onChangeCallback(),
										this
									);
								},
								clone: function () {
									return new this.constructor(
										this._x,
										this._y,
										this._z,
										this._order
									);
								},
								copy: function (t) {
									return (
										(this._x = t._x),
										(this._y = t._y),
										(this._z = t._z),
										(this._order = t._order),
										this._onChangeCallback(),
										this
									);
								},
								setFromRotationMatrix: function (t, e, n) {
									const i = qr.clamp,
										r = t.elements,
										o = r[0],
										a = r[4],
										s = r[8],
										c = r[1],
										l = r[5],
										h = r[9],
										p = r[2],
										u = r[6],
										d = r[10];
									switch ((e = e || this._order)) {
										case "XYZ":
											(this._y = Math.asin(i(s, -1, 1))),
												Math.abs(s) < 0.9999999
													? ((this._x = Math.atan2(-h, d)),
													  (this._z = Math.atan2(-a, o)))
													: ((this._x = Math.atan2(u, l)), (this._z = 0));
											break;
										case "YXZ":
											(this._x = Math.asin(-i(h, -1, 1))),
												Math.abs(h) < 0.9999999
													? ((this._y = Math.atan2(s, d)),
													  (this._z = Math.atan2(c, l)))
													: ((this._y = Math.atan2(-p, o)), (this._z = 0));
											break;
										case "ZXY":
											(this._x = Math.asin(i(u, -1, 1))),
												Math.abs(u) < 0.9999999
													? ((this._y = Math.atan2(-p, d)),
													  (this._z = Math.atan2(-a, l)))
													: ((this._y = 0), (this._z = Math.atan2(c, o)));
											break;
										case "ZYX":
											(this._y = Math.asin(-i(p, -1, 1))),
												Math.abs(p) < 0.9999999
													? ((this._x = Math.atan2(u, d)),
													  (this._z = Math.atan2(c, o)))
													: ((this._x = 0), (this._z = Math.atan2(-a, l)));
											break;
										case "YZX":
											(this._z = Math.asin(i(c, -1, 1))),
												Math.abs(c) < 0.9999999
													? ((this._x = Math.atan2(-h, l)),
													  (this._y = Math.atan2(-p, o)))
													: ((this._x = 0), (this._y = Math.atan2(s, d)));
											break;
										case "XZY":
											(this._z = Math.asin(-i(a, -1, 1))),
												Math.abs(a) < 0.9999999
													? ((this._x = Math.atan2(u, l)),
													  (this._y = Math.atan2(s, o)))
													: ((this._x = Math.atan2(-h, d)), (this._y = 0));
											break;
										default:
											console.warn(
												"THREE.Euler: .setFromRotationMatrix() encountered an unknown order: " +
													e
											);
									}
									return (
										(this._order = e),
										!1 !== n && this._onChangeCallback(),
										this
									);
								},
								setFromQuaternion: function (t, e, n) {
									return (
										Dr.makeRotationFromQuaternion(t),
										this.setFromRotationMatrix(Dr, e, n)
									);
								},
								setFromVector3: function (t, e) {
									return this.set(t.x, t.y, t.z, e || this._order);
								},
								reorder: function (t) {
									return Ar.setFromEuler(this), this.setFromQuaternion(Ar, t);
								},
								equals: function (t) {
									return (
										t._x === this._x &&
										t._y === this._y &&
										t._z === this._z &&
										t._order === this._order
									);
								},
								fromArray: function (t) {
									return (
										(this._x = t[0]),
										(this._y = t[1]),
										(this._z = t[2]),
										void 0 !== t[3] && (this._order = t[3]),
										this._onChangeCallback(),
										this
									);
								},
								toArray: function (t, e) {
									return (
										void 0 === t && (t = []),
										void 0 === e && (e = 0),
										(t[e] = this._x),
										(t[e + 1] = this._y),
										(t[e + 2] = this._z),
										(t[e + 3] = this._order),
										t
									);
								},
								toVector3: function (t) {
									return t
										? t.set(this._x, this._y, this._z)
										: new zr(this._x, this._y, this._z);
								},
								_onChange: function (t) {
									return (this._onChangeCallback = t), this;
								},
								_onChangeCallback: function () {},
							}),
							Object.assign(Br.prototype, {
								set: function (t) {
									this.mask = (1 << t) | 0;
								},
								enable: function (t) {
									this.mask |= (1 << t) | 0;
								},
								enableAll: function () {
									this.mask = -1;
								},
								toggle: function (t) {
									this.mask ^= (1 << t) | 0;
								},
								disable: function (t) {
									this.mask &= ~((1 << t) | 0);
								},
								disableAll: function () {
									this.mask = 0;
								},
								test: function (t) {
									return 0 != (this.mask & t.mask);
								},
							});
						let Gr = 0;
						const Qr = new zr(),
							_r = new br(),
							Pr = new jr(),
							Jr = new zr(),
							Yr = new zr(),
							Xr = new zr(),
							$r = new br(),
							to = new zr(1, 0, 0),
							eo = new zr(0, 1, 0),
							no = new zr(0, 0, 1),
							io = { type: "added" },
							ro = { type: "removed" };
						function oo() {
							Object.defineProperty(this, "id", { value: Gr++ }),
								(this.uuid = qr.generateUUID()),
								(this.name = ""),
								(this.type = "Object3D"),
								(this.parent = null),
								(this.children = []),
								(this.up = oo.DefaultUp.clone());
							const t = new zr(),
								e = new Lr(),
								n = new br(),
								i = new zr(1, 1, 1);
							e._onChange(function () {
								n.setFromEuler(e, !1);
							}),
								n._onChange(function () {
									e.setFromQuaternion(n, void 0, !1);
								}),
								Object.defineProperties(this, {
									position: { configurable: !0, enumerable: !0, value: t },
									rotation: { configurable: !0, enumerable: !0, value: e },
									quaternion: { configurable: !0, enumerable: !0, value: n },
									scale: { configurable: !0, enumerable: !0, value: i },
									modelViewMatrix: { value: new jr() },
									normalMatrix: { value: new Mr() },
								}),
								(this.matrix = new jr()),
								(this.matrixWorld = new jr()),
								(this.matrixAutoUpdate = oo.DefaultMatrixAutoUpdate),
								(this.matrixWorldNeedsUpdate = !1),
								(this.layers = new Br()),
								(this.visible = !0),
								(this.castShadow = !1),
								(this.receiveShadow = !1),
								(this.frustumCulled = !0),
								(this.renderOrder = 0),
								(this.userData = {});
						}
						function ao() {
							oo.call(this),
								(this.type = "Scene"),
								(this.background = null),
								(this.environment = null),
								(this.fog = null),
								(this.overrideMaterial = null),
								(this.autoUpdate = !0),
								"undefined" != typeof __THREE_DEVTOOLS__ &&
									__THREE_DEVTOOLS__.dispatchEvent(
										new CustomEvent("observe", { detail: this })
									);
						}
						(oo.DefaultUp = new zr(0, 1, 0)),
							(oo.DefaultMatrixAutoUpdate = !0),
							(oo.prototype = Object.assign(Object.create(Sr.prototype), {
								constructor: oo,
								isObject3D: !0,
								onBeforeRender: function () {},
								onAfterRender: function () {},
								applyMatrix4: function (t) {
									this.matrixAutoUpdate && this.updateMatrix(),
										this.matrix.premultiply(t),
										this.matrix.decompose(
											this.position,
											this.quaternion,
											this.scale
										);
								},
								applyQuaternion: function (t) {
									return this.quaternion.premultiply(t), this;
								},
								setRotationFromAxisAngle: function (t, e) {
									this.quaternion.setFromAxisAngle(t, e);
								},
								setRotationFromEuler: function (t) {
									this.quaternion.setFromEuler(t, !0);
								},
								setRotationFromMatrix: function (t) {
									this.quaternion.setFromRotationMatrix(t);
								},
								setRotationFromQuaternion: function (t) {
									this.quaternion.copy(t);
								},
								rotateOnAxis: function (t, e) {
									return (
										_r.setFromAxisAngle(t, e),
										this.quaternion.multiply(_r),
										this
									);
								},
								rotateOnWorldAxis: function (t, e) {
									return (
										_r.setFromAxisAngle(t, e),
										this.quaternion.premultiply(_r),
										this
									);
								},
								rotateX: function (t) {
									return this.rotateOnAxis(to, t);
								},
								rotateY: function (t) {
									return this.rotateOnAxis(eo, t);
								},
								rotateZ: function (t) {
									return this.rotateOnAxis(no, t);
								},
								translateOnAxis: function (t, e) {
									return (
										Qr.copy(t).applyQuaternion(this.quaternion),
										this.position.add(Qr.multiplyScalar(e)),
										this
									);
								},
								translateX: function (t) {
									return this.translateOnAxis(to, t);
								},
								translateY: function (t) {
									return this.translateOnAxis(eo, t);
								},
								translateZ: function (t) {
									return this.translateOnAxis(no, t);
								},
								localToWorld: function (t) {
									return t.applyMatrix4(this.matrixWorld);
								},
								worldToLocal: function (t) {
									return t.applyMatrix4(Pr.getInverse(this.matrixWorld));
								},
								lookAt: function (t, e, n) {
									t.isVector3 ? Jr.copy(t) : Jr.set(t, e, n);
									const i = this.parent;
									this.updateWorldMatrix(!0, !1),
										Yr.setFromMatrixPosition(this.matrixWorld),
										this.isCamera || this.isLight
											? Pr.lookAt(Yr, Jr, this.up)
											: Pr.lookAt(Jr, Yr, this.up),
										this.quaternion.setFromRotationMatrix(Pr),
										i &&
											(Pr.extractRotation(i.matrixWorld),
											_r.setFromRotationMatrix(Pr),
											this.quaternion.premultiply(_r.inverse()));
								},
								add: function (t) {
									if (arguments.length > 1) {
										for (let t = 0; t < arguments.length; t++)
											this.add(arguments[t]);
										return this;
									}
									return t === this
										? (console.error(
												"THREE.Object3D.add: object can't be added as a child of itself.",
												t
										  ),
										  this)
										: (t && t.isObject3D
												? (null !== t.parent && t.parent.remove(t),
												  (t.parent = this),
												  this.children.push(t),
												  t.dispatchEvent(io))
												: console.error(
														"THREE.Object3D.add: object not an instance of THREE.Object3D.",
														t
												  ),
										  this);
								},
								remove: function (t) {
									if (arguments.length > 1) {
										for (let t = 0; t < arguments.length; t++)
											this.remove(arguments[t]);
										return this;
									}
									const e = this.children.indexOf(t);
									return (
										-1 !== e &&
											((t.parent = null),
											this.children.splice(e, 1),
											t.dispatchEvent(ro)),
										this
									);
								},
								attach: function (t) {
									return (
										this.updateWorldMatrix(!0, !1),
										Pr.getInverse(this.matrixWorld),
										null !== t.parent &&
											(t.parent.updateWorldMatrix(!0, !1),
											Pr.multiply(t.parent.matrixWorld)),
										t.applyMatrix4(Pr),
										t.updateWorldMatrix(!1, !1),
										this.add(t),
										this
									);
								},
								getObjectById: function (t) {
									return this.getObjectByProperty("id", t);
								},
								getObjectByName: function (t) {
									return this.getObjectByProperty("name", t);
								},
								getObjectByProperty: function (t, e) {
									if (this[t] === e) return this;
									for (let n = 0, i = this.children.length; n < i; n++) {
										const i = this.children[n].getObjectByProperty(t, e);
										if (void 0 !== i) return i;
									}
								},
								getWorldPosition: function (t) {
									return (
										void 0 === t &&
											(console.warn(
												"THREE.Object3D: .getWorldPosition() target is now required"
											),
											(t = new zr())),
										this.updateMatrixWorld(!0),
										t.setFromMatrixPosition(this.matrixWorld)
									);
								},
								getWorldQuaternion: function (t) {
									return (
										void 0 === t &&
											(console.warn(
												"THREE.Object3D: .getWorldQuaternion() target is now required"
											),
											(t = new br())),
										this.updateMatrixWorld(!0),
										this.matrixWorld.decompose(Yr, t, Xr),
										t
									);
								},
								getWorldScale: function (t) {
									return (
										void 0 === t &&
											(console.warn(
												"THREE.Object3D: .getWorldScale() target is now required"
											),
											(t = new zr())),
										this.updateMatrixWorld(!0),
										this.matrixWorld.decompose(Yr, $r, t),
										t
									);
								},
								getWorldDirection: function (t) {
									void 0 === t &&
										(console.warn(
											"THREE.Object3D: .getWorldDirection() target is now required"
										),
										(t = new zr())),
										this.updateMatrixWorld(!0);
									const e = this.matrixWorld.elements;
									return t.set(e[8], e[9], e[10]).normalize();
								},
								raycast: function () {},
								traverse: function (t) {
									t(this);
									const e = this.children;
									for (let n = 0, i = e.length; n < i; n++) e[n].traverse(t);
								},
								traverseVisible: function (t) {
									if (!1 === this.visible) return;
									t(this);
									const e = this.children;
									for (let n = 0, i = e.length; n < i; n++)
										e[n].traverseVisible(t);
								},
								traverseAncestors: function (t) {
									const e = this.parent;
									null !== e && (t(e), e.traverseAncestors(t));
								},
								updateMatrix: function () {
									this.matrix.compose(
										this.position,
										this.quaternion,
										this.scale
									),
										(this.matrixWorldNeedsUpdate = !0);
								},
								updateMatrixWorld: function (t) {
									this.matrixAutoUpdate && this.updateMatrix(),
										(this.matrixWorldNeedsUpdate || t) &&
											(null === this.parent
												? this.matrixWorld.copy(this.matrix)
												: this.matrixWorld.multiplyMatrices(
														this.parent.matrixWorld,
														this.matrix
												  ),
											(this.matrixWorldNeedsUpdate = !1),
											(t = !0));
									const e = this.children;
									for (let n = 0, i = e.length; n < i; n++)
										e[n].updateMatrixWorld(t);
								},
								updateWorldMatrix: function (t, e) {
									const n = this.parent;
									if (
										(!0 === t && null !== n && n.updateWorldMatrix(!0, !1),
										this.matrixAutoUpdate && this.updateMatrix(),
										null === this.parent
											? this.matrixWorld.copy(this.matrix)
											: this.matrixWorld.multiplyMatrices(
													this.parent.matrixWorld,
													this.matrix
											  ),
										!0 === e)
									) {
										const t = this.children;
										for (let e = 0, n = t.length; e < n; e++)
											t[e].updateWorldMatrix(!1, !0);
									}
								},
								toJSON: function (t) {
									const e = void 0 === t || "string" == typeof t,
										n = {};
									e &&
										((t = {
											geometries: {},
											materials: {},
											textures: {},
											images: {},
											shapes: {},
										}),
										(n.metadata = {
											version: 4.5,
											type: "Object",
											generator: "Object3D.toJSON",
										}));
									const i = {};
									function r(e, n) {
										return (
											void 0 === e[n.uuid] && (e[n.uuid] = n.toJSON(t)), n.uuid
										);
									}
									if (
										((i.uuid = this.uuid),
										(i.type = this.type),
										"" !== this.name && (i.name = this.name),
										!0 === this.castShadow && (i.castShadow = !0),
										!0 === this.receiveShadow && (i.receiveShadow = !0),
										!1 === this.visible && (i.visible = !1),
										!1 === this.frustumCulled && (i.frustumCulled = !1),
										0 !== this.renderOrder &&
											(i.renderOrder = this.renderOrder),
										"{}" !== JSON.stringify(this.userData) &&
											(i.userData = this.userData),
										(i.layers = this.layers.mask),
										(i.matrix = this.matrix.toArray()),
										!1 === this.matrixAutoUpdate && (i.matrixAutoUpdate = !1),
										this.isInstancedMesh &&
											((i.type = "InstancedMesh"),
											(i.count = this.count),
											(i.instanceMatrix = this.instanceMatrix.toJSON())),
										this.isMesh || this.isLine || this.isPoints)
									) {
										i.geometry = r(t.geometries, this.geometry);
										const e = this.geometry.parameters;
										if (void 0 !== e && void 0 !== e.shapes) {
											const n = e.shapes;
											if (Array.isArray(n))
												for (let e = 0, i = n.length; e < i; e++) {
													const i = n[e];
													r(t.shapes, i);
												}
											else r(t.shapes, n);
										}
									}
									if (void 0 !== this.material)
										if (Array.isArray(this.material)) {
											const e = [];
											for (let n = 0, i = this.material.length; n < i; n++)
												e.push(r(t.materials, this.material[n]));
											i.material = e;
										} else i.material = r(t.materials, this.material);
									if (this.children.length > 0) {
										i.children = [];
										for (let e = 0; e < this.children.length; e++)
											i.children.push(this.children[e].toJSON(t).object);
									}
									if (e) {
										const e = o(t.geometries),
											i = o(t.materials),
											r = o(t.textures),
											a = o(t.images),
											s = o(t.shapes);
										e.length > 0 && (n.geometries = e),
											i.length > 0 && (n.materials = i),
											r.length > 0 && (n.textures = r),
											a.length > 0 && (n.images = a),
											s.length > 0 && (n.shapes = s);
									}
									return (n.object = i), n;
									function o(t) {
										const e = [];
										for (const n in t) {
											const i = t[n];
											delete i.metadata, e.push(i);
										}
										return e;
									}
								},
								clone: function (t) {
									return new this.constructor().copy(this, t);
								},
								copy: function (t, e) {
									if (
										(void 0 === e && (e = !0),
										(this.name = t.name),
										this.up.copy(t.up),
										this.position.copy(t.position),
										(this.rotation.order = t.rotation.order),
										this.quaternion.copy(t.quaternion),
										this.scale.copy(t.scale),
										this.matrix.copy(t.matrix),
										this.matrixWorld.copy(t.matrixWorld),
										(this.matrixAutoUpdate = t.matrixAutoUpdate),
										(this.matrixWorldNeedsUpdate = t.matrixWorldNeedsUpdate),
										(this.layers.mask = t.layers.mask),
										(this.visible = t.visible),
										(this.castShadow = t.castShadow),
										(this.receiveShadow = t.receiveShadow),
										(this.frustumCulled = t.frustumCulled),
										(this.renderOrder = t.renderOrder),
										(this.userData = JSON.parse(JSON.stringify(t.userData))),
										!0 === e)
									)
										for (let e = 0; e < t.children.length; e++) {
											const n = t.children[e];
											this.add(n.clone());
										}
									return this;
								},
							})),
							(ao.prototype = Object.assign(Object.create(oo.prototype), {
								constructor: ao,
								isScene: !0,
								copy: function (t, e) {
									return (
										oo.prototype.copy.call(this, t, e),
										null !== t.background &&
											(this.background = t.background.clone()),
										null !== t.environment &&
											(this.environment = t.environment.clone()),
										null !== t.fog && (this.fog = t.fog.clone()),
										null !== t.overrideMaterial &&
											(this.overrideMaterial = t.overrideMaterial.clone()),
										(this.autoUpdate = t.autoUpdate),
										(this.matrixAutoUpdate = t.matrixAutoUpdate),
										this
									);
								},
								toJSON: function (t) {
									const e = oo.prototype.toJSON.call(this, t);
									return (
										null !== this.background &&
											(e.object.background = this.background.toJSON(t)),
										null !== this.environment &&
											(e.object.environment = this.environment.toJSON(t)),
										null !== this.fog && (e.object.fog = this.fog.toJSON()),
										e
									);
								},
								dispose: function () {
									this.dispatchEvent({ type: "dispose" });
								},
							}));
						const so = [
								new zr(),
								new zr(),
								new zr(),
								new zr(),
								new zr(),
								new zr(),
								new zr(),
								new zr(),
							],
							co = new zr(),
							lo = new Ro(),
							ho = new zr(),
							po = new zr(),
							uo = new zr(),
							mo = new zr(),
							fo = new zr(),
							go = new zr(),
							So = new zr(),
							yo = new zr(),
							Vo = new zr(),
							qo = new zr();
						function Ro(t, e) {
							(this.min = void 0 !== t ? t : new zr(1 / 0, 1 / 0, 1 / 0)),
								(this.max = void 0 !== e ? e : new zr(-1 / 0, -1 / 0, -1 / 0));
						}
						function Mo(t, e, n, i, r) {
							for (let o = 0, a = t.length - 3; o <= a; o += 3) {
								qo.fromArray(t, o);
								const a =
										r.x * Math.abs(qo.x) +
										r.y * Math.abs(qo.y) +
										r.z * Math.abs(qo.z),
									s = e.dot(qo),
									c = n.dot(qo),
									l = i.dot(qo);
								if (Math.max(-Math.max(s, c, l), Math.min(s, c, l)) > a)
									return !1;
							}
							return !0;
						}
						Object.assign(Ro.prototype, {
							isBox3: !0,
							set: function (t, e) {
								return this.min.copy(t), this.max.copy(e), this;
							},
							setFromArray: function (t) {
								let e = 1 / 0,
									n = 1 / 0,
									i = 1 / 0,
									r = -1 / 0,
									o = -1 / 0,
									a = -1 / 0;
								for (let s = 0, c = t.length; s < c; s += 3) {
									const c = t[s],
										l = t[s + 1],
										h = t[s + 2];
									c < e && (e = c),
										l < n && (n = l),
										h < i && (i = h),
										c > r && (r = c),
										l > o && (o = l),
										h > a && (a = h);
								}
								return this.min.set(e, n, i), this.max.set(r, o, a), this;
							},
							setFromBufferAttribute: function (t) {
								let e = 1 / 0,
									n = 1 / 0,
									i = 1 / 0,
									r = -1 / 0,
									o = -1 / 0,
									a = -1 / 0;
								for (let s = 0, c = t.count; s < c; s++) {
									const c = t.getX(s),
										l = t.getY(s),
										h = t.getZ(s);
									c < e && (e = c),
										l < n && (n = l),
										h < i && (i = h),
										c > r && (r = c),
										l > o && (o = l),
										h > a && (a = h);
								}
								return this.min.set(e, n, i), this.max.set(r, o, a), this;
							},
							setFromPoints: function (t) {
								this.makeEmpty();
								for (let e = 0, n = t.length; e < n; e++)
									this.expandByPoint(t[e]);
								return this;
							},
							setFromCenterAndSize: function (t, e) {
								const n = co.copy(e).multiplyScalar(0.5);
								return this.min.copy(t).sub(n), this.max.copy(t).add(n), this;
							},
							setFromObject: function (t) {
								return this.makeEmpty(), this.expandByObject(t);
							},
							clone: function () {
								return new this.constructor().copy(this);
							},
							copy: function (t) {
								return this.min.copy(t.min), this.max.copy(t.max), this;
							},
							makeEmpty: function () {
								return (
									(this.min.x = this.min.y = this.min.z = 1 / 0),
									(this.max.x = this.max.y = this.max.z = -1 / 0),
									this
								);
							},
							isEmpty: function () {
								return (
									this.max.x < this.min.x ||
									this.max.y < this.min.y ||
									this.max.z < this.min.z
								);
							},
							getCenter: function (t) {
								return (
									void 0 === t &&
										(console.warn(
											"THREE.Box3: .getCenter() target is now required"
										),
										(t = new zr())),
									this.isEmpty()
										? t.set(0, 0, 0)
										: t.addVectors(this.min, this.max).multiplyScalar(0.5)
								);
							},
							getSize: function (t) {
								return (
									void 0 === t &&
										(console.warn(
											"THREE.Box3: .getSize() target is now required"
										),
										(t = new zr())),
									this.isEmpty()
										? t.set(0, 0, 0)
										: t.subVectors(this.max, this.min)
								);
							},
							expandByPoint: function (t) {
								return this.min.min(t), this.max.max(t), this;
							},
							expandByVector: function (t) {
								return this.min.sub(t), this.max.add(t), this;
							},
							expandByScalar: function (t) {
								return this.min.addScalar(-t), this.max.addScalar(t), this;
							},
							expandByObject: function (t) {
								t.updateWorldMatrix(!1, !1);
								const e = t.geometry;
								void 0 !== e &&
									(null === e.boundingBox && e.computeBoundingBox(),
									lo.copy(e.boundingBox),
									lo.applyMatrix4(t.matrixWorld),
									this.union(lo));
								const n = t.children;
								for (let t = 0, e = n.length; t < e; t++)
									this.expandByObject(n[t]);
								return this;
							},
							containsPoint: function (t) {
								return !(
									t.x < this.min.x ||
									t.x > this.max.x ||
									t.y < this.min.y ||
									t.y > this.max.y ||
									t.z < this.min.z ||
									t.z > this.max.z
								);
							},
							containsBox: function (t) {
								return (
									this.min.x <= t.min.x &&
									t.max.x <= this.max.x &&
									this.min.y <= t.min.y &&
									t.max.y <= this.max.y &&
									this.min.z <= t.min.z &&
									t.max.z <= this.max.z
								);
							},
							getParameter: function (t, e) {
								return (
									void 0 === e &&
										(console.warn(
											"THREE.Box3: .getParameter() target is now required"
										),
										(e = new zr())),
									e.set(
										(t.x - this.min.x) / (this.max.x - this.min.x),
										(t.y - this.min.y) / (this.max.y - this.min.y),
										(t.z - this.min.z) / (this.max.z - this.min.z)
									)
								);
							},
							intersectsBox: function (t) {
								return !(
									t.max.x < this.min.x ||
									t.min.x > this.max.x ||
									t.max.y < this.min.y ||
									t.min.y > this.max.y ||
									t.max.z < this.min.z ||
									t.min.z > this.max.z
								);
							},
							intersectsSphere: function (t) {
								return (
									this.clampPoint(t.center, co),
									co.distanceToSquared(t.center) <= t.radius * t.radius
								);
							},
							intersectsPlane: function (t) {
								let e, n;
								return (
									t.normal.x > 0
										? ((e = t.normal.x * this.min.x),
										  (n = t.normal.x * this.max.x))
										: ((e = t.normal.x * this.max.x),
										  (n = t.normal.x * this.min.x)),
									t.normal.y > 0
										? ((e += t.normal.y * this.min.y),
										  (n += t.normal.y * this.max.y))
										: ((e += t.normal.y * this.max.y),
										  (n += t.normal.y * this.min.y)),
									t.normal.z > 0
										? ((e += t.normal.z * this.min.z),
										  (n += t.normal.z * this.max.z))
										: ((e += t.normal.z * this.max.z),
										  (n += t.normal.z * this.min.z)),
									e <= -t.constant && n >= -t.constant
								);
							},
							intersectsTriangle: function (t) {
								if (this.isEmpty()) return !1;
								this.getCenter(So),
									yo.subVectors(this.max, So),
									ho.subVectors(t.a, So),
									po.subVectors(t.b, So),
									uo.subVectors(t.c, So),
									mo.subVectors(po, ho),
									fo.subVectors(uo, po),
									go.subVectors(ho, uo);
								let e = [
									0,
									-mo.z,
									mo.y,
									0,
									-fo.z,
									fo.y,
									0,
									-go.z,
									go.y,
									mo.z,
									0,
									-mo.x,
									fo.z,
									0,
									-fo.x,
									go.z,
									0,
									-go.x,
									-mo.y,
									mo.x,
									0,
									-fo.y,
									fo.x,
									0,
									-go.y,
									go.x,
									0,
								];
								return (
									!!Mo(e, ho, po, uo, yo) &&
									((e = [1, 0, 0, 0, 1, 0, 0, 0, 1]),
									!!Mo(e, ho, po, uo, yo) &&
										(Vo.crossVectors(mo, fo),
										(e = [Vo.x, Vo.y, Vo.z]),
										Mo(e, ho, po, uo, yo)))
								);
							},
							clampPoint: function (t, e) {
								return (
									void 0 === e &&
										(console.warn(
											"THREE.Box3: .clampPoint() target is now required"
										),
										(e = new zr())),
									e.copy(t).clamp(this.min, this.max)
								);
							},
							distanceToPoint: function (t) {
								return co.copy(t).clamp(this.min, this.max).sub(t).length();
							},
							getBoundingSphere: function (t) {
								return (
									void 0 === t &&
										console.error(
											"THREE.Box3: .getBoundingSphere() target is now required"
										),
									this.getCenter(t.center),
									(t.radius = 0.5 * this.getSize(co).length()),
									t
								);
							},
							intersect: function (t) {
								return (
									this.min.max(t.min),
									this.max.min(t.max),
									this.isEmpty() && this.makeEmpty(),
									this
								);
							},
							union: function (t) {
								return this.min.min(t.min), this.max.max(t.max), this;
							},
							applyMatrix4: function (t) {
								return (
									this.isEmpty() ||
										(so[0]
											.set(this.min.x, this.min.y, this.min.z)
											.applyMatrix4(t),
										so[1]
											.set(this.min.x, this.min.y, this.max.z)
											.applyMatrix4(t),
										so[2]
											.set(this.min.x, this.max.y, this.min.z)
											.applyMatrix4(t),
										so[3]
											.set(this.min.x, this.max.y, this.max.z)
											.applyMatrix4(t),
										so[4]
											.set(this.max.x, this.min.y, this.min.z)
											.applyMatrix4(t),
										so[5]
											.set(this.max.x, this.min.y, this.max.z)
											.applyMatrix4(t),
										so[6]
											.set(this.max.x, this.max.y, this.min.z)
											.applyMatrix4(t),
										so[7]
											.set(this.max.x, this.max.y, this.max.z)
											.applyMatrix4(t),
										this.setFromPoints(so)),
									this
								);
							},
							translate: function (t) {
								return this.min.add(t), this.max.add(t), this;
							},
							equals: function (t) {
								return t.min.equals(this.min) && t.max.equals(this.max);
							},
						});
						const Io = new Ro();
						function vo(t, e) {
							(this.center = void 0 !== t ? t : new zr()),
								(this.radius = void 0 !== e ? e : -1);
						}
						Object.assign(vo.prototype, {
							set: function (t, e) {
								return this.center.copy(t), (this.radius = e), this;
							},
							setFromPoints: function (t, e) {
								const n = this.center;
								void 0 !== e ? n.copy(e) : Io.setFromPoints(t).getCenter(n);
								let i = 0;
								for (let e = 0, r = t.length; e < r; e++)
									i = Math.max(i, n.distanceToSquared(t[e]));
								return (this.radius = Math.sqrt(i)), this;
							},
							clone: function () {
								return new this.constructor().copy(this);
							},
							copy: function (t) {
								return (
									this.center.copy(t.center), (this.radius = t.radius), this
								);
							},
							isEmpty: function () {
								return this.radius < 0;
							},
							makeEmpty: function () {
								return this.center.set(0, 0, 0), (this.radius = -1), this;
							},
							containsPoint: function (t) {
								return (
									t.distanceToSquared(this.center) <= this.radius * this.radius
								);
							},
							distanceToPoint: function (t) {
								return t.distanceTo(this.center) - this.radius;
							},
							intersectsSphere: function (t) {
								const e = this.radius + t.radius;
								return t.center.distanceToSquared(this.center) <= e * e;
							},
							intersectsBox: function (t) {
								return t.intersectsSphere(this);
							},
							intersectsPlane: function (t) {
								return Math.abs(t.distanceToPoint(this.center)) <= this.radius;
							},
							clampPoint: function (t, e) {
								const n = this.center.distanceToSquared(t);
								return (
									void 0 === e &&
										(console.warn(
											"THREE.Sphere: .clampPoint() target is now required"
										),
										(e = new zr())),
									e.copy(t),
									n > this.radius * this.radius &&
										(e.sub(this.center).normalize(),
										e.multiplyScalar(this.radius).add(this.center)),
									e
								);
							},
							getBoundingBox: function (t) {
								return (
									void 0 === t &&
										(console.warn(
											"THREE.Sphere: .getBoundingBox() target is now required"
										),
										(t = new Ro())),
									this.isEmpty()
										? (t.makeEmpty(), t)
										: (t.set(this.center, this.center),
										  t.expandByScalar(this.radius),
										  t)
								);
							},
							applyMatrix4: function (t) {
								return (
									this.center.applyMatrix4(t),
									(this.radius = this.radius * t.getMaxScaleOnAxis()),
									this
								);
							},
							translate: function (t) {
								return this.center.add(t), this;
							},
							equals: function (t) {
								return t.center.equals(this.center) && t.radius === this.radius;
							},
						});
						const ko = new zr(),
							Uo = new zr(),
							wo = new zr(),
							xo = new zr(),
							Oo = new zr(),
							bo = new zr(),
							Ko = new zr();
						function To(t, e) {
							(this.origin = void 0 !== t ? t : new zr()),
								(this.direction = void 0 !== e ? e : new zr(0, 0, -1));
						}
						Object.assign(To.prototype, {
							set: function (t, e) {
								return this.origin.copy(t), this.direction.copy(e), this;
							},
							clone: function () {
								return new this.constructor().copy(this);
							},
							copy: function (t) {
								return (
									this.origin.copy(t.origin),
									this.direction.copy(t.direction),
									this
								);
							},
							at: function (t, e) {
								return (
									void 0 === e &&
										(console.warn("THREE.Ray: .at() target is now required"),
										(e = new zr())),
									e.copy(this.direction).multiplyScalar(t).add(this.origin)
								);
							},
							lookAt: function (t) {
								return (
									this.direction.copy(t).sub(this.origin).normalize(), this
								);
							},
							recast: function (t) {
								return this.origin.copy(this.at(t, ko)), this;
							},
							closestPointToPoint: function (t, e) {
								void 0 === e &&
									(console.warn(
										"THREE.Ray: .closestPointToPoint() target is now required"
									),
									(e = new zr())),
									e.subVectors(t, this.origin);
								const n = e.dot(this.direction);
								return n < 0
									? e.copy(this.origin)
									: e.copy(this.direction).multiplyScalar(n).add(this.origin);
							},
							distanceToPoint: function (t) {
								return Math.sqrt(this.distanceSqToPoint(t));
							},
							distanceSqToPoint: function (t) {
								const e = ko.subVectors(t, this.origin).dot(this.direction);
								return e < 0
									? this.origin.distanceToSquared(t)
									: (ko.copy(this.direction).multiplyScalar(e).add(this.origin),
									  ko.distanceToSquared(t));
							},
							distanceSqToSegment: function (t, e, n, i) {
								Uo.copy(t).add(e).multiplyScalar(0.5),
									wo.copy(e).sub(t).normalize(),
									xo.copy(this.origin).sub(Uo);
								const r = 0.5 * t.distanceTo(e),
									o = -this.direction.dot(wo),
									a = xo.dot(this.direction),
									s = -xo.dot(wo),
									c = xo.lengthSq(),
									l = Math.abs(1 - o * o);
								let h, p, u, d;
								if (l > 0)
									if (((h = o * s - a), (p = o * a - s), (d = r * l), h >= 0))
										if (p >= -d)
											if (p <= d) {
												const t = 1 / l;
												(h *= t),
													(p *= t),
													(u =
														h * (h + o * p + 2 * a) +
														p * (o * h + p + 2 * s) +
														c);
											} else
												(p = r),
													(h = Math.max(0, -(o * p + a))),
													(u = -h * h + p * (p + 2 * s) + c);
										else
											(p = -r),
												(h = Math.max(0, -(o * p + a))),
												(u = -h * h + p * (p + 2 * s) + c);
									else
										p <= -d
											? ((h = Math.max(0, -(-o * r + a))),
											  (p = h > 0 ? -r : Math.min(Math.max(-r, -s), r)),
											  (u = -h * h + p * (p + 2 * s) + c))
											: p <= d
											? ((h = 0),
											  (p = Math.min(Math.max(-r, -s), r)),
											  (u = p * (p + 2 * s) + c))
											: ((h = Math.max(0, -(o * r + a))),
											  (p = h > 0 ? r : Math.min(Math.max(-r, -s), r)),
											  (u = -h * h + p * (p + 2 * s) + c));
								else
									(p = o > 0 ? -r : r),
										(h = Math.max(0, -(o * p + a))),
										(u = -h * h + p * (p + 2 * s) + c);
								return (
									n &&
										n.copy(this.direction).multiplyScalar(h).add(this.origin),
									i && i.copy(wo).multiplyScalar(p).add(Uo),
									u
								);
							},
							intersectSphere: function (t, e) {
								ko.subVectors(t.center, this.origin);
								const n = ko.dot(this.direction),
									i = ko.dot(ko) - n * n,
									r = t.radius * t.radius;
								if (i > r) return null;
								const o = Math.sqrt(r - i),
									a = n - o,
									s = n + o;
								return a < 0 && s < 0
									? null
									: a < 0
									? this.at(s, e)
									: this.at(a, e);
							},
							intersectsSphere: function (t) {
								return this.distanceSqToPoint(t.center) <= t.radius * t.radius;
							},
							distanceToPlane: function (t) {
								const e = t.normal.dot(this.direction);
								if (0 === e)
									return 0 === t.distanceToPoint(this.origin) ? 0 : null;
								const n = -(this.origin.dot(t.normal) + t.constant) / e;
								return n >= 0 ? n : null;
							},
							intersectPlane: function (t, e) {
								const n = this.distanceToPlane(t);
								return null === n ? null : this.at(n, e);
							},
							intersectsPlane: function (t) {
								const e = t.distanceToPoint(this.origin);
								return 0 === e || t.normal.dot(this.direction) * e < 0;
							},
							intersectBox: function (t, e) {
								let n, i, r, o, a, s;
								const c = 1 / this.direction.x,
									l = 1 / this.direction.y,
									h = 1 / this.direction.z,
									p = this.origin;
								return (
									c >= 0
										? ((n = (t.min.x - p.x) * c), (i = (t.max.x - p.x) * c))
										: ((n = (t.max.x - p.x) * c), (i = (t.min.x - p.x) * c)),
									l >= 0
										? ((r = (t.min.y - p.y) * l), (o = (t.max.y - p.y) * l))
										: ((r = (t.max.y - p.y) * l), (o = (t.min.y - p.y) * l)),
									n > o || r > i
										? null
										: ((r > n || n != n) && (n = r),
										  (o < i || i != i) && (i = o),
										  h >= 0
												? ((a = (t.min.z - p.z) * h), (s = (t.max.z - p.z) * h))
												: ((a = (t.max.z - p.z) * h),
												  (s = (t.min.z - p.z) * h)),
										  n > s || a > i
												? null
												: ((a > n || n != n) && (n = a),
												  (s < i || i != i) && (i = s),
												  i < 0 ? null : this.at(n >= 0 ? n : i, e)))
								);
							},
							intersectsBox: function (t) {
								return null !== this.intersectBox(t, ko);
							},
							intersectTriangle: function (t, e, n, i, r) {
								Oo.subVectors(e, t),
									bo.subVectors(n, t),
									Ko.crossVectors(Oo, bo);
								let o,
									a = this.direction.dot(Ko);
								if (a > 0) {
									if (i) return null;
									o = 1;
								} else {
									if (!(a < 0)) return null;
									(o = -1), (a = -a);
								}
								xo.subVectors(this.origin, t);
								const s = o * this.direction.dot(bo.crossVectors(xo, bo));
								if (s < 0) return null;
								const c = o * this.direction.dot(Oo.cross(xo));
								if (c < 0) return null;
								if (s + c > a) return null;
								const l = -o * xo.dot(Ko);
								return l < 0 ? null : this.at(l / a, r);
							},
							applyMatrix4: function (t) {
								return (
									this.origin.applyMatrix4(t),
									this.direction.transformDirection(t),
									this
								);
							},
							equals: function (t) {
								return (
									t.origin.equals(this.origin) &&
									t.direction.equals(this.direction)
								);
							},
						});
						const zo = new zr(),
							Wo = new zr(),
							Eo = new Mr();
						function Co(t, e) {
							(this.normal = void 0 !== t ? t : new zr(1, 0, 0)),
								(this.constant = void 0 !== e ? e : 0);
						}
						Object.assign(Co.prototype, {
							isPlane: !0,
							set: function (t, e) {
								return this.normal.copy(t), (this.constant = e), this;
							},
							setComponents: function (t, e, n, i) {
								return this.normal.set(t, e, n), (this.constant = i), this;
							},
							setFromNormalAndCoplanarPoint: function (t, e) {
								return (
									this.normal.copy(t),
									(this.constant = -e.dot(this.normal)),
									this
								);
							},
							setFromCoplanarPoints: function (t, e, n) {
								const i = zo
									.subVectors(n, e)
									.cross(Wo.subVectors(t, e))
									.normalize();
								return this.setFromNormalAndCoplanarPoint(i, t), this;
							},
							clone: function () {
								return new this.constructor().copy(this);
							},
							copy: function (t) {
								return (
									this.normal.copy(t.normal), (this.constant = t.constant), this
								);
							},
							normalize: function () {
								const t = 1 / this.normal.length();
								return (
									this.normal.multiplyScalar(t), (this.constant *= t), this
								);
							},
							negate: function () {
								return (this.constant *= -1), this.normal.negate(), this;
							},
							distanceToPoint: function (t) {
								return this.normal.dot(t) + this.constant;
							},
							distanceToSphere: function (t) {
								return this.distanceToPoint(t.center) - t.radius;
							},
							projectPoint: function (t, e) {
								return (
									void 0 === e &&
										(console.warn(
											"THREE.Plane: .projectPoint() target is now required"
										),
										(e = new zr())),
									e
										.copy(this.normal)
										.multiplyScalar(-this.distanceToPoint(t))
										.add(t)
								);
							},
							intersectLine: function (t, e) {
								void 0 === e &&
									(console.warn(
										"THREE.Plane: .intersectLine() target is now required"
									),
									(e = new zr()));
								const n = t.delta(zo),
									i = this.normal.dot(n);
								if (0 === i)
									return 0 === this.distanceToPoint(t.start)
										? e.copy(t.start)
										: void 0;
								const r = -(t.start.dot(this.normal) + this.constant) / i;
								return r < 0 || r > 1
									? void 0
									: e.copy(n).multiplyScalar(r).add(t.start);
							},
							intersectsLine: function (t) {
								const e = this.distanceToPoint(t.start),
									n = this.distanceToPoint(t.end);
								return (e < 0 && n > 0) || (n < 0 && e > 0);
							},
							intersectsBox: function (t) {
								return t.intersectsPlane(this);
							},
							intersectsSphere: function (t) {
								return t.intersectsPlane(this);
							},
							coplanarPoint: function (t) {
								return (
									void 0 === t &&
										(console.warn(
											"THREE.Plane: .coplanarPoint() target is now required"
										),
										(t = new zr())),
									t.copy(this.normal).multiplyScalar(-this.constant)
								);
							},
							applyMatrix4: function (t, e) {
								const n = e || Eo.getNormalMatrix(t),
									i = this.coplanarPoint(zo).applyMatrix4(t),
									r = this.normal.applyMatrix3(n).normalize();
								return (this.constant = -i.dot(r)), this;
							},
							translate: function (t) {
								return (this.constant -= t.dot(this.normal)), this;
							},
							equals: function (t) {
								return (
									t.normal.equals(this.normal) && t.constant === this.constant
								);
							},
						});
						const Fo = new zr(),
							Zo = new zr(),
							Ho = new zr(),
							No = new zr(),
							jo = new zr(),
							Do = new zr(),
							Ao = new zr(),
							Lo = new zr(),
							Bo = new zr(),
							Go = new zr();
						function Qo(t, e, n) {
							(this.a = void 0 !== t ? t : new zr()),
								(this.b = void 0 !== e ? e : new zr()),
								(this.c = void 0 !== n ? n : new zr());
						}
						Object.assign(Qo, {
							getNormal: function (t, e, n, i) {
								void 0 === i &&
									(console.warn(
										"THREE.Triangle: .getNormal() target is now required"
									),
									(i = new zr())),
									i.subVectors(n, e),
									Fo.subVectors(t, e),
									i.cross(Fo);
								const r = i.lengthSq();
								return r > 0
									? i.multiplyScalar(1 / Math.sqrt(r))
									: i.set(0, 0, 0);
							},
							getBarycoord: function (t, e, n, i, r) {
								Fo.subVectors(i, e), Zo.subVectors(n, e), Ho.subVectors(t, e);
								const o = Fo.dot(Fo),
									a = Fo.dot(Zo),
									s = Fo.dot(Ho),
									c = Zo.dot(Zo),
									l = Zo.dot(Ho),
									h = o * c - a * a;
								if (
									(void 0 === r &&
										(console.warn(
											"THREE.Triangle: .getBarycoord() target is now required"
										),
										(r = new zr())),
									0 === h)
								)
									return r.set(-2, -1, -1);
								const p = 1 / h,
									u = (c * s - a * l) * p,
									d = (o * l - a * s) * p;
								return r.set(1 - u - d, d, u);
							},
							containsPoint: function (t, e, n, i) {
								return (
									Qo.getBarycoord(t, e, n, i, No),
									No.x >= 0 && No.y >= 0 && No.x + No.y <= 1
								);
							},
							getUV: function (t, e, n, i, r, o, a, s) {
								return (
									this.getBarycoord(t, e, n, i, No),
									s.set(0, 0),
									s.addScaledVector(r, No.x),
									s.addScaledVector(o, No.y),
									s.addScaledVector(a, No.z),
									s
								);
							},
							isFrontFacing: function (t, e, n, i) {
								return (
									Fo.subVectors(n, e),
									Zo.subVectors(t, e),
									Fo.cross(Zo).dot(i) < 0
								);
							},
						}),
							Object.assign(Qo.prototype, {
								set: function (t, e, n) {
									return this.a.copy(t), this.b.copy(e), this.c.copy(n), this;
								},
								setFromPointsAndIndices: function (t, e, n, i) {
									return (
										this.a.copy(t[e]),
										this.b.copy(t[n]),
										this.c.copy(t[i]),
										this
									);
								},
								clone: function () {
									return new this.constructor().copy(this);
								},
								copy: function (t) {
									return (
										this.a.copy(t.a), this.b.copy(t.b), this.c.copy(t.c), this
									);
								},
								getArea: function () {
									return (
										Fo.subVectors(this.c, this.b),
										Zo.subVectors(this.a, this.b),
										0.5 * Fo.cross(Zo).length()
									);
								},
								getMidpoint: function (t) {
									return (
										void 0 === t &&
											(console.warn(
												"THREE.Triangle: .getMidpoint() target is now required"
											),
											(t = new zr())),
										t
											.addVectors(this.a, this.b)
											.add(this.c)
											.multiplyScalar(1 / 3)
									);
								},
								getNormal: function (t) {
									return Qo.getNormal(this.a, this.b, this.c, t);
								},
								getPlane: function (t) {
									return (
										void 0 === t &&
											(console.warn(
												"THREE.Triangle: .getPlane() target is now required"
											),
											(t = new Co())),
										t.setFromCoplanarPoints(this.a, this.b, this.c)
									);
								},
								getBarycoord: function (t, e) {
									return Qo.getBarycoord(t, this.a, this.b, this.c, e);
								},
								getUV: function (t, e, n, i, r) {
									return Qo.getUV(t, this.a, this.b, this.c, e, n, i, r);
								},
								containsPoint: function (t) {
									return Qo.containsPoint(t, this.a, this.b, this.c);
								},
								isFrontFacing: function (t) {
									return Qo.isFrontFacing(this.a, this.b, this.c, t);
								},
								intersectsBox: function (t) {
									return t.intersectsTriangle(this);
								},
								closestPointToPoint: function (t, e) {
									void 0 === e &&
										(console.warn(
											"THREE.Triangle: .closestPointToPoint() target is now required"
										),
										(e = new zr()));
									const n = this.a,
										i = this.b,
										r = this.c;
									let o, a;
									jo.subVectors(i, n), Do.subVectors(r, n), Lo.subVectors(t, n);
									const s = jo.dot(Lo),
										c = Do.dot(Lo);
									if (s <= 0 && c <= 0) return e.copy(n);
									Bo.subVectors(t, i);
									const l = jo.dot(Bo),
										h = Do.dot(Bo);
									if (l >= 0 && h <= l) return e.copy(i);
									const p = s * h - l * c;
									if (p <= 0 && s >= 0 && l <= 0)
										return (o = s / (s - l)), e.copy(n).addScaledVector(jo, o);
									Go.subVectors(t, r);
									const u = jo.dot(Go),
										d = Do.dot(Go);
									if (d >= 0 && u <= d) return e.copy(r);
									const m = u * c - s * d;
									if (m <= 0 && c >= 0 && d <= 0)
										return (a = c / (c - d)), e.copy(n).addScaledVector(Do, a);
									const f = l * d - u * h;
									if (f <= 0 && h - l >= 0 && u - d >= 0)
										return (
											Ao.subVectors(r, i),
											(a = (h - l) / (h - l + (u - d))),
											e.copy(i).addScaledVector(Ao, a)
										);
									const g = 1 / (f + m + p);
									return (
										(o = m * g),
										(a = p * g),
										e.copy(n).addScaledVector(jo, o).addScaledVector(Do, a)
									);
								},
								equals: function (t) {
									return (
										t.a.equals(this.a) &&
										t.b.equals(this.b) &&
										t.c.equals(this.c)
									);
								},
							});
						const _o = {
								aliceblue: 15792383,
								antiquewhite: 16444375,
								aqua: 65535,
								aquamarine: 8388564,
								azure: 15794175,
								beige: 16119260,
								bisque: 16770244,
								black: 0,
								blanchedalmond: 16772045,
								blue: 255,
								blueviolet: 9055202,
								brown: 10824234,
								burlywood: 14596231,
								cadetblue: 6266528,
								chartreuse: 8388352,
								chocolate: 13789470,
								coral: 16744272,
								cornflowerblue: 6591981,
								cornsilk: 16775388,
								crimson: 14423100,
								cyan: 65535,
								darkblue: 139,
								darkcyan: 35723,
								darkgoldenrod: 12092939,
								darkgray: 11119017,
								darkgreen: 25600,
								darkgrey: 11119017,
								darkkhaki: 12433259,
								darkmagenta: 9109643,
								darkolivegreen: 5597999,
								darkorange: 16747520,
								darkorchid: 10040012,
								darkred: 9109504,
								darksalmon: 15308410,
								darkseagreen: 9419919,
								darkslateblue: 4734347,
								darkslategray: 3100495,
								darkslategrey: 3100495,
								darkturquoise: 52945,
								darkviolet: 9699539,
								deeppink: 16716947,
								deepskyblue: 49151,
								dimgray: 6908265,
								dimgrey: 6908265,
								dodgerblue: 2003199,
								firebrick: 11674146,
								floralwhite: 16775920,
								forestgreen: 2263842,
								fuchsia: 16711935,
								gainsboro: 14474460,
								ghostwhite: 16316671,
								gold: 16766720,
								goldenrod: 14329120,
								gray: 8421504,
								green: 32768,
								greenyellow: 11403055,
								grey: 8421504,
								honeydew: 15794160,
								hotpink: 16738740,
								indianred: 13458524,
								indigo: 4915330,
								ivory: 16777200,
								khaki: 15787660,
								lavender: 15132410,
								lavenderblush: 16773365,
								lawngreen: 8190976,
								lemonchiffon: 16775885,
								lightblue: 11393254,
								lightcoral: 15761536,
								lightcyan: 14745599,
								lightgoldenrodyellow: 16448210,
								lightgray: 13882323,
								lightgreen: 9498256,
								lightgrey: 13882323,
								lightpink: 16758465,
								lightsalmon: 16752762,
								lightseagreen: 2142890,
								lightskyblue: 8900346,
								lightslategray: 7833753,
								lightslategrey: 7833753,
								lightsteelblue: 11584734,
								lightyellow: 16777184,
								lime: 65280,
								limegreen: 3329330,
								linen: 16445670,
								magenta: 16711935,
								maroon: 8388608,
								mediumaquamarine: 6737322,
								mediumblue: 205,
								mediumorchid: 12211667,
								mediumpurple: 9662683,
								mediumseagreen: 3978097,
								mediumslateblue: 8087790,
								mediumspringgreen: 64154,
								mediumturquoise: 4772300,
								mediumvioletred: 13047173,
								midnightblue: 1644912,
								mintcream: 16121850,
								mistyrose: 16770273,
								moccasin: 16770229,
								navajowhite: 16768685,
								navy: 128,
								oldlace: 16643558,
								olive: 8421376,
								olivedrab: 7048739,
								orange: 16753920,
								orangered: 16729344,
								orchid: 14315734,
								palegoldenrod: 15657130,
								palegreen: 10025880,
								paleturquoise: 11529966,
								palevioletred: 14381203,
								papayawhip: 16773077,
								peachpuff: 16767673,
								peru: 13468991,
								pink: 16761035,
								plum: 14524637,
								powderblue: 11591910,
								purple: 8388736,
								rebeccapurple: 6697881,
								red: 16711680,
								rosybrown: 12357519,
								royalblue: 4286945,
								saddlebrown: 9127187,
								salmon: 16416882,
								sandybrown: 16032864,
								seagreen: 3050327,
								seashell: 16774638,
								sienna: 10506797,
								silver: 12632256,
								skyblue: 8900331,
								slateblue: 6970061,
								slategray: 7372944,
								slategrey: 7372944,
								snow: 16775930,
								springgreen: 65407,
								steelblue: 4620980,
								tan: 13808780,
								teal: 32896,
								thistle: 14204888,
								tomato: 16737095,
								turquoise: 4251856,
								violet: 15631086,
								wheat: 16113331,
								white: 16777215,
								whitesmoke: 16119285,
								yellow: 16776960,
								yellowgreen: 10145074,
							},
							Po = { h: 0, s: 0, l: 0 },
							Jo = { h: 0, s: 0, l: 0 };
						function Yo(t, e, n) {
							return void 0 === e && void 0 === n
								? this.set(t)
								: this.setRGB(t, e, n);
						}
						function Xo(t, e, n) {
							return (
								n < 0 && (n += 1),
								n > 1 && (n -= 1),
								n < 1 / 6
									? t + 6 * (e - t) * n
									: n < 0.5
									? e
									: n < 2 / 3
									? t + 6 * (e - t) * (2 / 3 - n)
									: t
							);
						}
						function $o(t) {
							return t < 0.04045
								? 0.0773993808 * t
								: Math.pow(0.9478672986 * t + 0.0521327014, 2.4);
						}
						function ta(t) {
							return t < 0.0031308
								? 12.92 * t
								: 1.055 * Math.pow(t, 0.41666) - 0.055;
						}
						function ea(t, e, n, i, r, o) {
							(this.a = t),
								(this.b = e),
								(this.c = n),
								(this.normal = i && i.isVector3 ? i : new zr()),
								(this.vertexNormals = Array.isArray(i) ? i : []),
								(this.color = r && r.isColor ? r : new Yo()),
								(this.vertexColors = Array.isArray(r) ? r : []),
								(this.materialIndex = void 0 !== o ? o : 0);
						}
						Object.assign(Yo.prototype, {
							isColor: !0,
							r: 1,
							g: 1,
							b: 1,
							set: function (t) {
								return (
									t && t.isColor
										? this.copy(t)
										: "number" == typeof t
										? this.setHex(t)
										: "string" == typeof t && this.setStyle(t),
									this
								);
							},
							setScalar: function (t) {
								return (this.r = t), (this.g = t), (this.b = t), this;
							},
							setHex: function (t) {
								return (
									(t = Math.floor(t)),
									(this.r = ((t >> 16) & 255) / 255),
									(this.g = ((t >> 8) & 255) / 255),
									(this.b = (255 & t) / 255),
									this
								);
							},
							setRGB: function (t, e, n) {
								return (this.r = t), (this.g = e), (this.b = n), this;
							},
							setHSL: function (t, e, n) {
								if (
									((t = qr.euclideanModulo(t, 1)),
									(e = qr.clamp(e, 0, 1)),
									(n = qr.clamp(n, 0, 1)),
									0 === e)
								)
									this.r = this.g = this.b = n;
								else {
									const i = n <= 0.5 ? n * (1 + e) : n + e - n * e,
										r = 2 * n - i;
									(this.r = Xo(r, i, t + 1 / 3)),
										(this.g = Xo(r, i, t)),
										(this.b = Xo(r, i, t - 1 / 3));
								}
								return this;
							},
							setStyle: function (t) {
								function e(e) {
									void 0 !== e &&
										parseFloat(e) < 1 &&
										console.warn(
											"THREE.Color: Alpha component of " +
												t +
												" will be ignored."
										);
								}
								let n;
								if ((n = /^((?:rgb|hsl)a?)\(\s*([^\)]*)\)/.exec(t))) {
									let t;
									const i = n[1],
										r = n[2];
									switch (i) {
										case "rgb":
										case "rgba":
											if (
												(t =
													/^(\d+)\s*,\s*(\d+)\s*,\s*(\d+)\s*(,\s*([0-9]*\.?[0-9]+)\s*)?$/.exec(
														r
													))
											)
												return (
													(this.r = Math.min(255, parseInt(t[1], 10)) / 255),
													(this.g = Math.min(255, parseInt(t[2], 10)) / 255),
													(this.b = Math.min(255, parseInt(t[3], 10)) / 255),
													e(t[5]),
													this
												);
											if (
												(t =
													/^(\d+)\%\s*,\s*(\d+)\%\s*,\s*(\d+)\%\s*(,\s*([0-9]*\.?[0-9]+)\s*)?$/.exec(
														r
													))
											)
												return (
													(this.r = Math.min(100, parseInt(t[1], 10)) / 100),
													(this.g = Math.min(100, parseInt(t[2], 10)) / 100),
													(this.b = Math.min(100, parseInt(t[3], 10)) / 100),
													e(t[5]),
													this
												);
											break;
										case "hsl":
										case "hsla":
											if (
												(t =
													/^([0-9]*\.?[0-9]+)\s*,\s*(\d+)\%\s*,\s*(\d+)\%\s*(,\s*([0-9]*\.?[0-9]+)\s*)?$/.exec(
														r
													))
											) {
												const n = parseFloat(t[1]) / 360,
													i = parseInt(t[2], 10) / 100,
													r = parseInt(t[3], 10) / 100;
												return e(t[5]), this.setHSL(n, i, r);
											}
									}
								} else if ((n = /^\#([A-Fa-f0-9]+)$/.exec(t))) {
									const t = n[1],
										e = t.length;
									if (3 === e)
										return (
											(this.r = parseInt(t.charAt(0) + t.charAt(0), 16) / 255),
											(this.g = parseInt(t.charAt(1) + t.charAt(1), 16) / 255),
											(this.b = parseInt(t.charAt(2) + t.charAt(2), 16) / 255),
											this
										);
									if (6 === e)
										return (
											(this.r = parseInt(t.charAt(0) + t.charAt(1), 16) / 255),
											(this.g = parseInt(t.charAt(2) + t.charAt(3), 16) / 255),
											(this.b = parseInt(t.charAt(4) + t.charAt(5), 16) / 255),
											this
										);
								}
								return t && t.length > 0 ? this.setColorName(t) : this;
							},
							setColorName: function (t) {
								const e = _o[t];
								return (
									void 0 !== e
										? this.setHex(e)
										: console.warn("THREE.Color: Unknown color " + t),
									this
								);
							},
							clone: function () {
								return new this.constructor(this.r, this.g, this.b);
							},
							copy: function (t) {
								return (this.r = t.r), (this.g = t.g), (this.b = t.b), this;
							},
							copyGammaToLinear: function (t, e) {
								return (
									void 0 === e && (e = 2),
									(this.r = Math.pow(t.r, e)),
									(this.g = Math.pow(t.g, e)),
									(this.b = Math.pow(t.b, e)),
									this
								);
							},
							copyLinearToGamma: function (t, e) {
								void 0 === e && (e = 2);
								const n = e > 0 ? 1 / e : 1;
								return (
									(this.r = Math.pow(t.r, n)),
									(this.g = Math.pow(t.g, n)),
									(this.b = Math.pow(t.b, n)),
									this
								);
							},
							convertGammaToLinear: function (t) {
								return this.copyGammaToLinear(this, t), this;
							},
							convertLinearToGamma: function (t) {
								return this.copyLinearToGamma(this, t), this;
							},
							copySRGBToLinear: function (t) {
								return (
									(this.r = $o(t.r)),
									(this.g = $o(t.g)),
									(this.b = $o(t.b)),
									this
								);
							},
							copyLinearToSRGB: function (t) {
								return (
									(this.r = ta(t.r)),
									(this.g = ta(t.g)),
									(this.b = ta(t.b)),
									this
								);
							},
							convertSRGBToLinear: function () {
								return this.copySRGBToLinear(this), this;
							},
							convertLinearToSRGB: function () {
								return this.copyLinearToSRGB(this), this;
							},
							getHex: function () {
								return (
									((255 * this.r) << 16) ^
									((255 * this.g) << 8) ^
									((255 * this.b) << 0)
								);
							},
							getHexString: function () {
								return ("000000" + this.getHex().toString(16)).slice(-6);
							},
							getHSL: function (t) {
								void 0 === t &&
									(console.warn(
										"THREE.Color: .getHSL() target is now required"
									),
									(t = { h: 0, s: 0, l: 0 }));
								const e = this.r,
									n = this.g,
									i = this.b,
									r = Math.max(e, n, i),
									o = Math.min(e, n, i);
								let a, s;
								const c = (o + r) / 2;
								if (o === r) (a = 0), (s = 0);
								else {
									const t = r - o;
									switch (((s = c <= 0.5 ? t / (r + o) : t / (2 - r - o)), r)) {
										case e:
											a = (n - i) / t + (n < i ? 6 : 0);
											break;
										case n:
											a = (i - e) / t + 2;
											break;
										case i:
											a = (e - n) / t + 4;
									}
									a /= 6;
								}
								return (t.h = a), (t.s = s), (t.l = c), t;
							},
							getStyle: function () {
								return (
									"rgb(" +
									((255 * this.r) | 0) +
									"," +
									((255 * this.g) | 0) +
									"," +
									((255 * this.b) | 0) +
									")"
								);
							},
							offsetHSL: function (t, e, n) {
								return (
									this.getHSL(Po),
									(Po.h += t),
									(Po.s += e),
									(Po.l += n),
									this.setHSL(Po.h, Po.s, Po.l),
									this
								);
							},
							add: function (t) {
								return (this.r += t.r), (this.g += t.g), (this.b += t.b), this;
							},
							addColors: function (t, e) {
								return (
									(this.r = t.r + e.r),
									(this.g = t.g + e.g),
									(this.b = t.b + e.b),
									this
								);
							},
							addScalar: function (t) {
								return (this.r += t), (this.g += t), (this.b += t), this;
							},
							sub: function (t) {
								return (
									(this.r = Math.max(0, this.r - t.r)),
									(this.g = Math.max(0, this.g - t.g)),
									(this.b = Math.max(0, this.b - t.b)),
									this
								);
							},
							multiply: function (t) {
								return (this.r *= t.r), (this.g *= t.g), (this.b *= t.b), this;
							},
							multiplyScalar: function (t) {
								return (this.r *= t), (this.g *= t), (this.b *= t), this;
							},
							lerp: function (t, e) {
								return (
									(this.r += (t.r - this.r) * e),
									(this.g += (t.g - this.g) * e),
									(this.b += (t.b - this.b) * e),
									this
								);
							},
							lerpHSL: function (t, e) {
								this.getHSL(Po), t.getHSL(Jo);
								const n = qr.lerp(Po.h, Jo.h, e),
									i = qr.lerp(Po.s, Jo.s, e),
									r = qr.lerp(Po.l, Jo.l, e);
								return this.setHSL(n, i, r), this;
							},
							equals: function (t) {
								return t.r === this.r && t.g === this.g && t.b === this.b;
							},
							fromArray: function (t, e) {
								return (
									void 0 === e && (e = 0),
									(this.r = t[e]),
									(this.g = t[e + 1]),
									(this.b = t[e + 2]),
									this
								);
							},
							toArray: function (t, e) {
								return (
									void 0 === t && (t = []),
									void 0 === e && (e = 0),
									(t[e] = this.r),
									(t[e + 1] = this.g),
									(t[e + 2] = this.b),
									t
								);
							},
							fromBufferAttribute: function (t, e) {
								return (
									(this.r = t.getX(e)),
									(this.g = t.getY(e)),
									(this.b = t.getZ(e)),
									!0 === t.normalized &&
										((this.r /= 255), (this.g /= 255), (this.b /= 255)),
									this
								);
							},
							toJSON: function () {
								return this.getHex();
							},
						}),
							(Yo.NAMES = _o),
							Object.assign(ea.prototype, {
								clone: function () {
									return new this.constructor().copy(this);
								},
								copy: function (t) {
									(this.a = t.a),
										(this.b = t.b),
										(this.c = t.c),
										this.normal.copy(t.normal),
										this.color.copy(t.color),
										(this.materialIndex = t.materialIndex);
									for (let e = 0, n = t.vertexNormals.length; e < n; e++)
										this.vertexNormals[e] = t.vertexNormals[e].clone();
									for (let e = 0, n = t.vertexColors.length; e < n; e++)
										this.vertexColors[e] = t.vertexColors[e].clone();
									return this;
								},
							});
						let na = 0;
						function ia() {
							Object.defineProperty(this, "id", { value: na++ }),
								(this.uuid = qr.generateUUID()),
								(this.name = ""),
								(this.type = "Material"),
								(this.fog = !0),
								(this.blending = 1),
								(this.side = 0),
								(this.flatShading = !1),
								(this.vertexColors = !1),
								(this.opacity = 1),
								(this.transparent = !1),
								(this.blendSrc = 204),
								(this.blendDst = 205),
								(this.blendEquation = Ci),
								(this.blendSrcAlpha = null),
								(this.blendDstAlpha = null),
								(this.blendEquationAlpha = null),
								(this.depthFunc = 3),
								(this.depthTest = !0),
								(this.depthWrite = !0),
								(this.stencilWriteMask = 255),
								(this.stencilFunc = 519),
								(this.stencilRef = 0),
								(this.stencilFuncMask = 255),
								(this.stencilFail = mr),
								(this.stencilZFail = mr),
								(this.stencilZPass = mr),
								(this.stencilWrite = !1),
								(this.clippingPlanes = null),
								(this.clipIntersection = !1),
								(this.clipShadows = !1),
								(this.shadowSide = null),
								(this.colorWrite = !0),
								(this.precision = null),
								(this.polygonOffset = !1),
								(this.polygonOffsetFactor = 0),
								(this.polygonOffsetUnits = 0),
								(this.dithering = !1),
								(this.alphaTest = 0),
								(this.premultipliedAlpha = !1),
								(this.visible = !0),
								(this.toneMapped = !0),
								(this.userData = {}),
								(this.version = 0);
						}
						function ra(t) {
							ia.call(this),
								(this.type = "MeshBasicMaterial"),
								(this.color = new Yo(16777215)),
								(this.map = null),
								(this.lightMap = null),
								(this.lightMapIntensity = 1),
								(this.aoMap = null),
								(this.aoMapIntensity = 1),
								(this.specularMap = null),
								(this.alphaMap = null),
								(this.envMap = null),
								(this.combine = 0),
								(this.reflectivity = 1),
								(this.refractionRatio = 0.98),
								(this.wireframe = !1),
								(this.wireframeLinewidth = 1),
								(this.wireframeLinecap = "round"),
								(this.wireframeLinejoin = "round"),
								(this.skinning = !1),
								(this.morphTargets = !1),
								this.setValues(t);
						}
						(ia.prototype = Object.assign(Object.create(Sr.prototype), {
							constructor: ia,
							isMaterial: !0,
							onBeforeCompile: function () {},
							customProgramCacheKey: function () {
								return this.onBeforeCompile.toString();
							},
							setValues: function (t) {
								if (void 0 !== t)
									for (const e in t) {
										const n = t[e];
										if (void 0 === n) {
											console.warn(
												"THREE.Material: '" + e + "' parameter is undefined."
											);
											continue;
										}
										if ("shading" === e) {
											console.warn(
												"THREE." +
													this.type +
													": .shading has been removed. Use the boolean .flatShading instead."
											),
												(this.flatShading = 1 === n);
											continue;
										}
										const i = this[e];
										void 0 !== i
											? i && i.isColor
												? i.set(n)
												: i && i.isVector3 && n && n.isVector3
												? i.copy(n)
												: (this[e] = n)
											: console.warn(
													"THREE." +
														this.type +
														": '" +
														e +
														"' is not a property of this material."
											  );
									}
							},
							toJSON: function (t) {
								const e = void 0 === t || "string" == typeof t;
								e && (t = { textures: {}, images: {} });
								const n = {
									metadata: {
										version: 4.5,
										type: "Material",
										generator: "Material.toJSON",
									},
								};
								function i(t) {
									const e = [];
									for (const n in t) {
										const i = t[n];
										delete i.metadata, e.push(i);
									}
									return e;
								}
								if (
									((n.uuid = this.uuid),
									(n.type = this.type),
									"" !== this.name && (n.name = this.name),
									this.color &&
										this.color.isColor &&
										(n.color = this.color.getHex()),
									void 0 !== this.roughness && (n.roughness = this.roughness),
									void 0 !== this.metalness && (n.metalness = this.metalness),
									this.sheen &&
										this.sheen.isColor &&
										(n.sheen = this.sheen.getHex()),
									this.emissive &&
										this.emissive.isColor &&
										(n.emissive = this.emissive.getHex()),
									this.emissiveIntensity &&
										1 !== this.emissiveIntensity &&
										(n.emissiveIntensity = this.emissiveIntensity),
									this.specular &&
										this.specular.isColor &&
										(n.specular = this.specular.getHex()),
									void 0 !== this.shininess && (n.shininess = this.shininess),
									void 0 !== this.clearcoat && (n.clearcoat = this.clearcoat),
									void 0 !== this.clearcoatRoughness &&
										(n.clearcoatRoughness = this.clearcoatRoughness),
									this.clearcoatMap &&
										this.clearcoatMap.isTexture &&
										(n.clearcoatMap = this.clearcoatMap.toJSON(t).uuid),
									this.clearcoatRoughnessMap &&
										this.clearcoatRoughnessMap.isTexture &&
										(n.clearcoatRoughnessMap =
											this.clearcoatRoughnessMap.toJSON(t).uuid),
									this.clearcoatNormalMap &&
										this.clearcoatNormalMap.isTexture &&
										((n.clearcoatNormalMap =
											this.clearcoatNormalMap.toJSON(t).uuid),
										(n.clearcoatNormalScale =
											this.clearcoatNormalScale.toArray())),
									this.map &&
										this.map.isTexture &&
										(n.map = this.map.toJSON(t).uuid),
									this.matcap &&
										this.matcap.isTexture &&
										(n.matcap = this.matcap.toJSON(t).uuid),
									this.alphaMap &&
										this.alphaMap.isTexture &&
										(n.alphaMap = this.alphaMap.toJSON(t).uuid),
									this.lightMap &&
										this.lightMap.isTexture &&
										(n.lightMap = this.lightMap.toJSON(t).uuid),
									this.aoMap &&
										this.aoMap.isTexture &&
										((n.aoMap = this.aoMap.toJSON(t).uuid),
										(n.aoMapIntensity = this.aoMapIntensity)),
									this.bumpMap &&
										this.bumpMap.isTexture &&
										((n.bumpMap = this.bumpMap.toJSON(t).uuid),
										(n.bumpScale = this.bumpScale)),
									this.normalMap &&
										this.normalMap.isTexture &&
										((n.normalMap = this.normalMap.toJSON(t).uuid),
										(n.normalMapType = this.normalMapType),
										(n.normalScale = this.normalScale.toArray())),
									this.displacementMap &&
										this.displacementMap.isTexture &&
										((n.displacementMap = this.displacementMap.toJSON(t).uuid),
										(n.displacementScale = this.displacementScale),
										(n.displacementBias = this.displacementBias)),
									this.roughnessMap &&
										this.roughnessMap.isTexture &&
										(n.roughnessMap = this.roughnessMap.toJSON(t).uuid),
									this.metalnessMap &&
										this.metalnessMap.isTexture &&
										(n.metalnessMap = this.metalnessMap.toJSON(t).uuid),
									this.emissiveMap &&
										this.emissiveMap.isTexture &&
										(n.emissiveMap = this.emissiveMap.toJSON(t).uuid),
									this.specularMap &&
										this.specularMap.isTexture &&
										(n.specularMap = this.specularMap.toJSON(t).uuid),
									this.envMap &&
										this.envMap.isTexture &&
										((n.envMap = this.envMap.toJSON(t).uuid),
										(n.reflectivity = this.reflectivity),
										(n.refractionRatio = this.refractionRatio),
										void 0 !== this.combine && (n.combine = this.combine),
										void 0 !== this.envMapIntensity &&
											(n.envMapIntensity = this.envMapIntensity)),
									this.gradientMap &&
										this.gradientMap.isTexture &&
										(n.gradientMap = this.gradientMap.toJSON(t).uuid),
									void 0 !== this.size && (n.size = this.size),
									void 0 !== this.sizeAttenuation &&
										(n.sizeAttenuation = this.sizeAttenuation),
									1 !== this.blending && (n.blending = this.blending),
									!0 === this.flatShading && (n.flatShading = this.flatShading),
									0 !== this.side && (n.side = this.side),
									this.vertexColors && (n.vertexColors = !0),
									this.opacity < 1 && (n.opacity = this.opacity),
									!0 === this.transparent && (n.transparent = this.transparent),
									(n.depthFunc = this.depthFunc),
									(n.depthTest = this.depthTest),
									(n.depthWrite = this.depthWrite),
									(n.stencilWrite = this.stencilWrite),
									(n.stencilWriteMask = this.stencilWriteMask),
									(n.stencilFunc = this.stencilFunc),
									(n.stencilRef = this.stencilRef),
									(n.stencilFuncMask = this.stencilFuncMask),
									(n.stencilFail = this.stencilFail),
									(n.stencilZFail = this.stencilZFail),
									(n.stencilZPass = this.stencilZPass),
									this.rotation &&
										0 !== this.rotation &&
										(n.rotation = this.rotation),
									!0 === this.polygonOffset && (n.polygonOffset = !0),
									0 !== this.polygonOffsetFactor &&
										(n.polygonOffsetFactor = this.polygonOffsetFactor),
									0 !== this.polygonOffsetUnits &&
										(n.polygonOffsetUnits = this.polygonOffsetUnits),
									this.linewidth &&
										1 !== this.linewidth &&
										(n.linewidth = this.linewidth),
									void 0 !== this.dashSize && (n.dashSize = this.dashSize),
									void 0 !== this.gapSize && (n.gapSize = this.gapSize),
									void 0 !== this.scale && (n.scale = this.scale),
									!0 === this.dithering && (n.dithering = !0),
									this.alphaTest > 0 && (n.alphaTest = this.alphaTest),
									!0 === this.premultipliedAlpha &&
										(n.premultipliedAlpha = this.premultipliedAlpha),
									!0 === this.wireframe && (n.wireframe = this.wireframe),
									this.wireframeLinewidth > 1 &&
										(n.wireframeLinewidth = this.wireframeLinewidth),
									"round" !== this.wireframeLinecap &&
										(n.wireframeLinecap = this.wireframeLinecap),
									"round" !== this.wireframeLinejoin &&
										(n.wireframeLinejoin = this.wireframeLinejoin),
									!0 === this.morphTargets && (n.morphTargets = !0),
									!0 === this.morphNormals && (n.morphNormals = !0),
									!0 === this.skinning && (n.skinning = !0),
									!1 === this.visible && (n.visible = !1),
									!1 === this.toneMapped && (n.toneMapped = !1),
									"{}" !== JSON.stringify(this.userData) &&
										(n.userData = this.userData),
									e)
								) {
									const e = i(t.textures),
										r = i(t.images);
									e.length > 0 && (n.textures = e),
										r.length > 0 && (n.images = r);
								}
								return n;
							},
							clone: function () {
								return new this.constructor().copy(this);
							},
							copy: function (t) {
								(this.name = t.name),
									(this.fog = t.fog),
									(this.blending = t.blending),
									(this.side = t.side),
									(this.flatShading = t.flatShading),
									(this.vertexColors = t.vertexColors),
									(this.opacity = t.opacity),
									(this.transparent = t.transparent),
									(this.blendSrc = t.blendSrc),
									(this.blendDst = t.blendDst),
									(this.blendEquation = t.blendEquation),
									(this.blendSrcAlpha = t.blendSrcAlpha),
									(this.blendDstAlpha = t.blendDstAlpha),
									(this.blendEquationAlpha = t.blendEquationAlpha),
									(this.depthFunc = t.depthFunc),
									(this.depthTest = t.depthTest),
									(this.depthWrite = t.depthWrite),
									(this.stencilWriteMask = t.stencilWriteMask),
									(this.stencilFunc = t.stencilFunc),
									(this.stencilRef = t.stencilRef),
									(this.stencilFuncMask = t.stencilFuncMask),
									(this.stencilFail = t.stencilFail),
									(this.stencilZFail = t.stencilZFail),
									(this.stencilZPass = t.stencilZPass),
									(this.stencilWrite = t.stencilWrite);
								const e = t.clippingPlanes;
								let n = null;
								if (null !== e) {
									const t = e.length;
									n = new Array(t);
									for (let i = 0; i !== t; ++i) n[i] = e[i].clone();
								}
								return (
									(this.clippingPlanes = n),
									(this.clipIntersection = t.clipIntersection),
									(this.clipShadows = t.clipShadows),
									(this.shadowSide = t.shadowSide),
									(this.colorWrite = t.colorWrite),
									(this.precision = t.precision),
									(this.polygonOffset = t.polygonOffset),
									(this.polygonOffsetFactor = t.polygonOffsetFactor),
									(this.polygonOffsetUnits = t.polygonOffsetUnits),
									(this.dithering = t.dithering),
									(this.alphaTest = t.alphaTest),
									(this.premultipliedAlpha = t.premultipliedAlpha),
									(this.visible = t.visible),
									(this.toneMapped = t.toneMapped),
									(this.userData = JSON.parse(JSON.stringify(t.userData))),
									this
								);
							},
							dispose: function () {
								this.dispatchEvent({ type: "dispose" });
							},
						})),
							Object.defineProperty(ia.prototype, "needsUpdate", {
								set: function (t) {
									!0 === t && this.version++;
								},
							}),
							(ra.prototype = Object.create(ia.prototype)),
							(ra.prototype.constructor = ra),
							(ra.prototype.isMeshBasicMaterial = !0),
							(ra.prototype.copy = function (t) {
								return (
									ia.prototype.copy.call(this, t),
									this.color.copy(t.color),
									(this.map = t.map),
									(this.lightMap = t.lightMap),
									(this.lightMapIntensity = t.lightMapIntensity),
									(this.aoMap = t.aoMap),
									(this.aoMapIntensity = t.aoMapIntensity),
									(this.specularMap = t.specularMap),
									(this.alphaMap = t.alphaMap),
									(this.envMap = t.envMap),
									(this.combine = t.combine),
									(this.reflectivity = t.reflectivity),
									(this.refractionRatio = t.refractionRatio),
									(this.wireframe = t.wireframe),
									(this.wireframeLinewidth = t.wireframeLinewidth),
									(this.wireframeLinecap = t.wireframeLinecap),
									(this.wireframeLinejoin = t.wireframeLinejoin),
									(this.skinning = t.skinning),
									(this.morphTargets = t.morphTargets),
									this
								);
							});
						const oa = new zr(),
							aa = new Rr();
						function sa(t, e, n) {
							if (Array.isArray(t))
								throw new TypeError(
									"THREE.BufferAttribute: array should be a Typed Array."
								);
							(this.name = ""),
								(this.array = t),
								(this.itemSize = e),
								(this.count = void 0 !== t ? t.length / e : 0),
								(this.normalized = !0 === n),
								(this.usage = fr),
								(this.updateRange = { offset: 0, count: -1 }),
								(this.version = 0);
						}
						function ca(t, e, n) {
							sa.call(this, new Int8Array(t), e, n);
						}
						function la(t, e, n) {
							sa.call(this, new Uint8Array(t), e, n);
						}
						function ha(t, e, n) {
							sa.call(this, new Uint8ClampedArray(t), e, n);
						}
						function pa(t, e, n) {
							sa.call(this, new Int16Array(t), e, n);
						}
						function ua(t, e, n) {
							sa.call(this, new Uint16Array(t), e, n);
						}
						function da(t, e, n) {
							sa.call(this, new Int32Array(t), e, n);
						}
						function ma(t, e, n) {
							sa.call(this, new Uint32Array(t), e, n);
						}
						function fa(t, e, n) {
							sa.call(this, new Float32Array(t), e, n);
						}
						function ga(t, e, n) {
							sa.call(this, new Float64Array(t), e, n);
						}
						function Sa() {
							(this.vertices = []),
								(this.normals = []),
								(this.colors = []),
								(this.uvs = []),
								(this.uvs2 = []),
								(this.groups = []),
								(this.morphTargets = {}),
								(this.skinWeights = []),
								(this.skinIndices = []),
								(this.boundingBox = null),
								(this.boundingSphere = null),
								(this.verticesNeedUpdate = !1),
								(this.normalsNeedUpdate = !1),
								(this.colorsNeedUpdate = !1),
								(this.uvsNeedUpdate = !1),
								(this.groupsNeedUpdate = !1);
						}
						function ya(t) {
							if (0 === t.length) return -1 / 0;
							let e = t[0];
							for (let n = 1, i = t.length; n < i; ++n) t[n] > e && (e = t[n]);
							return e;
						}
						Object.defineProperty(sa.prototype, "needsUpdate", {
							set: function (t) {
								!0 === t && this.version++;
							},
						}),
							Object.assign(sa.prototype, {
								isBufferAttribute: !0,
								onUploadCallback: function () {},
								setUsage: function (t) {
									return (this.usage = t), this;
								},
								copy: function (t) {
									return (
										(this.name = t.name),
										(this.array = new t.array.constructor(t.array)),
										(this.itemSize = t.itemSize),
										(this.count = t.count),
										(this.normalized = t.normalized),
										(this.usage = t.usage),
										this
									);
								},
								copyAt: function (t, e, n) {
									(t *= this.itemSize), (n *= e.itemSize);
									for (let i = 0, r = this.itemSize; i < r; i++)
										this.array[t + i] = e.array[n + i];
									return this;
								},
								copyArray: function (t) {
									return this.array.set(t), this;
								},
								copyColorsArray: function (t) {
									const e = this.array;
									let n = 0;
									for (let i = 0, r = t.length; i < r; i++) {
										let r = t[i];
										void 0 === r &&
											(console.warn(
												"THREE.BufferAttribute.copyColorsArray(): color is undefined",
												i
											),
											(r = new Yo())),
											(e[n++] = r.r),
											(e[n++] = r.g),
											(e[n++] = r.b);
									}
									return this;
								},
								copyVector2sArray: function (t) {
									const e = this.array;
									let n = 0;
									for (let i = 0, r = t.length; i < r; i++) {
										let r = t[i];
										void 0 === r &&
											(console.warn(
												"THREE.BufferAttribute.copyVector2sArray(): vector is undefined",
												i
											),
											(r = new Rr())),
											(e[n++] = r.x),
											(e[n++] = r.y);
									}
									return this;
								},
								copyVector3sArray: function (t) {
									const e = this.array;
									let n = 0;
									for (let i = 0, r = t.length; i < r; i++) {
										let r = t[i];
										void 0 === r &&
											(console.warn(
												"THREE.BufferAttribute.copyVector3sArray(): vector is undefined",
												i
											),
											(r = new zr())),
											(e[n++] = r.x),
											(e[n++] = r.y),
											(e[n++] = r.z);
									}
									return this;
								},
								copyVector4sArray: function (t) {
									const e = this.array;
									let n = 0;
									for (let i = 0, r = t.length; i < r; i++) {
										let r = t[i];
										void 0 === r &&
											(console.warn(
												"THREE.BufferAttribute.copyVector4sArray(): vector is undefined",
												i
											),
											(r = new wr())),
											(e[n++] = r.x),
											(e[n++] = r.y),
											(e[n++] = r.z),
											(e[n++] = r.w);
									}
									return this;
								},
								applyMatrix3: function (t) {
									if (2 === this.itemSize)
										for (let e = 0, n = this.count; e < n; e++)
											aa.fromBufferAttribute(this, e),
												aa.applyMatrix3(t),
												this.setXY(e, aa.x, aa.y);
									else if (3 === this.itemSize)
										for (let e = 0, n = this.count; e < n; e++)
											oa.fromBufferAttribute(this, e),
												oa.applyMatrix3(t),
												this.setXYZ(e, oa.x, oa.y, oa.z);
									return this;
								},
								applyMatrix4: function (t) {
									for (let e = 0, n = this.count; e < n; e++)
										(oa.x = this.getX(e)),
											(oa.y = this.getY(e)),
											(oa.z = this.getZ(e)),
											oa.applyMatrix4(t),
											this.setXYZ(e, oa.x, oa.y, oa.z);
									return this;
								},
								applyNormalMatrix: function (t) {
									for (let e = 0, n = this.count; e < n; e++)
										(oa.x = this.getX(e)),
											(oa.y = this.getY(e)),
											(oa.z = this.getZ(e)),
											oa.applyNormalMatrix(t),
											this.setXYZ(e, oa.x, oa.y, oa.z);
									return this;
								},
								transformDirection: function (t) {
									for (let e = 0, n = this.count; e < n; e++)
										(oa.x = this.getX(e)),
											(oa.y = this.getY(e)),
											(oa.z = this.getZ(e)),
											oa.transformDirection(t),
											this.setXYZ(e, oa.x, oa.y, oa.z);
									return this;
								},
								set: function (t, e) {
									return void 0 === e && (e = 0), this.array.set(t, e), this;
								},
								getX: function (t) {
									return this.array[t * this.itemSize];
								},
								setX: function (t, e) {
									return (this.array[t * this.itemSize] = e), this;
								},
								getY: function (t) {
									return this.array[t * this.itemSize + 1];
								},
								setY: function (t, e) {
									return (this.array[t * this.itemSize + 1] = e), this;
								},
								getZ: function (t) {
									return this.array[t * this.itemSize + 2];
								},
								setZ: function (t, e) {
									return (this.array[t * this.itemSize + 2] = e), this;
								},
								getW: function (t) {
									return this.array[t * this.itemSize + 3];
								},
								setW: function (t, e) {
									return (this.array[t * this.itemSize + 3] = e), this;
								},
								setXY: function (t, e, n) {
									return (
										(t *= this.itemSize),
										(this.array[t + 0] = e),
										(this.array[t + 1] = n),
										this
									);
								},
								setXYZ: function (t, e, n, i) {
									return (
										(t *= this.itemSize),
										(this.array[t + 0] = e),
										(this.array[t + 1] = n),
										(this.array[t + 2] = i),
										this
									);
								},
								setXYZW: function (t, e, n, i, r) {
									return (
										(t *= this.itemSize),
										(this.array[t + 0] = e),
										(this.array[t + 1] = n),
										(this.array[t + 2] = i),
										(this.array[t + 3] = r),
										this
									);
								},
								onUpload: function (t) {
									return (this.onUploadCallback = t), this;
								},
								clone: function () {
									return new this.constructor(this.array, this.itemSize).copy(
										this
									);
								},
								toJSON: function () {
									return {
										itemSize: this.itemSize,
										type: this.array.constructor.name,
										array: Array.prototype.slice.call(this.array),
										normalized: this.normalized,
									};
								},
							}),
							(ca.prototype = Object.create(sa.prototype)),
							(ca.prototype.constructor = ca),
							(la.prototype = Object.create(sa.prototype)),
							(la.prototype.constructor = la),
							(ha.prototype = Object.create(sa.prototype)),
							(ha.prototype.constructor = ha),
							(pa.prototype = Object.create(sa.prototype)),
							(pa.prototype.constructor = pa),
							(ua.prototype = Object.create(sa.prototype)),
							(ua.prototype.constructor = ua),
							(da.prototype = Object.create(sa.prototype)),
							(da.prototype.constructor = da),
							(ma.prototype = Object.create(sa.prototype)),
							(ma.prototype.constructor = ma),
							(fa.prototype = Object.create(sa.prototype)),
							(fa.prototype.constructor = fa),
							(ga.prototype = Object.create(sa.prototype)),
							(ga.prototype.constructor = ga),
							Object.assign(Sa.prototype, {
								computeGroups: function (t) {
									const e = [];
									let n, i, r;
									const o = t.faces;
									for (i = 0; i < o.length; i++) {
										const t = o[i];
										t.materialIndex !== r &&
											((r = t.materialIndex),
											void 0 !== n && ((n.count = 3 * i - n.start), e.push(n)),
											(n = { start: 3 * i, materialIndex: r }));
									}
									void 0 !== n && ((n.count = 3 * i - n.start), e.push(n)),
										(this.groups = e);
								},
								fromGeometry: function (t) {
									const e = t.faces,
										n = t.vertices,
										i = t.faceVertexUvs,
										r = i[0] && i[0].length > 0,
										o = i[1] && i[1].length > 0,
										a = t.morphTargets,
										s = a.length;
									let c;
									if (s > 0) {
										c = [];
										for (let t = 0; t < s; t++)
											c[t] = { name: a[t].name, data: [] };
										this.morphTargets.position = c;
									}
									const l = t.morphNormals,
										h = l.length;
									let p;
									if (h > 0) {
										p = [];
										for (let t = 0; t < h; t++)
											p[t] = { name: l[t].name, data: [] };
										this.morphTargets.normal = p;
									}
									const u = t.skinIndices,
										d = t.skinWeights,
										m = u.length === n.length,
										f = d.length === n.length;
									n.length > 0 &&
										0 === e.length &&
										console.error(
											"THREE.DirectGeometry: Faceless geometries are not supported."
										);
									for (let t = 0; t < e.length; t++) {
										const g = e[t];
										this.vertices.push(n[g.a], n[g.b], n[g.c]);
										const S = g.vertexNormals;
										if (3 === S.length) this.normals.push(S[0], S[1], S[2]);
										else {
											const t = g.normal;
											this.normals.push(t, t, t);
										}
										const y = g.vertexColors;
										if (3 === y.length) this.colors.push(y[0], y[1], y[2]);
										else {
											const t = g.color;
											this.colors.push(t, t, t);
										}
										if (!0 === r) {
											const e = i[0][t];
											void 0 !== e
												? this.uvs.push(e[0], e[1], e[2])
												: (console.warn(
														"THREE.DirectGeometry.fromGeometry(): Undefined vertexUv ",
														t
												  ),
												  this.uvs.push(new Rr(), new Rr(), new Rr()));
										}
										if (!0 === o) {
											const e = i[1][t];
											void 0 !== e
												? this.uvs2.push(e[0], e[1], e[2])
												: (console.warn(
														"THREE.DirectGeometry.fromGeometry(): Undefined vertexUv2 ",
														t
												  ),
												  this.uvs2.push(new Rr(), new Rr(), new Rr()));
										}
										for (let t = 0; t < s; t++) {
											const e = a[t].vertices;
											c[t].data.push(e[g.a], e[g.b], e[g.c]);
										}
										for (let e = 0; e < h; e++) {
											const n = l[e].vertexNormals[t];
											p[e].data.push(n.a, n.b, n.c);
										}
										m && this.skinIndices.push(u[g.a], u[g.b], u[g.c]),
											f && this.skinWeights.push(d[g.a], d[g.b], d[g.c]);
									}
									return (
										this.computeGroups(t),
										(this.verticesNeedUpdate = t.verticesNeedUpdate),
										(this.normalsNeedUpdate = t.normalsNeedUpdate),
										(this.colorsNeedUpdate = t.colorsNeedUpdate),
										(this.uvsNeedUpdate = t.uvsNeedUpdate),
										(this.groupsNeedUpdate = t.groupsNeedUpdate),
										null !== t.boundingSphere &&
											(this.boundingSphere = t.boundingSphere.clone()),
										null !== t.boundingBox &&
											(this.boundingBox = t.boundingBox.clone()),
										this
									);
								},
							});
						let Va = 1;
						const qa = new jr(),
							Ra = new oo(),
							Ma = new zr(),
							Ia = new Ro(),
							va = new Ro(),
							ka = new zr();
						function Ua() {
							Object.defineProperty(this, "id", { value: (Va += 2) }),
								(this.uuid = qr.generateUUID()),
								(this.name = ""),
								(this.type = "BufferGeometry"),
								(this.index = null),
								(this.attributes = {}),
								(this.morphAttributes = {}),
								(this.morphTargetsRelative = !1),
								(this.groups = []),
								(this.boundingBox = null),
								(this.boundingSphere = null),
								(this.drawRange = { start: 0, count: 1 / 0 }),
								(this.userData = {});
						}
						Ua.prototype = Object.assign(Object.create(Sr.prototype), {
							constructor: Ua,
							isBufferGeometry: !0,
							getIndex: function () {
								return this.index;
							},
							setIndex: function (t) {
								Array.isArray(t)
									? (this.index = new (ya(t) > 65535 ? ma : ua)(t, 1))
									: (this.index = t);
							},
							getAttribute: function (t) {
								return this.attributes[t];
							},
							setAttribute: function (t, e) {
								return (this.attributes[t] = e), this;
							},
							deleteAttribute: function (t) {
								return delete this.attributes[t], this;
							},
							addGroup: function (t, e, n) {
								this.groups.push({
									start: t,
									count: e,
									materialIndex: void 0 !== n ? n : 0,
								});
							},
							clearGroups: function () {
								this.groups = [];
							},
							setDrawRange: function (t, e) {
								(this.drawRange.start = t), (this.drawRange.count = e);
							},
							applyMatrix4: function (t) {
								const e = this.attributes.position;
								void 0 !== e && (e.applyMatrix4(t), (e.needsUpdate = !0));
								const n = this.attributes.normal;
								if (void 0 !== n) {
									const e = new Mr().getNormalMatrix(t);
									n.applyNormalMatrix(e), (n.needsUpdate = !0);
								}
								const i = this.attributes.tangent;
								return (
									void 0 !== i &&
										(i.transformDirection(t), (i.needsUpdate = !0)),
									null !== this.boundingBox && this.computeBoundingBox(),
									null !== this.boundingSphere && this.computeBoundingSphere(),
									this
								);
							},
							rotateX: function (t) {
								return qa.makeRotationX(t), this.applyMatrix4(qa), this;
							},
							rotateY: function (t) {
								return qa.makeRotationY(t), this.applyMatrix4(qa), this;
							},
							rotateZ: function (t) {
								return qa.makeRotationZ(t), this.applyMatrix4(qa), this;
							},
							translate: function (t, e, n) {
								return qa.makeTranslation(t, e, n), this.applyMatrix4(qa), this;
							},
							scale: function (t, e, n) {
								return qa.makeScale(t, e, n), this.applyMatrix4(qa), this;
							},
							lookAt: function (t) {
								return (
									Ra.lookAt(t),
									Ra.updateMatrix(),
									this.applyMatrix4(Ra.matrix),
									this
								);
							},
							center: function () {
								return (
									this.computeBoundingBox(),
									this.boundingBox.getCenter(Ma).negate(),
									this.translate(Ma.x, Ma.y, Ma.z),
									this
								);
							},
							setFromObject: function (t) {
								const e = t.geometry;
								if (t.isPoints || t.isLine) {
									const t = new fa(3 * e.vertices.length, 3),
										n = new fa(3 * e.colors.length, 3);
									if (
										(this.setAttribute(
											"position",
											t.copyVector3sArray(e.vertices)
										),
										this.setAttribute("color", n.copyColorsArray(e.colors)),
										e.lineDistances &&
											e.lineDistances.length === e.vertices.length)
									) {
										const t = new fa(e.lineDistances.length, 1);
										this.setAttribute(
											"lineDistance",
											t.copyArray(e.lineDistances)
										);
									}
									null !== e.boundingSphere &&
										(this.boundingSphere = e.boundingSphere.clone()),
										null !== e.boundingBox &&
											(this.boundingBox = e.boundingBox.clone());
								} else t.isMesh && e && e.isGeometry && this.fromGeometry(e);
								return this;
							},
							setFromPoints: function (t) {
								const e = [];
								for (let n = 0, i = t.length; n < i; n++) {
									const i = t[n];
									e.push(i.x, i.y, i.z || 0);
								}
								return this.setAttribute("position", new fa(e, 3)), this;
							},
							updateFromObject: function (t) {
								let e = t.geometry;
								if (t.isMesh) {
									let t = e.__directGeometry;
									if (
										(!0 === e.elementsNeedUpdate &&
											((t = void 0), (e.elementsNeedUpdate = !1)),
										void 0 === t)
									)
										return this.fromGeometry(e);
									(t.verticesNeedUpdate = e.verticesNeedUpdate),
										(t.normalsNeedUpdate = e.normalsNeedUpdate),
										(t.colorsNeedUpdate = e.colorsNeedUpdate),
										(t.uvsNeedUpdate = e.uvsNeedUpdate),
										(t.groupsNeedUpdate = e.groupsNeedUpdate),
										(e.verticesNeedUpdate = !1),
										(e.normalsNeedUpdate = !1),
										(e.colorsNeedUpdate = !1),
										(e.uvsNeedUpdate = !1),
										(e.groupsNeedUpdate = !1),
										(e = t);
								}
								if (!0 === e.verticesNeedUpdate) {
									const t = this.attributes.position;
									void 0 !== t &&
										(t.copyVector3sArray(e.vertices), (t.needsUpdate = !0)),
										(e.verticesNeedUpdate = !1);
								}
								if (!0 === e.normalsNeedUpdate) {
									const t = this.attributes.normal;
									void 0 !== t &&
										(t.copyVector3sArray(e.normals), (t.needsUpdate = !0)),
										(e.normalsNeedUpdate = !1);
								}
								if (!0 === e.colorsNeedUpdate) {
									const t = this.attributes.color;
									void 0 !== t &&
										(t.copyColorsArray(e.colors), (t.needsUpdate = !0)),
										(e.colorsNeedUpdate = !1);
								}
								if (e.uvsNeedUpdate) {
									const t = this.attributes.uv;
									void 0 !== t &&
										(t.copyVector2sArray(e.uvs), (t.needsUpdate = !0)),
										(e.uvsNeedUpdate = !1);
								}
								if (e.lineDistancesNeedUpdate) {
									const t = this.attributes.lineDistance;
									void 0 !== t &&
										(t.copyArray(e.lineDistances), (t.needsUpdate = !0)),
										(e.lineDistancesNeedUpdate = !1);
								}
								return (
									e.groupsNeedUpdate &&
										(e.computeGroups(t.geometry),
										(this.groups = e.groups),
										(e.groupsNeedUpdate = !1)),
									this
								);
							},
							fromGeometry: function (t) {
								return (
									(t.__directGeometry = new Sa().fromGeometry(t)),
									this.fromDirectGeometry(t.__directGeometry)
								);
							},
							fromDirectGeometry: function (t) {
								const e = new Float32Array(3 * t.vertices.length);
								if (
									(this.setAttribute(
										"position",
										new sa(e, 3).copyVector3sArray(t.vertices)
									),
									t.normals.length > 0)
								) {
									const e = new Float32Array(3 * t.normals.length);
									this.setAttribute(
										"normal",
										new sa(e, 3).copyVector3sArray(t.normals)
									);
								}
								if (t.colors.length > 0) {
									const e = new Float32Array(3 * t.colors.length);
									this.setAttribute(
										"color",
										new sa(e, 3).copyColorsArray(t.colors)
									);
								}
								if (t.uvs.length > 0) {
									const e = new Float32Array(2 * t.uvs.length);
									this.setAttribute(
										"uv",
										new sa(e, 2).copyVector2sArray(t.uvs)
									);
								}
								if (t.uvs2.length > 0) {
									const e = new Float32Array(2 * t.uvs2.length);
									this.setAttribute(
										"uv2",
										new sa(e, 2).copyVector2sArray(t.uvs2)
									);
								}
								this.groups = t.groups;
								for (const e in t.morphTargets) {
									const n = [],
										i = t.morphTargets[e];
									for (let t = 0, e = i.length; t < e; t++) {
										const e = i[t],
											r = new fa(3 * e.data.length, 3);
										(r.name = e.name), n.push(r.copyVector3sArray(e.data));
									}
									this.morphAttributes[e] = n;
								}
								if (t.skinIndices.length > 0) {
									const e = new fa(4 * t.skinIndices.length, 4);
									this.setAttribute(
										"skinIndex",
										e.copyVector4sArray(t.skinIndices)
									);
								}
								if (t.skinWeights.length > 0) {
									const e = new fa(4 * t.skinWeights.length, 4);
									this.setAttribute(
										"skinWeight",
										e.copyVector4sArray(t.skinWeights)
									);
								}
								return (
									null !== t.boundingSphere &&
										(this.boundingSphere = t.boundingSphere.clone()),
									null !== t.boundingBox &&
										(this.boundingBox = t.boundingBox.clone()),
									this
								);
							},
							computeBoundingBox: function () {
								null === this.boundingBox && (this.boundingBox = new Ro());
								const t = this.attributes.position,
									e = this.morphAttributes.position;
								if (void 0 !== t) {
									if ((this.boundingBox.setFromBufferAttribute(t), e))
										for (let t = 0, n = e.length; t < n; t++) {
											const n = e[t];
											Ia.setFromBufferAttribute(n),
												this.morphTargetsRelative
													? (ka.addVectors(this.boundingBox.min, Ia.min),
													  this.boundingBox.expandByPoint(ka),
													  ka.addVectors(this.boundingBox.max, Ia.max),
													  this.boundingBox.expandByPoint(ka))
													: (this.boundingBox.expandByPoint(Ia.min),
													  this.boundingBox.expandByPoint(Ia.max));
										}
								} else this.boundingBox.makeEmpty();
								(isNaN(this.boundingBox.min.x) ||
									isNaN(this.boundingBox.min.y) ||
									isNaN(this.boundingBox.min.z)) &&
									console.error(
										'THREE.BufferGeometry.computeBoundingBox: Computed min/max have NaN values. The "position" attribute is likely to have NaN values.',
										this
									);
							},
							computeBoundingSphere: function () {
								null === this.boundingSphere &&
									(this.boundingSphere = new vo());
								const t = this.attributes.position,
									e = this.morphAttributes.position;
								if (t) {
									const n = this.boundingSphere.center;
									if ((Ia.setFromBufferAttribute(t), e))
										for (let t = 0, n = e.length; t < n; t++) {
											const n = e[t];
											va.setFromBufferAttribute(n),
												this.morphTargetsRelative
													? (ka.addVectors(Ia.min, va.min),
													  Ia.expandByPoint(ka),
													  ka.addVectors(Ia.max, va.max),
													  Ia.expandByPoint(ka))
													: (Ia.expandByPoint(va.min),
													  Ia.expandByPoint(va.max));
										}
									Ia.getCenter(n);
									let i = 0;
									for (let e = 0, r = t.count; e < r; e++)
										ka.fromBufferAttribute(t, e),
											(i = Math.max(i, n.distanceToSquared(ka)));
									if (e)
										for (let r = 0, o = e.length; r < o; r++) {
											const o = e[r],
												a = this.morphTargetsRelative;
											for (let e = 0, r = o.count; e < r; e++)
												ka.fromBufferAttribute(o, e),
													a && (Ma.fromBufferAttribute(t, e), ka.add(Ma)),
													(i = Math.max(i, n.distanceToSquared(ka)));
										}
									(this.boundingSphere.radius = Math.sqrt(i)),
										isNaN(this.boundingSphere.radius) &&
											console.error(
												'THREE.BufferGeometry.computeBoundingSphere(): Computed radius is NaN. The "position" attribute is likely to have NaN values.',
												this
											);
								}
							},
							computeFaceNormals: function () {},
							computeVertexNormals: function () {
								const t = this.index,
									e = this.getAttribute("position");
								if (void 0 !== e) {
									let n = this.getAttribute("normal");
									if (void 0 === n)
										(n = new sa(new Float32Array(3 * e.count), 3)),
											this.setAttribute("normal", n);
									else
										for (let t = 0, e = n.count; t < e; t++)
											n.setXYZ(t, 0, 0, 0);
									const i = new zr(),
										r = new zr(),
										o = new zr(),
										a = new zr(),
										s = new zr(),
										c = new zr(),
										l = new zr(),
										h = new zr();
									if (t)
										for (let p = 0, u = t.count; p < u; p += 3) {
											const u = t.getX(p + 0),
												d = t.getX(p + 1),
												m = t.getX(p + 2);
											i.fromBufferAttribute(e, u),
												r.fromBufferAttribute(e, d),
												o.fromBufferAttribute(e, m),
												l.subVectors(o, r),
												h.subVectors(i, r),
												l.cross(h),
												a.fromBufferAttribute(n, u),
												s.fromBufferAttribute(n, d),
												c.fromBufferAttribute(n, m),
												a.add(l),
												s.add(l),
												c.add(l),
												n.setXYZ(u, a.x, a.y, a.z),
												n.setXYZ(d, s.x, s.y, s.z),
												n.setXYZ(m, c.x, c.y, c.z);
										}
									else
										for (let t = 0, a = e.count; t < a; t += 3)
											i.fromBufferAttribute(e, t + 0),
												r.fromBufferAttribute(e, t + 1),
												o.fromBufferAttribute(e, t + 2),
												l.subVectors(o, r),
												h.subVectors(i, r),
												l.cross(h),
												n.setXYZ(t + 0, l.x, l.y, l.z),
												n.setXYZ(t + 1, l.x, l.y, l.z),
												n.setXYZ(t + 2, l.x, l.y, l.z);
									this.normalizeNormals(), (n.needsUpdate = !0);
								}
							},
							merge: function (t, e) {
								if (!t || !t.isBufferGeometry)
									return void console.error(
										"THREE.BufferGeometry.merge(): geometry not an instance of THREE.BufferGeometry.",
										t
									);
								void 0 === e &&
									((e = 0),
									console.warn(
										"THREE.BufferGeometry.merge(): Overwriting original geometry, starting at offset=0. Use BufferGeometryUtils.mergeBufferGeometries() for lossless merge."
									));
								const n = this.attributes;
								for (const i in n) {
									if (void 0 === t.attributes[i]) continue;
									const r = n[i].array,
										o = t.attributes[i],
										a = o.array,
										s = o.itemSize * e,
										c = Math.min(a.length, r.length - s);
									for (let t = 0, e = s; t < c; t++, e++) r[e] = a[t];
								}
								return this;
							},
							normalizeNormals: function () {
								const t = this.attributes.normal;
								for (let e = 0, n = t.count; e < n; e++)
									ka.fromBufferAttribute(t, e),
										ka.normalize(),
										t.setXYZ(e, ka.x, ka.y, ka.z);
							},
							toNonIndexed: function () {
								function t(t, e) {
									const n = t.array,
										i = t.itemSize,
										r = t.normalized,
										o = new n.constructor(e.length * i);
									let a = 0,
										s = 0;
									for (let t = 0, r = e.length; t < r; t++) {
										a = e[t] * i;
										for (let t = 0; t < i; t++) o[s++] = n[a++];
									}
									return new sa(o, i, r);
								}
								if (null === this.index)
									return (
										console.warn(
											"THREE.BufferGeometry.toNonIndexed(): Geometry is already non-indexed."
										),
										this
									);
								const e = new Ua(),
									n = this.index.array,
									i = this.attributes;
								for (const r in i) {
									const o = t(i[r], n);
									e.setAttribute(r, o);
								}
								const r = this.morphAttributes;
								for (const i in r) {
									const o = [],
										a = r[i];
									for (let e = 0, i = a.length; e < i; e++) {
										const i = t(a[e], n);
										o.push(i);
									}
									e.morphAttributes[i] = o;
								}
								e.morphTargetsRelative = this.morphTargetsRelative;
								const o = this.groups;
								for (let t = 0, n = o.length; t < n; t++) {
									const n = o[t];
									e.addGroup(n.start, n.count, n.materialIndex);
								}
								return e;
							},
							toJSON: function () {
								const t = {
									metadata: {
										version: 4.5,
										type: "BufferGeometry",
										generator: "BufferGeometry.toJSON",
									},
								};
								if (
									((t.uuid = this.uuid),
									(t.type = this.type),
									"" !== this.name && (t.name = this.name),
									Object.keys(this.userData).length > 0 &&
										(t.userData = this.userData),
									void 0 !== this.parameters)
								) {
									const e = this.parameters;
									for (const n in e) void 0 !== e[n] && (t[n] = e[n]);
									return t;
								}
								t.data = { attributes: {} };
								const e = this.index;
								null !== e &&
									(t.data.index = {
										type: e.array.constructor.name,
										array: Array.prototype.slice.call(e.array),
									});
								const n = this.attributes;
								for (const e in n) {
									const i = n[e],
										r = i.toJSON(t.data);
									"" !== i.name && (r.name = i.name),
										(t.data.attributes[e] = r);
								}
								const i = {};
								let r = !1;
								for (const e in this.morphAttributes) {
									const n = this.morphAttributes[e],
										o = [];
									for (let e = 0, i = n.length; e < i; e++) {
										const i = n[e],
											r = i.toJSON(t.data);
										"" !== i.name && (r.name = i.name), o.push(r);
									}
									o.length > 0 && ((i[e] = o), (r = !0));
								}
								r &&
									((t.data.morphAttributes = i),
									(t.data.morphTargetsRelative = this.morphTargetsRelative));
								const o = this.groups;
								o.length > 0 && (t.data.groups = JSON.parse(JSON.stringify(o)));
								const a = this.boundingSphere;
								return (
									null !== a &&
										(t.data.boundingSphere = {
											center: a.center.toArray(),
											radius: a.radius,
										}),
									t
								);
							},
							clone: function () {
								return new Ua().copy(this);
							},
							copy: function (t) {
								(this.index = null),
									(this.attributes = {}),
									(this.morphAttributes = {}),
									(this.groups = []),
									(this.boundingBox = null),
									(this.boundingSphere = null);
								const e = {};
								this.name = t.name;
								const n = t.index;
								null !== n && this.setIndex(n.clone(e));
								const i = t.attributes;
								for (const t in i) {
									const n = i[t];
									this.setAttribute(t, n.clone(e));
								}
								const r = t.morphAttributes;
								for (const t in r) {
									const n = [],
										i = r[t];
									for (let t = 0, r = i.length; t < r; t++)
										n.push(i[t].clone(e));
									this.morphAttributes[t] = n;
								}
								this.morphTargetsRelative = t.morphTargetsRelative;
								const o = t.groups;
								for (let t = 0, e = o.length; t < e; t++) {
									const e = o[t];
									this.addGroup(e.start, e.count, e.materialIndex);
								}
								const a = t.boundingBox;
								null !== a && (this.boundingBox = a.clone());
								const s = t.boundingSphere;
								return (
									null !== s && (this.boundingSphere = s.clone()),
									(this.drawRange.start = t.drawRange.start),
									(this.drawRange.count = t.drawRange.count),
									(this.userData = t.userData),
									this
								);
							},
							dispose: function () {
								this.dispatchEvent({ type: "dispose" });
							},
						});
						const wa = new jr(),
							xa = new To(),
							Oa = new vo(),
							ba = new zr(),
							Ka = new zr(),
							Ta = new zr(),
							za = new zr(),
							Wa = new zr(),
							Ea = new zr(),
							Ca = new zr(),
							Fa = new zr(),
							Za = new zr(),
							Ha = new Rr(),
							Na = new Rr(),
							ja = new Rr(),
							Da = new zr(),
							Aa = new zr();
						function La(t, e) {
							oo.call(this),
								(this.type = "Mesh"),
								(this.geometry = void 0 !== t ? t : new Ua()),
								(this.material = void 0 !== e ? e : new ra()),
								this.updateMorphTargets();
						}
						function Ba(t, e, n, i, r, o, a, s) {
							let c;
							if (
								((c =
									1 === e.side
										? i.intersectTriangle(a, o, r, !0, s)
										: i.intersectTriangle(r, o, a, 2 !== e.side, s)),
								null === c)
							)
								return null;
							Aa.copy(s), Aa.applyMatrix4(t.matrixWorld);
							const l = n.ray.origin.distanceTo(Aa);
							return l < n.near || l > n.far
								? null
								: { distance: l, point: Aa.clone(), object: t };
						}
						function Ga(t, e, n, i, r, o, a, s, c, l, h, p) {
							ba.fromBufferAttribute(r, l),
								Ka.fromBufferAttribute(r, h),
								Ta.fromBufferAttribute(r, p);
							const u = t.morphTargetInfluences;
							if (e.morphTargets && o && u) {
								Ca.set(0, 0, 0), Fa.set(0, 0, 0), Za.set(0, 0, 0);
								for (let t = 0, e = o.length; t < e; t++) {
									const e = u[t],
										n = o[t];
									0 !== e &&
										(za.fromBufferAttribute(n, l),
										Wa.fromBufferAttribute(n, h),
										Ea.fromBufferAttribute(n, p),
										a
											? (Ca.addScaledVector(za, e),
											  Fa.addScaledVector(Wa, e),
											  Za.addScaledVector(Ea, e))
											: (Ca.addScaledVector(za.sub(ba), e),
											  Fa.addScaledVector(Wa.sub(Ka), e),
											  Za.addScaledVector(Ea.sub(Ta), e)));
								}
								ba.add(Ca), Ka.add(Fa), Ta.add(Za);
							}
							t.isSkinnedMesh &&
								(t.boneTransform(l, ba),
								t.boneTransform(h, Ka),
								t.boneTransform(p, Ta));
							const d = Ba(t, e, n, i, ba, Ka, Ta, Da);
							if (d) {
								s &&
									(Ha.fromBufferAttribute(s, l),
									Na.fromBufferAttribute(s, h),
									ja.fromBufferAttribute(s, p),
									(d.uv = Qo.getUV(Da, ba, Ka, Ta, Ha, Na, ja, new Rr()))),
									c &&
										(Ha.fromBufferAttribute(c, l),
										Na.fromBufferAttribute(c, h),
										ja.fromBufferAttribute(c, p),
										(d.uv2 = Qo.getUV(Da, ba, Ka, Ta, Ha, Na, ja, new Rr())));
								const t = new ea(l, h, p);
								Qo.getNormal(ba, Ka, Ta, t.normal), (d.face = t);
							}
							return d;
						}
						La.prototype = Object.assign(Object.create(oo.prototype), {
							constructor: La,
							isMesh: !0,
							copy: function (t) {
								return (
									oo.prototype.copy.call(this, t),
									void 0 !== t.morphTargetInfluences &&
										(this.morphTargetInfluences =
											t.morphTargetInfluences.slice()),
									void 0 !== t.morphTargetDictionary &&
										(this.morphTargetDictionary = Object.assign(
											{},
											t.morphTargetDictionary
										)),
									(this.material = t.material),
									(this.geometry = t.geometry),
									this
								);
							},
							updateMorphTargets: function () {
								const t = this.geometry;
								if (t.isBufferGeometry) {
									const e = t.morphAttributes,
										n = Object.keys(e);
									if (n.length > 0) {
										const t = e[n[0]];
										if (void 0 !== t) {
											(this.morphTargetInfluences = []),
												(this.morphTargetDictionary = {});
											for (let e = 0, n = t.length; e < n; e++) {
												const n = t[e].name || String(e);
												this.morphTargetInfluences.push(0),
													(this.morphTargetDictionary[n] = e);
											}
										}
									}
								} else {
									const e = t.morphTargets;
									void 0 !== e &&
										e.length > 0 &&
										console.error(
											"THREE.Mesh.updateMorphTargets() no longer supports THREE.Geometry. Use THREE.BufferGeometry instead."
										);
								}
							},
							raycast: function (t, e) {
								const n = this.geometry,
									i = this.material,
									r = this.matrixWorld;
								if (void 0 === i) return;
								if (
									(null === n.boundingSphere && n.computeBoundingSphere(),
									Oa.copy(n.boundingSphere),
									Oa.applyMatrix4(r),
									!1 === t.ray.intersectsSphere(Oa))
								)
									return;
								if (
									(wa.getInverse(r),
									xa.copy(t.ray).applyMatrix4(wa),
									null !== n.boundingBox &&
										!1 === xa.intersectsBox(n.boundingBox))
								)
									return;
								let o;
								if (n.isBufferGeometry) {
									const r = n.index,
										a = n.attributes.position,
										s = n.morphAttributes.position,
										c = n.morphTargetsRelative,
										l = n.attributes.uv,
										h = n.attributes.uv2,
										p = n.groups,
										u = n.drawRange;
									if (null !== r)
										if (Array.isArray(i))
											for (let n = 0, d = p.length; n < d; n++) {
												const d = p[n],
													m = i[d.materialIndex];
												for (
													let n = Math.max(d.start, u.start),
														i = Math.min(d.start + d.count, u.start + u.count);
													n < i;
													n += 3
												) {
													const i = r.getX(n),
														p = r.getX(n + 1),
														u = r.getX(n + 2);
													(o = Ga(this, m, t, xa, a, s, c, l, h, i, p, u)),
														o &&
															((o.faceIndex = Math.floor(n / 3)),
															(o.face.materialIndex = d.materialIndex),
															e.push(o));
												}
											}
										else
											for (
												let n = Math.max(0, u.start),
													p = Math.min(r.count, u.start + u.count);
												n < p;
												n += 3
											) {
												const p = r.getX(n),
													u = r.getX(n + 1),
													d = r.getX(n + 2);
												(o = Ga(this, i, t, xa, a, s, c, l, h, p, u, d)),
													o && ((o.faceIndex = Math.floor(n / 3)), e.push(o));
											}
									else if (void 0 !== a)
										if (Array.isArray(i))
											for (let n = 0, r = p.length; n < r; n++) {
												const r = p[n],
													d = i[r.materialIndex];
												for (
													let n = Math.max(r.start, u.start),
														i = Math.min(r.start + r.count, u.start + u.count);
													n < i;
													n += 3
												)
													(o = Ga(
														this,
														d,
														t,
														xa,
														a,
														s,
														c,
														l,
														h,
														n,
														n + 1,
														n + 2
													)),
														o &&
															((o.faceIndex = Math.floor(n / 3)),
															(o.face.materialIndex = r.materialIndex),
															e.push(o));
											}
										else
											for (
												let n = Math.max(0, u.start),
													r = Math.min(a.count, u.start + u.count);
												n < r;
												n += 3
											)
												(o = Ga(
													this,
													i,
													t,
													xa,
													a,
													s,
													c,
													l,
													h,
													n,
													n + 1,
													n + 2
												)),
													o && ((o.faceIndex = Math.floor(n / 3)), e.push(o));
								} else if (n.isGeometry) {
									const r = Array.isArray(i),
										a = n.vertices,
										s = n.faces;
									let c;
									const l = n.faceVertexUvs[0];
									l.length > 0 && (c = l);
									for (let n = 0, l = s.length; n < l; n++) {
										const l = s[n],
											h = r ? i[l.materialIndex] : i;
										if (void 0 === h) continue;
										const p = a[l.a],
											u = a[l.b],
											d = a[l.c];
										if (((o = Ba(this, h, t, xa, p, u, d, Da)), o)) {
											if (c && c[n]) {
												const t = c[n];
												Ha.copy(t[0]),
													Na.copy(t[1]),
													ja.copy(t[2]),
													(o.uv = Qo.getUV(Da, p, u, d, Ha, Na, ja, new Rr()));
											}
											(o.face = l), (o.faceIndex = n), e.push(o);
										}
									}
								}
							},
						});
						let Qa = 0;
						const _a = new jr(),
							Pa = new oo(),
							Ja = new zr();
						function Ya() {
							Object.defineProperty(this, "id", { value: (Qa += 2) }),
								(this.uuid = qr.generateUUID()),
								(this.name = ""),
								(this.type = "Geometry"),
								(this.vertices = []),
								(this.colors = []),
								(this.faces = []),
								(this.faceVertexUvs = [[]]),
								(this.morphTargets = []),
								(this.morphNormals = []),
								(this.skinWeights = []),
								(this.skinIndices = []),
								(this.lineDistances = []),
								(this.boundingBox = null),
								(this.boundingSphere = null),
								(this.elementsNeedUpdate = !1),
								(this.verticesNeedUpdate = !1),
								(this.uvsNeedUpdate = !1),
								(this.normalsNeedUpdate = !1),
								(this.colorsNeedUpdate = !1),
								(this.lineDistancesNeedUpdate = !1),
								(this.groupsNeedUpdate = !1);
						}
						Ya.prototype = Object.assign(Object.create(Sr.prototype), {
							constructor: Ya,
							isGeometry: !0,
							applyMatrix4: function (t) {
								const e = new Mr().getNormalMatrix(t);
								for (let e = 0, n = this.vertices.length; e < n; e++)
									this.vertices[e].applyMatrix4(t);
								for (let t = 0, n = this.faces.length; t < n; t++) {
									const n = this.faces[t];
									n.normal.applyMatrix3(e).normalize();
									for (let t = 0, i = n.vertexNormals.length; t < i; t++)
										n.vertexNormals[t].applyMatrix3(e).normalize();
								}
								return (
									null !== this.boundingBox && this.computeBoundingBox(),
									null !== this.boundingSphere && this.computeBoundingSphere(),
									(this.verticesNeedUpdate = !0),
									(this.normalsNeedUpdate = !0),
									this
								);
							},
							rotateX: function (t) {
								return _a.makeRotationX(t), this.applyMatrix4(_a), this;
							},
							rotateY: function (t) {
								return _a.makeRotationY(t), this.applyMatrix4(_a), this;
							},
							rotateZ: function (t) {
								return _a.makeRotationZ(t), this.applyMatrix4(_a), this;
							},
							translate: function (t, e, n) {
								return _a.makeTranslation(t, e, n), this.applyMatrix4(_a), this;
							},
							scale: function (t, e, n) {
								return _a.makeScale(t, e, n), this.applyMatrix4(_a), this;
							},
							lookAt: function (t) {
								return (
									Pa.lookAt(t),
									Pa.updateMatrix(),
									this.applyMatrix4(Pa.matrix),
									this
								);
							},
							fromBufferGeometry: function (t) {
								const e = this,
									n = null !== t.index ? t.index : void 0,
									i = t.attributes;
								if (void 0 === i.position)
									return (
										console.error(
											"THREE.Geometry.fromBufferGeometry(): Position attribute required for conversion."
										),
										this
									);
								const r = i.position,
									o = i.normal,
									a = i.color,
									s = i.uv,
									c = i.uv2;
								void 0 !== c && (this.faceVertexUvs[1] = []);
								for (let t = 0; t < r.count; t++)
									e.vertices.push(new zr().fromBufferAttribute(r, t)),
										void 0 !== a &&
											e.colors.push(new Yo().fromBufferAttribute(a, t));
								function l(t, n, i, r) {
									const l =
											void 0 === a
												? []
												: [
														e.colors[t].clone(),
														e.colors[n].clone(),
														e.colors[i].clone(),
												  ],
										h = new ea(
											t,
											n,
											i,
											void 0 === o
												? []
												: [
														new zr().fromBufferAttribute(o, t),
														new zr().fromBufferAttribute(o, n),
														new zr().fromBufferAttribute(o, i),
												  ],
											l,
											r
										);
									e.faces.push(h),
										void 0 !== s &&
											e.faceVertexUvs[0].push([
												new Rr().fromBufferAttribute(s, t),
												new Rr().fromBufferAttribute(s, n),
												new Rr().fromBufferAttribute(s, i),
											]),
										void 0 !== c &&
											e.faceVertexUvs[1].push([
												new Rr().fromBufferAttribute(c, t),
												new Rr().fromBufferAttribute(c, n),
												new Rr().fromBufferAttribute(c, i),
											]);
								}
								const h = t.groups;
								if (h.length > 0)
									for (let t = 0; t < h.length; t++) {
										const e = h[t],
											i = e.start;
										for (let t = i, r = i + e.count; t < r; t += 3)
											void 0 !== n
												? l(
														n.getX(t),
														n.getX(t + 1),
														n.getX(t + 2),
														e.materialIndex
												  )
												: l(t, t + 1, t + 2, e.materialIndex);
									}
								else if (void 0 !== n)
									for (let t = 0; t < n.count; t += 3)
										l(n.getX(t), n.getX(t + 1), n.getX(t + 2));
								else for (let t = 0; t < r.count; t += 3) l(t, t + 1, t + 2);
								return (
									this.computeFaceNormals(),
									null !== t.boundingBox &&
										(this.boundingBox = t.boundingBox.clone()),
									null !== t.boundingSphere &&
										(this.boundingSphere = t.boundingSphere.clone()),
									this
								);
							},
							center: function () {
								return (
									this.computeBoundingBox(),
									this.boundingBox.getCenter(Ja).negate(),
									this.translate(Ja.x, Ja.y, Ja.z),
									this
								);
							},
							normalize: function () {
								this.computeBoundingSphere();
								const t = this.boundingSphere.center,
									e = this.boundingSphere.radius,
									n = 0 === e ? 1 : 1 / e,
									i = new jr();
								return (
									i.set(
										n,
										0,
										0,
										-n * t.x,
										0,
										n,
										0,
										-n * t.y,
										0,
										0,
										n,
										-n * t.z,
										0,
										0,
										0,
										1
									),
									this.applyMatrix4(i),
									this
								);
							},
							computeFaceNormals: function () {
								const t = new zr(),
									e = new zr();
								for (let n = 0, i = this.faces.length; n < i; n++) {
									const i = this.faces[n],
										r = this.vertices[i.a],
										o = this.vertices[i.b],
										a = this.vertices[i.c];
									t.subVectors(a, o),
										e.subVectors(r, o),
										t.cross(e),
										t.normalize(),
										i.normal.copy(t);
								}
							},
							computeVertexNormals: function (t) {
								void 0 === t && (t = !0);
								const e = new Array(this.vertices.length);
								for (let t = 0, n = this.vertices.length; t < n; t++)
									e[t] = new zr();
								if (t) {
									const t = new zr(),
										n = new zr();
									for (let i = 0, r = this.faces.length; i < r; i++) {
										const r = this.faces[i],
											o = this.vertices[r.a],
											a = this.vertices[r.b],
											s = this.vertices[r.c];
										t.subVectors(s, a),
											n.subVectors(o, a),
											t.cross(n),
											e[r.a].add(t),
											e[r.b].add(t),
											e[r.c].add(t);
									}
								} else {
									this.computeFaceNormals();
									for (let t = 0, n = this.faces.length; t < n; t++) {
										const n = this.faces[t];
										e[n.a].add(n.normal),
											e[n.b].add(n.normal),
											e[n.c].add(n.normal);
									}
								}
								for (let t = 0, n = this.vertices.length; t < n; t++)
									e[t].normalize();
								for (let t = 0, n = this.faces.length; t < n; t++) {
									const n = this.faces[t],
										i = n.vertexNormals;
									3 === i.length
										? (i[0].copy(e[n.a]), i[1].copy(e[n.b]), i[2].copy(e[n.c]))
										: ((i[0] = e[n.a].clone()),
										  (i[1] = e[n.b].clone()),
										  (i[2] = e[n.c].clone()));
								}
								this.faces.length > 0 && (this.normalsNeedUpdate = !0);
							},
							computeFlatVertexNormals: function () {
								this.computeFaceNormals();
								for (let t = 0, e = this.faces.length; t < e; t++) {
									const e = this.faces[t],
										n = e.vertexNormals;
									3 === n.length
										? (n[0].copy(e.normal),
										  n[1].copy(e.normal),
										  n[2].copy(e.normal))
										: ((n[0] = e.normal.clone()),
										  (n[1] = e.normal.clone()),
										  (n[2] = e.normal.clone()));
								}
								this.faces.length > 0 && (this.normalsNeedUpdate = !0);
							},
							computeMorphNormals: function () {
								for (let t = 0, e = this.faces.length; t < e; t++) {
									const e = this.faces[t];
									e.__originalFaceNormal
										? e.__originalFaceNormal.copy(e.normal)
										: (e.__originalFaceNormal = e.normal.clone()),
										e.__originalVertexNormals ||
											(e.__originalVertexNormals = []);
									for (let t = 0, n = e.vertexNormals.length; t < n; t++)
										e.__originalVertexNormals[t]
											? e.__originalVertexNormals[t].copy(e.vertexNormals[t])
											: (e.__originalVertexNormals[t] =
													e.vertexNormals[t].clone());
								}
								const t = new Ya();
								t.faces = this.faces;
								for (let e = 0, n = this.morphTargets.length; e < n; e++) {
									if (!this.morphNormals[e]) {
										(this.morphNormals[e] = {}),
											(this.morphNormals[e].faceNormals = []),
											(this.morphNormals[e].vertexNormals = []);
										const t = this.morphNormals[e].faceNormals,
											n = this.morphNormals[e].vertexNormals;
										for (let e = 0, i = this.faces.length; e < i; e++) {
											const e = new zr(),
												i = { a: new zr(), b: new zr(), c: new zr() };
											t.push(e), n.push(i);
										}
									}
									const n = this.morphNormals[e];
									(t.vertices = this.morphTargets[e].vertices),
										t.computeFaceNormals(),
										t.computeVertexNormals();
									for (let t = 0, e = this.faces.length; t < e; t++) {
										const e = this.faces[t],
											i = n.faceNormals[t],
											r = n.vertexNormals[t];
										i.copy(e.normal),
											r.a.copy(e.vertexNormals[0]),
											r.b.copy(e.vertexNormals[1]),
											r.c.copy(e.vertexNormals[2]);
									}
								}
								for (let t = 0, e = this.faces.length; t < e; t++) {
									const e = this.faces[t];
									(e.normal = e.__originalFaceNormal),
										(e.vertexNormals = e.__originalVertexNormals);
								}
							},
							computeBoundingBox: function () {
								null === this.boundingBox && (this.boundingBox = new Ro()),
									this.boundingBox.setFromPoints(this.vertices);
							},
							computeBoundingSphere: function () {
								null === this.boundingSphere &&
									(this.boundingSphere = new vo()),
									this.boundingSphere.setFromPoints(this.vertices);
							},
							merge: function (t, e, n) {
								if (!t || !t.isGeometry)
									return void console.error(
										"THREE.Geometry.merge(): geometry not an instance of THREE.Geometry.",
										t
									);
								let i,
									r = this.vertices.length,
									o = this.vertices,
									a = t.vertices,
									s = this.faces,
									c = t.faces,
									l = this.colors,
									h = t.colors;
								void 0 === n && (n = 0),
									void 0 !== e && (i = new Mr().getNormalMatrix(e));
								for (let t = 0, n = a.length; t < n; t++) {
									const n = a[t].clone();
									void 0 !== e && n.applyMatrix4(e), o.push(n);
								}
								for (let t = 0, e = h.length; t < e; t++) l.push(h[t].clone());
								for (let t = 0, e = c.length; t < e; t++) {
									let e,
										o,
										a,
										l = c[t],
										h = l.vertexNormals,
										p = l.vertexColors;
									(e = new ea(l.a + r, l.b + r, l.c + r)),
										e.normal.copy(l.normal),
										void 0 !== i && e.normal.applyMatrix3(i).normalize();
									for (let t = 0, n = h.length; t < n; t++)
										(o = h[t].clone()),
											void 0 !== i && o.applyMatrix3(i).normalize(),
											e.vertexNormals.push(o);
									e.color.copy(l.color);
									for (let t = 0, n = p.length; t < n; t++)
										(a = p[t]), e.vertexColors.push(a.clone());
									(e.materialIndex = l.materialIndex + n), s.push(e);
								}
								for (let e = 0, n = t.faceVertexUvs.length; e < n; e++) {
									const n = t.faceVertexUvs[e];
									void 0 === this.faceVertexUvs[e] &&
										(this.faceVertexUvs[e] = []);
									for (let t = 0, i = n.length; t < i; t++) {
										const i = n[t],
											r = [];
										for (let t = 0, e = i.length; t < e; t++)
											r.push(i[t].clone());
										this.faceVertexUvs[e].push(r);
									}
								}
							},
							mergeMesh: function (t) {
								t && t.isMesh
									? (t.matrixAutoUpdate && t.updateMatrix(),
									  this.merge(t.geometry, t.matrix))
									: console.error(
											"THREE.Geometry.mergeMesh(): mesh not an instance of THREE.Mesh.",
											t
									  );
							},
							mergeVertices: function () {
								const t = {},
									e = [],
									n = [],
									i = Math.pow(10, 4);
								for (let r = 0, o = this.vertices.length; r < o; r++) {
									const o = this.vertices[r],
										a =
											Math.round(o.x * i) +
											"_" +
											Math.round(o.y * i) +
											"_" +
											Math.round(o.z * i);
									void 0 === t[a]
										? ((t[a] = r),
										  e.push(this.vertices[r]),
										  (n[r] = e.length - 1))
										: (n[r] = n[t[a]]);
								}
								const r = [];
								for (let t = 0, e = this.faces.length; t < e; t++) {
									const e = this.faces[t];
									(e.a = n[e.a]), (e.b = n[e.b]), (e.c = n[e.c]);
									const i = [e.a, e.b, e.c];
									for (let e = 0; e < 3; e++)
										if (i[e] === i[(e + 1) % 3]) {
											r.push(t);
											break;
										}
								}
								for (let t = r.length - 1; t >= 0; t--) {
									const e = r[t];
									this.faces.splice(e, 1);
									for (let t = 0, n = this.faceVertexUvs.length; t < n; t++)
										this.faceVertexUvs[t].splice(e, 1);
								}
								const o = this.vertices.length - e.length;
								return (this.vertices = e), o;
							},
							setFromPoints: function (t) {
								this.vertices = [];
								for (let e = 0, n = t.length; e < n; e++) {
									const n = t[e];
									this.vertices.push(new zr(n.x, n.y, n.z || 0));
								}
								return this;
							},
							sortFacesByMaterialIndex: function () {
								const t = this.faces,
									e = t.length;
								for (let n = 0; n < e; n++) t[n]._id = n;
								t.sort(function (t, e) {
									return t.materialIndex - e.materialIndex;
								});
								const n = this.faceVertexUvs[0],
									i = this.faceVertexUvs[1];
								let r, o;
								n && n.length === e && (r = []),
									i && i.length === e && (o = []);
								for (let a = 0; a < e; a++) {
									const e = t[a]._id;
									r && r.push(n[e]), o && o.push(i[e]);
								}
								r && (this.faceVertexUvs[0] = r),
									o && (this.faceVertexUvs[1] = o);
							},
							toJSON: function () {
								const t = {
									metadata: {
										version: 4.5,
										type: "Geometry",
										generator: "Geometry.toJSON",
									},
								};
								if (
									((t.uuid = this.uuid),
									(t.type = this.type),
									"" !== this.name && (t.name = this.name),
									void 0 !== this.parameters)
								) {
									const e = this.parameters;
									for (const n in e) void 0 !== e[n] && (t[n] = e[n]);
									return t;
								}
								const e = [];
								for (let t = 0; t < this.vertices.length; t++) {
									const n = this.vertices[t];
									e.push(n.x, n.y, n.z);
								}
								const n = [],
									i = [],
									r = {},
									o = [],
									a = {},
									s = [],
									c = {};
								for (let t = 0; t < this.faces.length; t++) {
									const e = this.faces[t],
										i = !0,
										r = !1,
										o = void 0 !== this.faceVertexUvs[0][t],
										a = e.normal.length() > 0,
										s = e.vertexNormals.length > 0,
										c = 1 !== e.color.r || 1 !== e.color.g || 1 !== e.color.b,
										d = e.vertexColors.length > 0;
									let m = 0;
									if (
										((m = l(m, 0, 0)),
										(m = l(m, 1, i)),
										(m = l(m, 2, r)),
										(m = l(m, 3, o)),
										(m = l(m, 4, a)),
										(m = l(m, 5, s)),
										(m = l(m, 6, c)),
										(m = l(m, 7, d)),
										n.push(m),
										n.push(e.a, e.b, e.c),
										n.push(e.materialIndex),
										o)
									) {
										const e = this.faceVertexUvs[0][t];
										n.push(u(e[0]), u(e[1]), u(e[2]));
									}
									if ((a && n.push(h(e.normal)), s)) {
										const t = e.vertexNormals;
										n.push(h(t[0]), h(t[1]), h(t[2]));
									}
									if ((c && n.push(p(e.color)), d)) {
										const t = e.vertexColors;
										n.push(p(t[0]), p(t[1]), p(t[2]));
									}
								}
								function l(t, e, n) {
									return n ? t | (1 << e) : t & ~(1 << e);
								}
								function h(t) {
									const e = t.x.toString() + t.y.toString() + t.z.toString();
									return (
										void 0 !== r[e] ||
											((r[e] = i.length / 3), i.push(t.x, t.y, t.z)),
										r[e]
									);
								}
								function p(t) {
									const e = t.r.toString() + t.g.toString() + t.b.toString();
									return (
										void 0 !== a[e] || ((a[e] = o.length), o.push(t.getHex())),
										a[e]
									);
								}
								function u(t) {
									const e = t.x.toString() + t.y.toString();
									return (
										void 0 !== c[e] ||
											((c[e] = s.length / 2), s.push(t.x, t.y)),
										c[e]
									);
								}
								return (
									(t.data = {}),
									(t.data.vertices = e),
									(t.data.normals = i),
									o.length > 0 && (t.data.colors = o),
									s.length > 0 && (t.data.uvs = [s]),
									(t.data.faces = n),
									t
								);
							},
							clone: function () {
								return new Ya().copy(this);
							},
							copy: function (t) {
								(this.vertices = []),
									(this.colors = []),
									(this.faces = []),
									(this.faceVertexUvs = [[]]),
									(this.morphTargets = []),
									(this.morphNormals = []),
									(this.skinWeights = []),
									(this.skinIndices = []),
									(this.lineDistances = []),
									(this.boundingBox = null),
									(this.boundingSphere = null),
									(this.name = t.name);
								const e = t.vertices;
								for (let t = 0, n = e.length; t < n; t++)
									this.vertices.push(e[t].clone());
								const n = t.colors;
								for (let t = 0, e = n.length; t < e; t++)
									this.colors.push(n[t].clone());
								const i = t.faces;
								for (let t = 0, e = i.length; t < e; t++)
									this.faces.push(i[t].clone());
								for (let e = 0, n = t.faceVertexUvs.length; e < n; e++) {
									const n = t.faceVertexUvs[e];
									void 0 === this.faceVertexUvs[e] &&
										(this.faceVertexUvs[e] = []);
									for (let t = 0, i = n.length; t < i; t++) {
										const i = n[t],
											r = [];
										for (let t = 0, e = i.length; t < e; t++) {
											const e = i[t];
											r.push(e.clone());
										}
										this.faceVertexUvs[e].push(r);
									}
								}
								const r = t.morphTargets;
								for (let t = 0, e = r.length; t < e; t++) {
									const e = {};
									if (((e.name = r[t].name), void 0 !== r[t].vertices)) {
										e.vertices = [];
										for (let n = 0, i = r[t].vertices.length; n < i; n++)
											e.vertices.push(r[t].vertices[n].clone());
									}
									if (void 0 !== r[t].normals) {
										e.normals = [];
										for (let n = 0, i = r[t].normals.length; n < i; n++)
											e.normals.push(r[t].normals[n].clone());
									}
									this.morphTargets.push(e);
								}
								const o = t.morphNormals;
								for (let t = 0, e = o.length; t < e; t++) {
									const e = {};
									if (void 0 !== o[t].vertexNormals) {
										e.vertexNormals = [];
										for (let n = 0, i = o[t].vertexNormals.length; n < i; n++) {
											const i = o[t].vertexNormals[n],
												r = {};
											(r.a = i.a.clone()),
												(r.b = i.b.clone()),
												(r.c = i.c.clone()),
												e.vertexNormals.push(r);
										}
									}
									if (void 0 !== o[t].faceNormals) {
										e.faceNormals = [];
										for (let n = 0, i = o[t].faceNormals.length; n < i; n++)
											e.faceNormals.push(o[t].faceNormals[n].clone());
									}
									this.morphNormals.push(e);
								}
								const a = t.skinWeights;
								for (let t = 0, e = a.length; t < e; t++)
									this.skinWeights.push(a[t].clone());
								const s = t.skinIndices;
								for (let t = 0, e = s.length; t < e; t++)
									this.skinIndices.push(s[t].clone());
								const c = t.lineDistances;
								for (let t = 0, e = c.length; t < e; t++)
									this.lineDistances.push(c[t]);
								const l = t.boundingBox;
								null !== l && (this.boundingBox = l.clone());
								const h = t.boundingSphere;
								return (
									null !== h && (this.boundingSphere = h.clone()),
									(this.elementsNeedUpdate = t.elementsNeedUpdate),
									(this.verticesNeedUpdate = t.verticesNeedUpdate),
									(this.uvsNeedUpdate = t.uvsNeedUpdate),
									(this.normalsNeedUpdate = t.normalsNeedUpdate),
									(this.colorsNeedUpdate = t.colorsNeedUpdate),
									(this.lineDistancesNeedUpdate = t.lineDistancesNeedUpdate),
									(this.groupsNeedUpdate = t.groupsNeedUpdate),
									this
								);
							},
							dispose: function () {
								this.dispatchEvent({ type: "dispose" });
							},
						});
						class Xa extends Ua {
							constructor(t = 1, e = 1, n = 1, i = 1, r = 1, o = 1) {
								super(),
									(this.type = "BoxBufferGeometry"),
									(this.parameters = {
										width: t,
										height: e,
										depth: n,
										widthSegments: i,
										heightSegments: r,
										depthSegments: o,
									});
								const a = this;
								(i = Math.floor(i)), (r = Math.floor(r)), (o = Math.floor(o));
								const s = [],
									c = [],
									l = [],
									h = [];
								let p = 0,
									u = 0;
								function d(t, e, n, i, r, o, d, m, f, g, S) {
									const y = o / f,
										V = d / g,
										q = o / 2,
										R = d / 2,
										M = m / 2,
										I = f + 1,
										v = g + 1;
									let k = 0,
										U = 0;
									const w = new zr();
									for (let o = 0; o < v; o++) {
										const a = o * V - R;
										for (let s = 0; s < I; s++) {
											const p = s * y - q;
											(w[t] = p * i),
												(w[e] = a * r),
												(w[n] = M),
												c.push(w.x, w.y, w.z),
												(w[t] = 0),
												(w[e] = 0),
												(w[n] = m > 0 ? 1 : -1),
												l.push(w.x, w.y, w.z),
												h.push(s / f),
												h.push(1 - o / g),
												(k += 1);
										}
									}
									for (let t = 0; t < g; t++)
										for (let e = 0; e < f; e++) {
											const n = p + e + I * t,
												i = p + e + I * (t + 1),
												r = p + (e + 1) + I * (t + 1),
												o = p + (e + 1) + I * t;
											s.push(n, i, o), s.push(i, r, o), (U += 6);
										}
									a.addGroup(u, U, S), (u += U), (p += k);
								}
								d("z", "y", "x", -1, -1, n, e, t, o, r, 0),
									d("z", "y", "x", 1, -1, n, e, -t, o, r, 1),
									d("x", "z", "y", 1, 1, t, n, e, i, o, 2),
									d("x", "z", "y", 1, -1, t, n, -e, i, o, 3),
									d("x", "y", "z", 1, -1, t, e, n, i, r, 4),
									d("x", "y", "z", -1, -1, t, e, -n, i, r, 5),
									this.setIndex(s),
									this.setAttribute("position", new fa(c, 3)),
									this.setAttribute("normal", new fa(l, 3)),
									this.setAttribute("uv", new fa(h, 2));
							}
						}
						function $a(t) {
							const e = {};
							for (const n in t) {
								e[n] = {};
								for (const i in t[n]) {
									const r = t[n][i];
									r &&
									(r.isColor ||
										r.isMatrix3 ||
										r.isMatrix4 ||
										r.isVector2 ||
										r.isVector3 ||
										r.isVector4 ||
										r.isTexture)
										? (e[n][i] = r.clone())
										: Array.isArray(r)
										? (e[n][i] = r.slice())
										: (e[n][i] = r);
								}
							}
							return e;
						}
						function ts(t) {
							const e = {};
							for (let n = 0; n < t.length; n++) {
								const i = $a(t[n]);
								for (const t in i) e[t] = i[t];
							}
							return e;
						}
						const es = { clone: $a, merge: ts };
						function ns(t) {
							ia.call(this),
								(this.type = "ShaderMaterial"),
								(this.defines = {}),
								(this.uniforms = {}),
								(this.vertexShader =
									"void main() {\n\tgl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\n}"),
								(this.fragmentShader =
									"void main() {\n\tgl_FragColor = vec4( 1.0, 0.0, 0.0, 1.0 );\n}"),
								(this.linewidth = 1),
								(this.wireframe = !1),
								(this.wireframeLinewidth = 1),
								(this.fog = !1),
								(this.lights = !1),
								(this.clipping = !1),
								(this.skinning = !1),
								(this.morphTargets = !1),
								(this.morphNormals = !1),
								(this.extensions = {
									derivatives: !1,
									fragDepth: !1,
									drawBuffers: !1,
									shaderTextureLOD: !1,
								}),
								(this.defaultAttributeValues = {
									color: [1, 1, 1],
									uv: [0, 0],
									uv2: [0, 0],
								}),
								(this.index0AttributeName = void 0),
								(this.uniformsNeedUpdate = !1),
								void 0 !== t &&
									(void 0 !== t.attributes &&
										console.error(
											"THREE.ShaderMaterial: attributes should now be defined in THREE.BufferGeometry instead."
										),
									this.setValues(t));
						}
						function is() {
							oo.call(this),
								(this.type = "Camera"),
								(this.matrixWorldInverse = new jr()),
								(this.projectionMatrix = new jr()),
								(this.projectionMatrixInverse = new jr());
						}
						function rs(t, e, n, i) {
							is.call(this),
								(this.type = "PerspectiveCamera"),
								(this.fov = void 0 !== t ? t : 50),
								(this.zoom = 1),
								(this.near = void 0 !== n ? n : 0.1),
								(this.far = void 0 !== i ? i : 2e3),
								(this.focus = 10),
								(this.aspect = void 0 !== e ? e : 1),
								(this.view = null),
								(this.filmGauge = 35),
								(this.filmOffset = 0),
								this.updateProjectionMatrix();
						}
						(ns.prototype = Object.create(ia.prototype)),
							(ns.prototype.constructor = ns),
							(ns.prototype.isShaderMaterial = !0),
							(ns.prototype.copy = function (t) {
								return (
									ia.prototype.copy.call(this, t),
									(this.fragmentShader = t.fragmentShader),
									(this.vertexShader = t.vertexShader),
									(this.uniforms = $a(t.uniforms)),
									(this.defines = Object.assign({}, t.defines)),
									(this.wireframe = t.wireframe),
									(this.wireframeLinewidth = t.wireframeLinewidth),
									(this.lights = t.lights),
									(this.clipping = t.clipping),
									(this.skinning = t.skinning),
									(this.morphTargets = t.morphTargets),
									(this.morphNormals = t.morphNormals),
									(this.extensions = Object.assign({}, t.extensions)),
									this
								);
							}),
							(ns.prototype.toJSON = function (t) {
								const e = ia.prototype.toJSON.call(this, t);
								e.uniforms = {};
								for (const n in this.uniforms) {
									const i = this.uniforms[n].value;
									i && i.isTexture
										? (e.uniforms[n] = { type: "t", value: i.toJSON(t).uuid })
										: i && i.isColor
										? (e.uniforms[n] = { type: "c", value: i.getHex() })
										: i && i.isVector2
										? (e.uniforms[n] = { type: "v2", value: i.toArray() })
										: i && i.isVector3
										? (e.uniforms[n] = { type: "v3", value: i.toArray() })
										: i && i.isVector4
										? (e.uniforms[n] = { type: "v4", value: i.toArray() })
										: i && i.isMatrix3
										? (e.uniforms[n] = { type: "m3", value: i.toArray() })
										: i && i.isMatrix4
										? (e.uniforms[n] = { type: "m4", value: i.toArray() })
										: (e.uniforms[n] = { value: i });
								}
								Object.keys(this.defines).length > 0 &&
									(e.defines = this.defines),
									(e.vertexShader = this.vertexShader),
									(e.fragmentShader = this.fragmentShader);
								const n = {};
								for (const t in this.extensions)
									!0 === this.extensions[t] && (n[t] = !0);
								return Object.keys(n).length > 0 && (e.extensions = n), e;
							}),
							(is.prototype = Object.assign(Object.create(oo.prototype), {
								constructor: is,
								isCamera: !0,
								copy: function (t, e) {
									return (
										oo.prototype.copy.call(this, t, e),
										this.matrixWorldInverse.copy(t.matrixWorldInverse),
										this.projectionMatrix.copy(t.projectionMatrix),
										this.projectionMatrixInverse.copy(
											t.projectionMatrixInverse
										),
										this
									);
								},
								getWorldDirection: function (t) {
									void 0 === t &&
										(console.warn(
											"THREE.Camera: .getWorldDirection() target is now required"
										),
										(t = new zr())),
										this.updateMatrixWorld(!0);
									const e = this.matrixWorld.elements;
									return t.set(-e[8], -e[9], -e[10]).normalize();
								},
								updateMatrixWorld: function (t) {
									oo.prototype.updateMatrixWorld.call(this, t),
										this.matrixWorldInverse.getInverse(this.matrixWorld);
								},
								updateWorldMatrix: function (t, e) {
									oo.prototype.updateWorldMatrix.call(this, t, e),
										this.matrixWorldInverse.getInverse(this.matrixWorld);
								},
								clone: function () {
									return new this.constructor().copy(this);
								},
							})),
							(rs.prototype = Object.assign(Object.create(is.prototype), {
								constructor: rs,
								isPerspectiveCamera: !0,
								copy: function (t, e) {
									return (
										is.prototype.copy.call(this, t, e),
										(this.fov = t.fov),
										(this.zoom = t.zoom),
										(this.near = t.near),
										(this.far = t.far),
										(this.focus = t.focus),
										(this.aspect = t.aspect),
										(this.view =
											null === t.view ? null : Object.assign({}, t.view)),
										(this.filmGauge = t.filmGauge),
										(this.filmOffset = t.filmOffset),
										this
									);
								},
								setFocalLength: function (t) {
									const e = (0.5 * this.getFilmHeight()) / t;
									(this.fov = 2 * qr.RAD2DEG * Math.atan(e)),
										this.updateProjectionMatrix();
								},
								getFocalLength: function () {
									const t = Math.tan(0.5 * qr.DEG2RAD * this.fov);
									return (0.5 * this.getFilmHeight()) / t;
								},
								getEffectiveFOV: function () {
									return (
										2 *
										qr.RAD2DEG *
										Math.atan(Math.tan(0.5 * qr.DEG2RAD * this.fov) / this.zoom)
									);
								},
								getFilmWidth: function () {
									return this.filmGauge * Math.min(this.aspect, 1);
								},
								getFilmHeight: function () {
									return this.filmGauge / Math.max(this.aspect, 1);
								},
								setViewOffset: function (t, e, n, i, r, o) {
									(this.aspect = t / e),
										null === this.view &&
											(this.view = {
												enabled: !0,
												fullWidth: 1,
												fullHeight: 1,
												offsetX: 0,
												offsetY: 0,
												width: 1,
												height: 1,
											}),
										(this.view.enabled = !0),
										(this.view.fullWidth = t),
										(this.view.fullHeight = e),
										(this.view.offsetX = n),
										(this.view.offsetY = i),
										(this.view.width = r),
										(this.view.height = o),
										this.updateProjectionMatrix();
								},
								clearViewOffset: function () {
									null !== this.view && (this.view.enabled = !1),
										this.updateProjectionMatrix();
								},
								updateProjectionMatrix: function () {
									let t = this.near,
										e = (t * Math.tan(0.5 * qr.DEG2RAD * this.fov)) / this.zoom,
										n = 2 * e,
										i = this.aspect * n,
										r = -0.5 * i,
										o = this.view;
									if (null !== this.view && this.view.enabled) {
										const t = o.fullWidth,
											a = o.fullHeight;
										(r += (o.offsetX * i) / t),
											(e -= (o.offsetY * n) / a),
											(i *= o.width / t),
											(n *= o.height / a);
									}
									const a = this.filmOffset;
									0 !== a && (r += (t * a) / this.getFilmWidth()),
										this.projectionMatrix.makePerspective(
											r,
											r + i,
											e,
											e - n,
											t,
											this.far
										),
										this.projectionMatrixInverse.getInverse(
											this.projectionMatrix
										);
								},
								toJSON: function (t) {
									const e = oo.prototype.toJSON.call(this, t);
									return (
										(e.object.fov = this.fov),
										(e.object.zoom = this.zoom),
										(e.object.near = this.near),
										(e.object.far = this.far),
										(e.object.focus = this.focus),
										(e.object.aspect = this.aspect),
										null !== this.view &&
											(e.object.view = Object.assign({}, this.view)),
										(e.object.filmGauge = this.filmGauge),
										(e.object.filmOffset = this.filmOffset),
										e
									);
								},
							}));
						const os = 90;
						function as(t, e, n) {
							if (
								(oo.call(this),
								(this.type = "CubeCamera"),
								!0 !== n.isWebGLCubeRenderTarget)
							)
								return void console.error(
									"THREE.CubeCamera: The constructor now expects an instance of WebGLCubeRenderTarget as third parameter."
								);
							this.renderTarget = n;
							const i = new rs(os, 1, t, e);
							(i.layers = this.layers),
								i.up.set(0, -1, 0),
								i.lookAt(new zr(1, 0, 0)),
								this.add(i);
							const r = new rs(os, 1, t, e);
							(r.layers = this.layers),
								r.up.set(0, -1, 0),
								r.lookAt(new zr(-1, 0, 0)),
								this.add(r);
							const o = new rs(os, 1, t, e);
							(o.layers = this.layers),
								o.up.set(0, 0, 1),
								o.lookAt(new zr(0, 1, 0)),
								this.add(o);
							const a = new rs(os, 1, t, e);
							(a.layers = this.layers),
								a.up.set(0, 0, -1),
								a.lookAt(new zr(0, -1, 0)),
								this.add(a);
							const s = new rs(os, 1, t, e);
							(s.layers = this.layers),
								s.up.set(0, -1, 0),
								s.lookAt(new zr(0, 0, 1)),
								this.add(s);
							const c = new rs(os, 1, t, e);
							(c.layers = this.layers),
								c.up.set(0, -1, 0),
								c.lookAt(new zr(0, 0, -1)),
								this.add(c),
								(this.update = function (t, e) {
									null === this.parent && this.updateMatrixWorld();
									const l = t.xr.enabled,
										h = t.getRenderTarget();
									t.xr.enabled = !1;
									const p = n.texture.generateMipmaps;
									(n.texture.generateMipmaps = !1),
										t.setRenderTarget(n, 0),
										t.render(e, i),
										t.setRenderTarget(n, 1),
										t.render(e, r),
										t.setRenderTarget(n, 2),
										t.render(e, o),
										t.setRenderTarget(n, 3),
										t.render(e, a),
										t.setRenderTarget(n, 4),
										t.render(e, s),
										(n.texture.generateMipmaps = p),
										t.setRenderTarget(n, 5),
										t.render(e, c),
										t.setRenderTarget(h),
										(t.xr.enabled = l);
								}),
								(this.clear = function (t, e, i, r) {
									const o = t.getRenderTarget();
									for (let o = 0; o < 6; o++)
										t.setRenderTarget(n, o), t.clear(e, i, r);
									t.setRenderTarget(o);
								});
						}
						function ss(t, e, n) {
							Number.isInteger(e) &&
								(console.warn(
									"THREE.WebGLCubeRenderTarget: constructor signature is now WebGLCubeRenderTarget( size, options )"
								),
								(e = n)),
								xr.call(this, t, t, e);
						}
						function cs(t, e, n, i, r, o, a, s, c, l, h, p) {
							Ur.call(this, null, o, a, s, c, l, i, r, h, p),
								(this.image = {
									data: t || null,
									width: e || 1,
									height: n || 1,
								}),
								(this.magFilter = void 0 !== c ? c : Di),
								(this.minFilter = void 0 !== l ? l : Di),
								(this.generateMipmaps = !1),
								(this.flipY = !1),
								(this.unpackAlignment = 1),
								(this.needsUpdate = !0);
						}
						(as.prototype = Object.create(oo.prototype)),
							(as.prototype.constructor = as),
							(ss.prototype = Object.create(xr.prototype)),
							(ss.prototype.constructor = ss),
							(ss.prototype.isWebGLCubeRenderTarget = !0),
							(ss.prototype.fromEquirectangularTexture = function (t, e) {
								(this.texture.type = e.type),
									(this.texture.format = tr),
									(this.texture.encoding = e.encoding),
									(this.texture.generateMipmaps = e.generateMipmaps),
									(this.texture.minFilter = e.minFilter),
									(this.texture.magFilter = e.magFilter);
								const n = new ao(),
									i =
										"\n\n\t\t\tvarying vec3 vWorldDirection;\n\n\t\t\tvec3 transformDirection( in vec3 dir, in mat4 matrix ) {\n\n\t\t\t\treturn normalize( ( matrix * vec4( dir, 0.0 ) ).xyz );\n\n\t\t\t}\n\n\t\t\tvoid main() {\n\n\t\t\t\tvWorldDirection = transformDirection( position, modelMatrix );\n\n\t\t\t\t#include <begin_vertex>\n\t\t\t\t#include <project_vertex>\n\n\t\t\t}\n\t\t",
									r =
										"\n\n\t\t\tuniform sampler2D tEquirect;\n\n\t\t\tvarying vec3 vWorldDirection;\n\n\t\t\t#include <common>\n\n\t\t\tvoid main() {\n\n\t\t\t\tvec3 direction = normalize( vWorldDirection );\n\n\t\t\t\tvec2 sampleUV = equirectUv( direction );\n\n\t\t\t\tgl_FragColor = texture2D( tEquirect, sampleUV );\n\n\t\t\t}\n\t\t",
									o = new ns({
										name: "CubemapFromEquirect",
										uniforms: $a({ tEquirect: { value: null } }),
										vertexShader: i,
										fragmentShader: r,
										side: 1,
										blending: 0,
									});
								o.uniforms.tEquirect.value = e;
								const a = new La(new Xa(5, 5, 5), o);
								return (
									n.add(a),
									new as(1, 10, this).update(t, n),
									a.geometry.dispose(),
									a.material.dispose(),
									this
								);
							}),
							(cs.prototype = Object.create(Ur.prototype)),
							(cs.prototype.constructor = cs),
							(cs.prototype.isDataTexture = !0);
						const ls = new vo(),
							hs = new zr();
						function ps(t, e, n, i, r, o) {
							this.planes = [
								void 0 !== t ? t : new Co(),
								void 0 !== e ? e : new Co(),
								void 0 !== n ? n : new Co(),
								void 0 !== i ? i : new Co(),
								void 0 !== r ? r : new Co(),
								void 0 !== o ? o : new Co(),
							];
						}
						Object.assign(ps.prototype, {
							set: function (t, e, n, i, r, o) {
								const a = this.planes;
								return (
									a[0].copy(t),
									a[1].copy(e),
									a[2].copy(n),
									a[3].copy(i),
									a[4].copy(r),
									a[5].copy(o),
									this
								);
							},
							clone: function () {
								return new this.constructor().copy(this);
							},
							copy: function (t) {
								const e = this.planes;
								for (let n = 0; n < 6; n++) e[n].copy(t.planes[n]);
								return this;
							},
							setFromProjectionMatrix: function (t) {
								const e = this.planes,
									n = t.elements,
									i = n[0],
									r = n[1],
									o = n[2],
									a = n[3],
									s = n[4],
									c = n[5],
									l = n[6],
									h = n[7],
									p = n[8],
									u = n[9],
									d = n[10],
									m = n[11],
									f = n[12],
									g = n[13],
									S = n[14],
									y = n[15];
								return (
									e[0].setComponents(a - i, h - s, m - p, y - f).normalize(),
									e[1].setComponents(a + i, h + s, m + p, y + f).normalize(),
									e[2].setComponents(a + r, h + c, m + u, y + g).normalize(),
									e[3].setComponents(a - r, h - c, m - u, y - g).normalize(),
									e[4].setComponents(a - o, h - l, m - d, y - S).normalize(),
									e[5].setComponents(a + o, h + l, m + d, y + S).normalize(),
									this
								);
							},
							intersectsObject: function (t) {
								const e = t.geometry;
								return (
									null === e.boundingSphere && e.computeBoundingSphere(),
									ls.copy(e.boundingSphere).applyMatrix4(t.matrixWorld),
									this.intersectsSphere(ls)
								);
							},
							intersectsSprite: function (t) {
								return (
									ls.center.set(0, 0, 0),
									(ls.radius = 0.7071067811865476),
									ls.applyMatrix4(t.matrixWorld),
									this.intersectsSphere(ls)
								);
							},
							intersectsSphere: function (t) {
								const e = this.planes,
									n = t.center,
									i = -t.radius;
								for (let t = 0; t < 6; t++)
									if (e[t].distanceToPoint(n) < i) return !1;
								return !0;
							},
							intersectsBox: function (t) {
								const e = this.planes;
								for (let n = 0; n < 6; n++) {
									const i = e[n];
									if (
										((hs.x = i.normal.x > 0 ? t.max.x : t.min.x),
										(hs.y = i.normal.y > 0 ? t.max.y : t.min.y),
										(hs.z = i.normal.z > 0 ? t.max.z : t.min.z),
										i.distanceToPoint(hs) < 0)
									)
										return !1;
								}
								return !0;
							},
							containsPoint: function (t) {
								const e = this.planes;
								for (let n = 0; n < 6; n++)
									if (e[n].distanceToPoint(t) < 0) return !1;
								return !0;
							},
						});
						const us = {
							common: {
								diffuse: { value: new Yo(15658734) },
								opacity: { value: 1 },
								map: { value: null },
								uvTransform: { value: new Mr() },
								uv2Transform: { value: new Mr() },
								alphaMap: { value: null },
							},
							specularmap: { specularMap: { value: null } },
							envmap: {
								envMap: { value: null },
								flipEnvMap: { value: -1 },
								reflectivity: { value: 1 },
								refractionRatio: { value: 0.98 },
								maxMipLevel: { value: 0 },
							},
							aomap: { aoMap: { value: null }, aoMapIntensity: { value: 1 } },
							lightmap: {
								lightMap: { value: null },
								lightMapIntensity: { value: 1 },
							},
							emissivemap: { emissiveMap: { value: null } },
							bumpmap: { bumpMap: { value: null }, bumpScale: { value: 1 } },
							normalmap: {
								normalMap: { value: null },
								normalScale: { value: new Rr(1, 1) },
							},
							displacementmap: {
								displacementMap: { value: null },
								displacementScale: { value: 1 },
								displacementBias: { value: 0 },
							},
							roughnessmap: { roughnessMap: { value: null } },
							metalnessmap: { metalnessMap: { value: null } },
							gradientmap: { gradientMap: { value: null } },
							fog: {
								fogDensity: { value: 25e-5 },
								fogNear: { value: 1 },
								fogFar: { value: 2e3 },
								fogColor: { value: new Yo(16777215) },
							},
							lights: {
								ambientLightColor: { value: [] },
								lightProbe: { value: [] },
								directionalLights: {
									value: [],
									properties: { direction: {}, color: {} },
								},
								directionalLightShadows: {
									value: [],
									properties: {
										shadowBias: {},
										shadowNormalBias: {},
										shadowRadius: {},
										shadowMapSize: {},
									},
								},
								directionalShadowMap: { value: [] },
								directionalShadowMatrix: { value: [] },
								spotLights: {
									value: [],
									properties: {
										color: {},
										position: {},
										direction: {},
										distance: {},
										coneCos: {},
										penumbraCos: {},
										decay: {},
									},
								},
								spotLightShadows: {
									value: [],
									properties: {
										shadowBias: {},
										shadowNormalBias: {},
										shadowRadius: {},
										shadowMapSize: {},
									},
								},
								spotShadowMap: { value: [] },
								spotShadowMatrix: { value: [] },
								pointLights: {
									value: [],
									properties: {
										color: {},
										position: {},
										decay: {},
										distance: {},
									},
								},
								pointLightShadows: {
									value: [],
									properties: {
										shadowBias: {},
										shadowNormalBias: {},
										shadowRadius: {},
										shadowMapSize: {},
										shadowCameraNear: {},
										shadowCameraFar: {},
									},
								},
								pointShadowMap: { value: [] },
								pointShadowMatrix: { value: [] },
								hemisphereLights: {
									value: [],
									properties: { direction: {}, skyColor: {}, groundColor: {} },
								},
								rectAreaLights: {
									value: [],
									properties: {
										color: {},
										position: {},
										width: {},
										height: {},
									},
								},
							},
							points: {
								diffuse: { value: new Yo(15658734) },
								opacity: { value: 1 },
								size: { value: 1 },
								scale: { value: 1 },
								map: { value: null },
								alphaMap: { value: null },
								uvTransform: { value: new Mr() },
							},
							sprite: {
								diffuse: { value: new Yo(15658734) },
								opacity: { value: 1 },
								center: { value: new Rr(0.5, 0.5) },
								rotation: { value: 0 },
								map: { value: null },
								alphaMap: { value: null },
								uvTransform: { value: new Mr() },
							},
						};
						function ds() {
							let t = null,
								e = !1,
								n = null,
								i = null;
							function r(e, o) {
								n(e, o), (i = t.requestAnimationFrame(r));
							}
							return {
								start: function () {
									!0 !== e &&
										null !== n &&
										((i = t.requestAnimationFrame(r)), (e = !0));
								},
								stop: function () {
									t.cancelAnimationFrame(i), (e = !1);
								},
								setAnimationLoop: function (t) {
									n = t;
								},
								setContext: function (e) {
									t = e;
								},
							};
						}
						function ms(t, e) {
							const n = e.isWebGL2,
								i = new WeakMap();
							return {
								get: function (t) {
									return (
										t.isInterleavedBufferAttribute && (t = t.data), i.get(t)
									);
								},
								remove: function (e) {
									e.isInterleavedBufferAttribute && (e = e.data);
									const n = i.get(e);
									n && (t.deleteBuffer(n.buffer), i.delete(e));
								},
								update: function (e, r) {
									e.isInterleavedBufferAttribute && (e = e.data);
									const o = i.get(e);
									void 0 === o
										? i.set(
												e,
												(function (e, n) {
													const i = e.array,
														r = e.usage,
														o = t.createBuffer();
													t.bindBuffer(n, o),
														t.bufferData(n, i, r),
														e.onUploadCallback();
													let a = 5126;
													return (
														i instanceof Float32Array
															? (a = 5126)
															: i instanceof Float64Array
															? console.warn(
																	"THREE.WebGLAttributes: Unsupported data buffer format: Float64Array."
															  )
															: i instanceof Uint16Array
															? (a = 5123)
															: i instanceof Int16Array
															? (a = 5122)
															: i instanceof Uint32Array
															? (a = 5125)
															: i instanceof Int32Array
															? (a = 5124)
															: i instanceof Int8Array
															? (a = 5120)
															: i instanceof Uint8Array && (a = 5121),
														{
															buffer: o,
															type: a,
															bytesPerElement: i.BYTES_PER_ELEMENT,
															version: e.version,
														}
													);
												})(e, r)
										  )
										: o.version < e.version &&
										  ((function (e, i, r) {
												const o = i.array,
													a = i.updateRange;
												t.bindBuffer(r, e),
													-1 === a.count
														? t.bufferSubData(r, 0, o)
														: (n
																? t.bufferSubData(
																		r,
																		a.offset * o.BYTES_PER_ELEMENT,
																		o,
																		a.offset,
																		a.count
																  )
																: t.bufferSubData(
																		r,
																		a.offset * o.BYTES_PER_ELEMENT,
																		o.subarray(a.offset, a.offset + a.count)
																  ),
														  (a.count = -1));
										  })(o.buffer, e, r),
										  (o.version = e.version));
								},
							};
						}
						function fs(t, e, n, i) {
							Ya.call(this),
								(this.type = "PlaneGeometry"),
								(this.parameters = {
									width: t,
									height: e,
									widthSegments: n,
									heightSegments: i,
								}),
								this.fromBufferGeometry(new gs(t, e, n, i)),
								this.mergeVertices();
						}
						function gs(t, e, n, i) {
							Ua.call(this),
								(this.type = "PlaneBufferGeometry"),
								(this.parameters = {
									width: t,
									height: e,
									widthSegments: n,
									heightSegments: i,
								});
							const r = (t = t || 1) / 2,
								o = (e = e || 1) / 2,
								a = Math.floor(n) || 1,
								s = Math.floor(i) || 1,
								c = a + 1,
								l = s + 1,
								h = t / a,
								p = e / s,
								u = [],
								d = [],
								m = [],
								f = [];
							for (let t = 0; t < l; t++) {
								const e = t * p - o;
								for (let n = 0; n < c; n++) {
									const i = n * h - r;
									d.push(i, -e, 0),
										m.push(0, 0, 1),
										f.push(n / a),
										f.push(1 - t / s);
								}
							}
							for (let t = 0; t < s; t++)
								for (let e = 0; e < a; e++) {
									const n = e + c * t,
										i = e + c * (t + 1),
										r = e + 1 + c * (t + 1),
										o = e + 1 + c * t;
									u.push(n, i, o), u.push(i, r, o);
								}
							this.setIndex(u),
								this.setAttribute("position", new fa(d, 3)),
								this.setAttribute("normal", new fa(m, 3)),
								this.setAttribute("uv", new fa(f, 2));
						}
						(fs.prototype = Object.create(Ya.prototype)),
							(fs.prototype.constructor = fs),
							(gs.prototype = Object.create(Ua.prototype)),
							(gs.prototype.constructor = gs);
						const Ss = {
								alphamap_fragment:
									"#ifdef USE_ALPHAMAP\n\tdiffuseColor.a *= texture2D( alphaMap, vUv ).g;\n#endif",
								alphamap_pars_fragment:
									"#ifdef USE_ALPHAMAP\n\tuniform sampler2D alphaMap;\n#endif",
								alphatest_fragment:
									"#ifdef ALPHATEST\n\tif ( diffuseColor.a < ALPHATEST ) discard;\n#endif",
								aomap_fragment:
									"#ifdef USE_AOMAP\n\tfloat ambientOcclusion = ( texture2D( aoMap, vUv2 ).r - 1.0 ) * aoMapIntensity + 1.0;\n\treflectedLight.indirectDiffuse *= ambientOcclusion;\n\t#if defined( USE_ENVMAP ) && defined( STANDARD )\n\t\tfloat dotNV = saturate( dot( geometry.normal, geometry.viewDir ) );\n\t\treflectedLight.indirectSpecular *= computeSpecularOcclusion( dotNV, ambientOcclusion, material.specularRoughness );\n\t#endif\n#endif",
								aomap_pars_fragment:
									"#ifdef USE_AOMAP\n\tuniform sampler2D aoMap;\n\tuniform float aoMapIntensity;\n#endif",
								begin_vertex: "vec3 transformed = vec3( position );",
								beginnormal_vertex:
									"vec3 objectNormal = vec3( normal );\n#ifdef USE_TANGENT\n\tvec3 objectTangent = vec3( tangent.xyz );\n#endif",
								bsdfs:
									"vec2 integrateSpecularBRDF( const in float dotNV, const in float roughness ) {\n\tconst vec4 c0 = vec4( - 1, - 0.0275, - 0.572, 0.022 );\n\tconst vec4 c1 = vec4( 1, 0.0425, 1.04, - 0.04 );\n\tvec4 r = roughness * c0 + c1;\n\tfloat a004 = min( r.x * r.x, exp2( - 9.28 * dotNV ) ) * r.x + r.y;\n\treturn vec2( -1.04, 1.04 ) * a004 + r.zw;\n}\nfloat punctualLightIntensityToIrradianceFactor( const in float lightDistance, const in float cutoffDistance, const in float decayExponent ) {\n#if defined ( PHYSICALLY_CORRECT_LIGHTS )\n\tfloat distanceFalloff = 1.0 / max( pow( lightDistance, decayExponent ), 0.01 );\n\tif( cutoffDistance > 0.0 ) {\n\t\tdistanceFalloff *= pow2( saturate( 1.0 - pow4( lightDistance / cutoffDistance ) ) );\n\t}\n\treturn distanceFalloff;\n#else\n\tif( cutoffDistance > 0.0 && decayExponent > 0.0 ) {\n\t\treturn pow( saturate( -lightDistance / cutoffDistance + 1.0 ), decayExponent );\n\t}\n\treturn 1.0;\n#endif\n}\nvec3 BRDF_Diffuse_Lambert( const in vec3 diffuseColor ) {\n\treturn RECIPROCAL_PI * diffuseColor;\n}\nvec3 F_Schlick( const in vec3 specularColor, const in float dotLH ) {\n\tfloat fresnel = exp2( ( -5.55473 * dotLH - 6.98316 ) * dotLH );\n\treturn ( 1.0 - specularColor ) * fresnel + specularColor;\n}\nvec3 F_Schlick_RoughnessDependent( const in vec3 F0, const in float dotNV, const in float roughness ) {\n\tfloat fresnel = exp2( ( -5.55473 * dotNV - 6.98316 ) * dotNV );\n\tvec3 Fr = max( vec3( 1.0 - roughness ), F0 ) - F0;\n\treturn Fr * fresnel + F0;\n}\nfloat G_GGX_Smith( const in float alpha, const in float dotNL, const in float dotNV ) {\n\tfloat a2 = pow2( alpha );\n\tfloat gl = dotNL + sqrt( a2 + ( 1.0 - a2 ) * pow2( dotNL ) );\n\tfloat gv = dotNV + sqrt( a2 + ( 1.0 - a2 ) * pow2( dotNV ) );\n\treturn 1.0 / ( gl * gv );\n}\nfloat G_GGX_SmithCorrelated( const in float alpha, const in float dotNL, const in float dotNV ) {\n\tfloat a2 = pow2( alpha );\n\tfloat gv = dotNL * sqrt( a2 + ( 1.0 - a2 ) * pow2( dotNV ) );\n\tfloat gl = dotNV * sqrt( a2 + ( 1.0 - a2 ) * pow2( dotNL ) );\n\treturn 0.5 / max( gv + gl, EPSILON );\n}\nfloat D_GGX( const in float alpha, const in float dotNH ) {\n\tfloat a2 = pow2( alpha );\n\tfloat denom = pow2( dotNH ) * ( a2 - 1.0 ) + 1.0;\n\treturn RECIPROCAL_PI * a2 / pow2( denom );\n}\nvec3 BRDF_Specular_GGX( const in IncidentLight incidentLight, const in vec3 viewDir, const in vec3 normal, const in vec3 specularColor, const in float roughness ) {\n\tfloat alpha = pow2( roughness );\n\tvec3 halfDir = normalize( incidentLight.direction + viewDir );\n\tfloat dotNL = saturate( dot( normal, incidentLight.direction ) );\n\tfloat dotNV = saturate( dot( normal, viewDir ) );\n\tfloat dotNH = saturate( dot( normal, halfDir ) );\n\tfloat dotLH = saturate( dot( incidentLight.direction, halfDir ) );\n\tvec3 F = F_Schlick( specularColor, dotLH );\n\tfloat G = G_GGX_SmithCorrelated( alpha, dotNL, dotNV );\n\tfloat D = D_GGX( alpha, dotNH );\n\treturn F * ( G * D );\n}\nvec2 LTC_Uv( const in vec3 N, const in vec3 V, const in float roughness ) {\n\tconst float LUT_SIZE  = 64.0;\n\tconst float LUT_SCALE = ( LUT_SIZE - 1.0 ) / LUT_SIZE;\n\tconst float LUT_BIAS  = 0.5 / LUT_SIZE;\n\tfloat dotNV = saturate( dot( N, V ) );\n\tvec2 uv = vec2( roughness, sqrt( 1.0 - dotNV ) );\n\tuv = uv * LUT_SCALE + LUT_BIAS;\n\treturn uv;\n}\nfloat LTC_ClippedSphereFormFactor( const in vec3 f ) {\n\tfloat l = length( f );\n\treturn max( ( l * l + f.z ) / ( l + 1.0 ), 0.0 );\n}\nvec3 LTC_EdgeVectorFormFactor( const in vec3 v1, const in vec3 v2 ) {\n\tfloat x = dot( v1, v2 );\n\tfloat y = abs( x );\n\tfloat a = 0.8543985 + ( 0.4965155 + 0.0145206 * y ) * y;\n\tfloat b = 3.4175940 + ( 4.1616724 + y ) * y;\n\tfloat v = a / b;\n\tfloat theta_sintheta = ( x > 0.0 ) ? v : 0.5 * inversesqrt( max( 1.0 - x * x, 1e-7 ) ) - v;\n\treturn cross( v1, v2 ) * theta_sintheta;\n}\nvec3 LTC_Evaluate( const in vec3 N, const in vec3 V, const in vec3 P, const in mat3 mInv, const in vec3 rectCoords[ 4 ] ) {\n\tvec3 v1 = rectCoords[ 1 ] - rectCoords[ 0 ];\n\tvec3 v2 = rectCoords[ 3 ] - rectCoords[ 0 ];\n\tvec3 lightNormal = cross( v1, v2 );\n\tif( dot( lightNormal, P - rectCoords[ 0 ] ) < 0.0 ) return vec3( 0.0 );\n\tvec3 T1, T2;\n\tT1 = normalize( V - N * dot( V, N ) );\n\tT2 = - cross( N, T1 );\n\tmat3 mat = mInv * transposeMat3( mat3( T1, T2, N ) );\n\tvec3 coords[ 4 ];\n\tcoords[ 0 ] = mat * ( rectCoords[ 0 ] - P );\n\tcoords[ 1 ] = mat * ( rectCoords[ 1 ] - P );\n\tcoords[ 2 ] = mat * ( rectCoords[ 2 ] - P );\n\tcoords[ 3 ] = mat * ( rectCoords[ 3 ] - P );\n\tcoords[ 0 ] = normalize( coords[ 0 ] );\n\tcoords[ 1 ] = normalize( coords[ 1 ] );\n\tcoords[ 2 ] = normalize( coords[ 2 ] );\n\tcoords[ 3 ] = normalize( coords[ 3 ] );\n\tvec3 vectorFormFactor = vec3( 0.0 );\n\tvectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 0 ], coords[ 1 ] );\n\tvectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 1 ], coords[ 2 ] );\n\tvectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 2 ], coords[ 3 ] );\n\tvectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 3 ], coords[ 0 ] );\n\tfloat result = LTC_ClippedSphereFormFactor( vectorFormFactor );\n\treturn vec3( result );\n}\nvec3 BRDF_Specular_GGX_Environment( const in vec3 viewDir, const in vec3 normal, const in vec3 specularColor, const in float roughness ) {\n\tfloat dotNV = saturate( dot( normal, viewDir ) );\n\tvec2 brdf = integrateSpecularBRDF( dotNV, roughness );\n\treturn specularColor * brdf.x + brdf.y;\n}\nvoid BRDF_Specular_Multiscattering_Environment( const in GeometricContext geometry, const in vec3 specularColor, const in float roughness, inout vec3 singleScatter, inout vec3 multiScatter ) {\n\tfloat dotNV = saturate( dot( geometry.normal, geometry.viewDir ) );\n\tvec3 F = F_Schlick_RoughnessDependent( specularColor, dotNV, roughness );\n\tvec2 brdf = integrateSpecularBRDF( dotNV, roughness );\n\tvec3 FssEss = F * brdf.x + brdf.y;\n\tfloat Ess = brdf.x + brdf.y;\n\tfloat Ems = 1.0 - Ess;\n\tvec3 Favg = specularColor + ( 1.0 - specularColor ) * 0.047619;\tvec3 Fms = FssEss * Favg / ( 1.0 - Ems * Favg );\n\tsingleScatter += FssEss;\n\tmultiScatter += Fms * Ems;\n}\nfloat G_BlinnPhong_Implicit( ) {\n\treturn 0.25;\n}\nfloat D_BlinnPhong( const in float shininess, const in float dotNH ) {\n\treturn RECIPROCAL_PI * ( shininess * 0.5 + 1.0 ) * pow( dotNH, shininess );\n}\nvec3 BRDF_Specular_BlinnPhong( const in IncidentLight incidentLight, const in GeometricContext geometry, const in vec3 specularColor, const in float shininess ) {\n\tvec3 halfDir = normalize( incidentLight.direction + geometry.viewDir );\n\tfloat dotNH = saturate( dot( geometry.normal, halfDir ) );\n\tfloat dotLH = saturate( dot( incidentLight.direction, halfDir ) );\n\tvec3 F = F_Schlick( specularColor, dotLH );\n\tfloat G = G_BlinnPhong_Implicit( );\n\tfloat D = D_BlinnPhong( shininess, dotNH );\n\treturn F * ( G * D );\n}\nfloat GGXRoughnessToBlinnExponent( const in float ggxRoughness ) {\n\treturn ( 2.0 / pow2( ggxRoughness + 0.0001 ) - 2.0 );\n}\nfloat BlinnExponentToGGXRoughness( const in float blinnExponent ) {\n\treturn sqrt( 2.0 / ( blinnExponent + 2.0 ) );\n}\n#if defined( USE_SHEEN )\nfloat D_Charlie(float roughness, float NoH) {\n\tfloat invAlpha  = 1.0 / roughness;\n\tfloat cos2h = NoH * NoH;\n\tfloat sin2h = max(1.0 - cos2h, 0.0078125);\treturn (2.0 + invAlpha) * pow(sin2h, invAlpha * 0.5) / (2.0 * PI);\n}\nfloat V_Neubelt(float NoV, float NoL) {\n\treturn saturate(1.0 / (4.0 * (NoL + NoV - NoL * NoV)));\n}\nvec3 BRDF_Specular_Sheen( const in float roughness, const in vec3 L, const in GeometricContext geometry, vec3 specularColor ) {\n\tvec3 N = geometry.normal;\n\tvec3 V = geometry.viewDir;\n\tvec3 H = normalize( V + L );\n\tfloat dotNH = saturate( dot( N, H ) );\n\treturn specularColor * D_Charlie( roughness, dotNH ) * V_Neubelt( dot(N, V), dot(N, L) );\n}\n#endif",
								bumpmap_pars_fragment:
									"#ifdef USE_BUMPMAP\n\tuniform sampler2D bumpMap;\n\tuniform float bumpScale;\n\tvec2 dHdxy_fwd() {\n\t\tvec2 dSTdx = dFdx( vUv );\n\t\tvec2 dSTdy = dFdy( vUv );\n\t\tfloat Hll = bumpScale * texture2D( bumpMap, vUv ).x;\n\t\tfloat dBx = bumpScale * texture2D( bumpMap, vUv + dSTdx ).x - Hll;\n\t\tfloat dBy = bumpScale * texture2D( bumpMap, vUv + dSTdy ).x - Hll;\n\t\treturn vec2( dBx, dBy );\n\t}\n\tvec3 perturbNormalArb( vec3 surf_pos, vec3 surf_norm, vec2 dHdxy ) {\n\t\tvec3 vSigmaX = vec3( dFdx( surf_pos.x ), dFdx( surf_pos.y ), dFdx( surf_pos.z ) );\n\t\tvec3 vSigmaY = vec3( dFdy( surf_pos.x ), dFdy( surf_pos.y ), dFdy( surf_pos.z ) );\n\t\tvec3 vN = surf_norm;\n\t\tvec3 R1 = cross( vSigmaY, vN );\n\t\tvec3 R2 = cross( vN, vSigmaX );\n\t\tfloat fDet = dot( vSigmaX, R1 );\n\t\tfDet *= ( float( gl_FrontFacing ) * 2.0 - 1.0 );\n\t\tvec3 vGrad = sign( fDet ) * ( dHdxy.x * R1 + dHdxy.y * R2 );\n\t\treturn normalize( abs( fDet ) * surf_norm - vGrad );\n\t}\n#endif",
								clipping_planes_fragment:
									"#if NUM_CLIPPING_PLANES > 0\n\tvec4 plane;\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < UNION_CLIPPING_PLANES; i ++ ) {\n\t\tplane = clippingPlanes[ i ];\n\t\tif ( dot( vClipPosition, plane.xyz ) > plane.w ) discard;\n\t}\n\t#pragma unroll_loop_end\n\t#if UNION_CLIPPING_PLANES < NUM_CLIPPING_PLANES\n\t\tbool clipped = true;\n\t\t#pragma unroll_loop_start\n\t\tfor ( int i = UNION_CLIPPING_PLANES; i < NUM_CLIPPING_PLANES; i ++ ) {\n\t\t\tplane = clippingPlanes[ i ];\n\t\t\tclipped = ( dot( vClipPosition, plane.xyz ) > plane.w ) && clipped;\n\t\t}\n\t\t#pragma unroll_loop_end\n\t\tif ( clipped ) discard;\n\t#endif\n#endif",
								clipping_planes_pars_fragment:
									"#if NUM_CLIPPING_PLANES > 0\n\tvarying vec3 vClipPosition;\n\tuniform vec4 clippingPlanes[ NUM_CLIPPING_PLANES ];\n#endif",
								clipping_planes_pars_vertex:
									"#if NUM_CLIPPING_PLANES > 0\n\tvarying vec3 vClipPosition;\n#endif",
								clipping_planes_vertex:
									"#if NUM_CLIPPING_PLANES > 0\n\tvClipPosition = - mvPosition.xyz;\n#endif",
								color_fragment:
									"#ifdef USE_COLOR\n\tdiffuseColor.rgb *= vColor;\n#endif",
								color_pars_fragment:
									"#ifdef USE_COLOR\n\tvarying vec3 vColor;\n#endif",
								color_pars_vertex:
									"#ifdef USE_COLOR\n\tvarying vec3 vColor;\n#endif",
								color_vertex:
									"#ifdef USE_COLOR\n\tvColor.xyz = color.xyz;\n#endif",
								common:
									"#define PI 3.141592653589793\n#define PI2 6.283185307179586\n#define PI_HALF 1.5707963267948966\n#define RECIPROCAL_PI 0.3183098861837907\n#define RECIPROCAL_PI2 0.15915494309189535\n#define EPSILON 1e-6\n#ifndef saturate\n#define saturate(a) clamp( a, 0.0, 1.0 )\n#endif\n#define whiteComplement(a) ( 1.0 - saturate( a ) )\nfloat pow2( const in float x ) { return x*x; }\nfloat pow3( const in float x ) { return x*x*x; }\nfloat pow4( const in float x ) { float x2 = x*x; return x2*x2; }\nfloat average( const in vec3 color ) { return dot( color, vec3( 0.3333 ) ); }\nhighp float rand( const in vec2 uv ) {\n\tconst highp float a = 12.9898, b = 78.233, c = 43758.5453;\n\thighp float dt = dot( uv.xy, vec2( a,b ) ), sn = mod( dt, PI );\n\treturn fract(sin(sn) * c);\n}\n#ifdef HIGH_PRECISION\n\tfloat precisionSafeLength( vec3 v ) { return length( v ); }\n#else\n\tfloat max3( vec3 v ) { return max( max( v.x, v.y ), v.z ); }\n\tfloat precisionSafeLength( vec3 v ) {\n\t\tfloat maxComponent = max3( abs( v ) );\n\t\treturn length( v / maxComponent ) * maxComponent;\n\t}\n#endif\nstruct IncidentLight {\n\tvec3 color;\n\tvec3 direction;\n\tbool visible;\n};\nstruct ReflectedLight {\n\tvec3 directDiffuse;\n\tvec3 directSpecular;\n\tvec3 indirectDiffuse;\n\tvec3 indirectSpecular;\n};\nstruct GeometricContext {\n\tvec3 position;\n\tvec3 normal;\n\tvec3 viewDir;\n#ifdef CLEARCOAT\n\tvec3 clearcoatNormal;\n#endif\n};\nvec3 transformDirection( in vec3 dir, in mat4 matrix ) {\n\treturn normalize( ( matrix * vec4( dir, 0.0 ) ).xyz );\n}\nvec3 inverseTransformDirection( in vec3 dir, in mat4 matrix ) {\n\treturn normalize( ( vec4( dir, 0.0 ) * matrix ).xyz );\n}\nvec3 projectOnPlane(in vec3 point, in vec3 pointOnPlane, in vec3 planeNormal ) {\n\tfloat distance = dot( planeNormal, point - pointOnPlane );\n\treturn - distance * planeNormal + point;\n}\nfloat sideOfPlane( in vec3 point, in vec3 pointOnPlane, in vec3 planeNormal ) {\n\treturn sign( dot( point - pointOnPlane, planeNormal ) );\n}\nvec3 linePlaneIntersect( in vec3 pointOnLine, in vec3 lineDirection, in vec3 pointOnPlane, in vec3 planeNormal ) {\n\treturn lineDirection * ( dot( planeNormal, pointOnPlane - pointOnLine ) / dot( planeNormal, lineDirection ) ) + pointOnLine;\n}\nmat3 transposeMat3( const in mat3 m ) {\n\tmat3 tmp;\n\ttmp[ 0 ] = vec3( m[ 0 ].x, m[ 1 ].x, m[ 2 ].x );\n\ttmp[ 1 ] = vec3( m[ 0 ].y, m[ 1 ].y, m[ 2 ].y );\n\ttmp[ 2 ] = vec3( m[ 0 ].z, m[ 1 ].z, m[ 2 ].z );\n\treturn tmp;\n}\nfloat linearToRelativeLuminance( const in vec3 color ) {\n\tvec3 weights = vec3( 0.2126, 0.7152, 0.0722 );\n\treturn dot( weights, color.rgb );\n}\nbool isPerspectiveMatrix( mat4 m ) {\n\treturn m[ 2 ][ 3 ] == - 1.0;\n}\nvec2 equirectUv( in vec3 dir ) {\n\tfloat u = atan( dir.z, dir.x ) * RECIPROCAL_PI2 + 0.5;\n\tfloat v = asin( clamp( dir.y, - 1.0, 1.0 ) ) * RECIPROCAL_PI + 0.5;\n\treturn vec2( u, v );\n}",
								cube_uv_reflection_fragment:
									"#ifdef ENVMAP_TYPE_CUBE_UV\n#define cubeUV_maxMipLevel 8.0\n#define cubeUV_minMipLevel 4.0\n#define cubeUV_maxTileSize 256.0\n#define cubeUV_minTileSize 16.0\nfloat getFace(vec3 direction) {\n    vec3 absDirection = abs(direction);\n    float face = -1.0;\n    if (absDirection.x > absDirection.z) {\n      if (absDirection.x > absDirection.y)\n        face = direction.x > 0.0 ? 0.0 : 3.0;\n      else\n        face = direction.y > 0.0 ? 1.0 : 4.0;\n    } else {\n      if (absDirection.z > absDirection.y)\n        face = direction.z > 0.0 ? 2.0 : 5.0;\n      else\n        face = direction.y > 0.0 ? 1.0 : 4.0;\n    }\n    return face;\n}\nvec2 getUV(vec3 direction, float face) {\n    vec2 uv;\n    if (face == 0.0) {\n      uv = vec2(direction.z, direction.y) / abs(direction.x);    } else if (face == 1.0) {\n      uv = vec2(-direction.x, -direction.z) / abs(direction.y);    } else if (face == 2.0) {\n      uv = vec2(-direction.x, direction.y) / abs(direction.z);    } else if (face == 3.0) {\n      uv = vec2(-direction.z, direction.y) / abs(direction.x);    } else if (face == 4.0) {\n      uv = vec2(-direction.x, direction.z) / abs(direction.y);    } else {\n      uv = vec2(direction.x, direction.y) / abs(direction.z);    }\n    return 0.5 * (uv + 1.0);\n}\nvec3 bilinearCubeUV(sampler2D envMap, vec3 direction, float mipInt) {\n  float face = getFace(direction);\n  float filterInt = max(cubeUV_minMipLevel - mipInt, 0.0);\n  mipInt = max(mipInt, cubeUV_minMipLevel);\n  float faceSize = exp2(mipInt);\n  float texelSize = 1.0 / (3.0 * cubeUV_maxTileSize);\n  vec2 uv = getUV(direction, face) * (faceSize - 1.0);\n  vec2 f = fract(uv);\n  uv += 0.5 - f;\n  if (face > 2.0) {\n    uv.y += faceSize;\n    face -= 3.0;\n  }\n  uv.x += face * faceSize;\n  if(mipInt < cubeUV_maxMipLevel){\n    uv.y += 2.0 * cubeUV_maxTileSize;\n  }\n  uv.y += filterInt * 2.0 * cubeUV_minTileSize;\n  uv.x += 3.0 * max(0.0, cubeUV_maxTileSize - 2.0 * faceSize);\n  uv *= texelSize;\n  vec3 tl = envMapTexelToLinear(texture2D(envMap, uv)).rgb;\n  uv.x += texelSize;\n  vec3 tr = envMapTexelToLinear(texture2D(envMap, uv)).rgb;\n  uv.y += texelSize;\n  vec3 br = envMapTexelToLinear(texture2D(envMap, uv)).rgb;\n  uv.x -= texelSize;\n  vec3 bl = envMapTexelToLinear(texture2D(envMap, uv)).rgb;\n  vec3 tm = mix(tl, tr, f.x);\n  vec3 bm = mix(bl, br, f.x);\n  return mix(tm, bm, f.y);\n}\n#define r0 1.0\n#define v0 0.339\n#define m0 -2.0\n#define r1 0.8\n#define v1 0.276\n#define m1 -1.0\n#define r4 0.4\n#define v4 0.046\n#define m4 2.0\n#define r5 0.305\n#define v5 0.016\n#define m5 3.0\n#define r6 0.21\n#define v6 0.0038\n#define m6 4.0\nfloat roughnessToMip(float roughness) {\n  float mip = 0.0;\n  if (roughness >= r1) {\n    mip = (r0 - roughness) * (m1 - m0) / (r0 - r1) + m0;\n  } else if (roughness >= r4) {\n    mip = (r1 - roughness) * (m4 - m1) / (r1 - r4) + m1;\n  } else if (roughness >= r5) {\n    mip = (r4 - roughness) * (m5 - m4) / (r4 - r5) + m4;\n  } else if (roughness >= r6) {\n    mip = (r5 - roughness) * (m6 - m5) / (r5 - r6) + m5;\n  } else {\n    mip = -2.0 * log2(1.16 * roughness);  }\n  return mip;\n}\nvec4 textureCubeUV(sampler2D envMap, vec3 sampleDir, float roughness) {\n  float mip = clamp(roughnessToMip(roughness), m0, cubeUV_maxMipLevel);\n  float mipF = fract(mip);\n  float mipInt = floor(mip);\n  vec3 color0 = bilinearCubeUV(envMap, sampleDir, mipInt);\n  if (mipF == 0.0) {\n    return vec4(color0, 1.0);\n  } else {\n    vec3 color1 = bilinearCubeUV(envMap, sampleDir, mipInt + 1.0);\n    return vec4(mix(color0, color1, mipF), 1.0);\n  }\n}\n#endif",
								defaultnormal_vertex:
									"vec3 transformedNormal = objectNormal;\n#ifdef USE_INSTANCING\n\tmat3 m = mat3( instanceMatrix );\n\ttransformedNormal /= vec3( dot( m[ 0 ], m[ 0 ] ), dot( m[ 1 ], m[ 1 ] ), dot( m[ 2 ], m[ 2 ] ) );\n\ttransformedNormal = m * transformedNormal;\n#endif\ntransformedNormal = normalMatrix * transformedNormal;\n#ifdef FLIP_SIDED\n\ttransformedNormal = - transformedNormal;\n#endif\n#ifdef USE_TANGENT\n\tvec3 transformedTangent = ( modelViewMatrix * vec4( objectTangent, 0.0 ) ).xyz;\n\t#ifdef FLIP_SIDED\n\t\ttransformedTangent = - transformedTangent;\n\t#endif\n#endif",
								displacementmap_pars_vertex:
									"#ifdef USE_DISPLACEMENTMAP\n\tuniform sampler2D displacementMap;\n\tuniform float displacementScale;\n\tuniform float displacementBias;\n#endif",
								displacementmap_vertex:
									"#ifdef USE_DISPLACEMENTMAP\n\ttransformed += normalize( objectNormal ) * ( texture2D( displacementMap, vUv ).x * displacementScale + displacementBias );\n#endif",
								emissivemap_fragment:
									"#ifdef USE_EMISSIVEMAP\n\tvec4 emissiveColor = texture2D( emissiveMap, vUv );\n\temissiveColor.rgb = emissiveMapTexelToLinear( emissiveColor ).rgb;\n\ttotalEmissiveRadiance *= emissiveColor.rgb;\n#endif",
								emissivemap_pars_fragment:
									"#ifdef USE_EMISSIVEMAP\n\tuniform sampler2D emissiveMap;\n#endif",
								encodings_fragment:
									"gl_FragColor = linearToOutputTexel( gl_FragColor );",
								encodings_pars_fragment:
									"\nvec4 LinearToLinear( in vec4 value ) {\n\treturn value;\n}\nvec4 GammaToLinear( in vec4 value, in float gammaFactor ) {\n\treturn vec4( pow( value.rgb, vec3( gammaFactor ) ), value.a );\n}\nvec4 LinearToGamma( in vec4 value, in float gammaFactor ) {\n\treturn vec4( pow( value.rgb, vec3( 1.0 / gammaFactor ) ), value.a );\n}\nvec4 sRGBToLinear( in vec4 value ) {\n\treturn vec4( mix( pow( value.rgb * 0.9478672986 + vec3( 0.0521327014 ), vec3( 2.4 ) ), value.rgb * 0.0773993808, vec3( lessThanEqual( value.rgb, vec3( 0.04045 ) ) ) ), value.a );\n}\nvec4 LinearTosRGB( in vec4 value ) {\n\treturn vec4( mix( pow( value.rgb, vec3( 0.41666 ) ) * 1.055 - vec3( 0.055 ), value.rgb * 12.92, vec3( lessThanEqual( value.rgb, vec3( 0.0031308 ) ) ) ), value.a );\n}\nvec4 RGBEToLinear( in vec4 value ) {\n\treturn vec4( value.rgb * exp2( value.a * 255.0 - 128.0 ), 1.0 );\n}\nvec4 LinearToRGBE( in vec4 value ) {\n\tfloat maxComponent = max( max( value.r, value.g ), value.b );\n\tfloat fExp = clamp( ceil( log2( maxComponent ) ), -128.0, 127.0 );\n\treturn vec4( value.rgb / exp2( fExp ), ( fExp + 128.0 ) / 255.0 );\n}\nvec4 RGBMToLinear( in vec4 value, in float maxRange ) {\n\treturn vec4( value.rgb * value.a * maxRange, 1.0 );\n}\nvec4 LinearToRGBM( in vec4 value, in float maxRange ) {\n\tfloat maxRGB = max( value.r, max( value.g, value.b ) );\n\tfloat M = clamp( maxRGB / maxRange, 0.0, 1.0 );\n\tM = ceil( M * 255.0 ) / 255.0;\n\treturn vec4( value.rgb / ( M * maxRange ), M );\n}\nvec4 RGBDToLinear( in vec4 value, in float maxRange ) {\n\treturn vec4( value.rgb * ( ( maxRange / 255.0 ) / value.a ), 1.0 );\n}\nvec4 LinearToRGBD( in vec4 value, in float maxRange ) {\n\tfloat maxRGB = max( value.r, max( value.g, value.b ) );\n\tfloat D = max( maxRange / maxRGB, 1.0 );\n\tD = clamp( floor( D ) / 255.0, 0.0, 1.0 );\n\treturn vec4( value.rgb * ( D * ( 255.0 / maxRange ) ), D );\n}\nconst mat3 cLogLuvM = mat3( 0.2209, 0.3390, 0.4184, 0.1138, 0.6780, 0.7319, 0.0102, 0.1130, 0.2969 );\nvec4 LinearToLogLuv( in vec4 value )  {\n\tvec3 Xp_Y_XYZp = cLogLuvM * value.rgb;\n\tXp_Y_XYZp = max( Xp_Y_XYZp, vec3( 1e-6, 1e-6, 1e-6 ) );\n\tvec4 vResult;\n\tvResult.xy = Xp_Y_XYZp.xy / Xp_Y_XYZp.z;\n\tfloat Le = 2.0 * log2(Xp_Y_XYZp.y) + 127.0;\n\tvResult.w = fract( Le );\n\tvResult.z = ( Le - ( floor( vResult.w * 255.0 ) ) / 255.0 ) / 255.0;\n\treturn vResult;\n}\nconst mat3 cLogLuvInverseM = mat3( 6.0014, -2.7008, -1.7996, -1.3320, 3.1029, -5.7721, 0.3008, -1.0882, 5.6268 );\nvec4 LogLuvToLinear( in vec4 value ) {\n\tfloat Le = value.z * 255.0 + value.w;\n\tvec3 Xp_Y_XYZp;\n\tXp_Y_XYZp.y = exp2( ( Le - 127.0 ) / 2.0 );\n\tXp_Y_XYZp.z = Xp_Y_XYZp.y / value.y;\n\tXp_Y_XYZp.x = value.x * Xp_Y_XYZp.z;\n\tvec3 vRGB = cLogLuvInverseM * Xp_Y_XYZp.rgb;\n\treturn vec4( max( vRGB, 0.0 ), 1.0 );\n}",
								envmap_fragment:
									"#ifdef USE_ENVMAP\n\t#ifdef ENV_WORLDPOS\n\t\tvec3 cameraToFrag;\n\t\t\n\t\tif ( isOrthographic ) {\n\t\t\tcameraToFrag = normalize( vec3( - viewMatrix[ 0 ][ 2 ], - viewMatrix[ 1 ][ 2 ], - viewMatrix[ 2 ][ 2 ] ) );\n\t\t}  else {\n\t\t\tcameraToFrag = normalize( vWorldPosition - cameraPosition );\n\t\t}\n\t\tvec3 worldNormal = inverseTransformDirection( normal, viewMatrix );\n\t\t#ifdef ENVMAP_MODE_REFLECTION\n\t\t\tvec3 reflectVec = reflect( cameraToFrag, worldNormal );\n\t\t#else\n\t\t\tvec3 reflectVec = refract( cameraToFrag, worldNormal, refractionRatio );\n\t\t#endif\n\t#else\n\t\tvec3 reflectVec = vReflect;\n\t#endif\n\t#ifdef ENVMAP_TYPE_CUBE\n\t\tvec4 envColor = textureCube( envMap, vec3( flipEnvMap * reflectVec.x, reflectVec.yz ) );\n\t#elif defined( ENVMAP_TYPE_CUBE_UV )\n\t\tvec4 envColor = textureCubeUV( envMap, reflectVec, 0.0 );\n\t#elif defined( ENVMAP_TYPE_EQUIREC )\n\t\treflectVec = normalize( reflectVec );\n\t\tvec2 sampleUV = equirectUv( reflectVec );\n\t\tvec4 envColor = texture2D( envMap, sampleUV );\n\t#else\n\t\tvec4 envColor = vec4( 0.0 );\n\t#endif\n\t#ifndef ENVMAP_TYPE_CUBE_UV\n\t\tenvColor = envMapTexelToLinear( envColor );\n\t#endif\n\t#ifdef ENVMAP_BLENDING_MULTIPLY\n\t\toutgoingLight = mix( outgoingLight, outgoingLight * envColor.xyz, specularStrength * reflectivity );\n\t#elif defined( ENVMAP_BLENDING_MIX )\n\t\toutgoingLight = mix( outgoingLight, envColor.xyz, specularStrength * reflectivity );\n\t#elif defined( ENVMAP_BLENDING_ADD )\n\t\toutgoingLight += envColor.xyz * specularStrength * reflectivity;\n\t#endif\n#endif",
								envmap_common_pars_fragment:
									"#ifdef USE_ENVMAP\n\tuniform float envMapIntensity;\n\tuniform float flipEnvMap;\n\tuniform int maxMipLevel;\n\t#ifdef ENVMAP_TYPE_CUBE\n\t\tuniform samplerCube envMap;\n\t#else\n\t\tuniform sampler2D envMap;\n\t#endif\n\t\n#endif",
								envmap_pars_fragment:
									"#ifdef USE_ENVMAP\n\tuniform float reflectivity;\n\t#if defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( PHONG )\n\t\t#define ENV_WORLDPOS\n\t#endif\n\t#ifdef ENV_WORLDPOS\n\t\tvarying vec3 vWorldPosition;\n\t\tuniform float refractionRatio;\n\t#else\n\t\tvarying vec3 vReflect;\n\t#endif\n#endif",
								envmap_pars_vertex:
									"#ifdef USE_ENVMAP\n\t#if defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) ||defined( PHONG )\n\t\t#define ENV_WORLDPOS\n\t#endif\n\t#ifdef ENV_WORLDPOS\n\t\t\n\t\tvarying vec3 vWorldPosition;\n\t#else\n\t\tvarying vec3 vReflect;\n\t\tuniform float refractionRatio;\n\t#endif\n#endif",
								envmap_physical_pars_fragment:
									"#if defined( USE_ENVMAP )\n\t#ifdef ENVMAP_MODE_REFRACTION\n\t\tuniform float refractionRatio;\n\t#endif\n\tvec3 getLightProbeIndirectIrradiance( const in GeometricContext geometry, const in int maxMIPLevel ) {\n\t\tvec3 worldNormal = inverseTransformDirection( geometry.normal, viewMatrix );\n\t\t#ifdef ENVMAP_TYPE_CUBE\n\t\t\tvec3 queryVec = vec3( flipEnvMap * worldNormal.x, worldNormal.yz );\n\t\t\t#ifdef TEXTURE_LOD_EXT\n\t\t\t\tvec4 envMapColor = textureCubeLodEXT( envMap, queryVec, float( maxMIPLevel ) );\n\t\t\t#else\n\t\t\t\tvec4 envMapColor = textureCube( envMap, queryVec, float( maxMIPLevel ) );\n\t\t\t#endif\n\t\t\tenvMapColor.rgb = envMapTexelToLinear( envMapColor ).rgb;\n\t\t#elif defined( ENVMAP_TYPE_CUBE_UV )\n\t\t\tvec4 envMapColor = textureCubeUV( envMap, worldNormal, 1.0 );\n\t\t#else\n\t\t\tvec4 envMapColor = vec4( 0.0 );\n\t\t#endif\n\t\treturn PI * envMapColor.rgb * envMapIntensity;\n\t}\n\tfloat getSpecularMIPLevel( const in float roughness, const in int maxMIPLevel ) {\n\t\tfloat maxMIPLevelScalar = float( maxMIPLevel );\n\t\tfloat sigma = PI * roughness * roughness / ( 1.0 + roughness );\n\t\tfloat desiredMIPLevel = maxMIPLevelScalar + log2( sigma );\n\t\treturn clamp( desiredMIPLevel, 0.0, maxMIPLevelScalar );\n\t}\n\tvec3 getLightProbeIndirectRadiance( const in vec3 viewDir, const in vec3 normal, const in float roughness, const in int maxMIPLevel ) {\n\t\t#ifdef ENVMAP_MODE_REFLECTION\n\t\t  vec3 reflectVec = reflect( -viewDir, normal );\n\t\t  reflectVec = normalize( mix( reflectVec, normal, roughness * roughness) );\n\t\t#else\n\t\t  vec3 reflectVec = refract( -viewDir, normal, refractionRatio );\n\t\t#endif\n\t\treflectVec = inverseTransformDirection( reflectVec, viewMatrix );\n\t\tfloat specularMIPLevel = getSpecularMIPLevel( roughness, maxMIPLevel );\n\t\t#ifdef ENVMAP_TYPE_CUBE\n\t\t\tvec3 queryReflectVec = vec3( flipEnvMap * reflectVec.x, reflectVec.yz );\n\t\t\t#ifdef TEXTURE_LOD_EXT\n\t\t\t\tvec4 envMapColor = textureCubeLodEXT( envMap, queryReflectVec, specularMIPLevel );\n\t\t\t#else\n\t\t\t\tvec4 envMapColor = textureCube( envMap, queryReflectVec, specularMIPLevel );\n\t\t\t#endif\n\t\t\tenvMapColor.rgb = envMapTexelToLinear( envMapColor ).rgb;\n\t\t#elif defined( ENVMAP_TYPE_CUBE_UV )\n\t\t\tvec4 envMapColor = textureCubeUV( envMap, reflectVec, roughness );\n\t\t#elif defined( ENVMAP_TYPE_EQUIREC )\n\t\t\tvec2 sampleUV = equirectUv( reflectVec );\n\t\t\t#ifdef TEXTURE_LOD_EXT\n\t\t\t\tvec4 envMapColor = texture2DLodEXT( envMap, sampleUV, specularMIPLevel );\n\t\t\t#else\n\t\t\t\tvec4 envMapColor = texture2D( envMap, sampleUV, specularMIPLevel );\n\t\t\t#endif\n\t\t\tenvMapColor.rgb = envMapTexelToLinear( envMapColor ).rgb;\n\t\t#endif\n\t\treturn envMapColor.rgb * envMapIntensity;\n\t}\n#endif",
								envmap_vertex:
									"#ifdef USE_ENVMAP\n\t#ifdef ENV_WORLDPOS\n\t\tvWorldPosition = worldPosition.xyz;\n\t#else\n\t\tvec3 cameraToVertex;\n\t\tif ( isOrthographic ) {\n\t\t\tcameraToVertex = normalize( vec3( - viewMatrix[ 0 ][ 2 ], - viewMatrix[ 1 ][ 2 ], - viewMatrix[ 2 ][ 2 ] ) );\n\t\t} else {\n\t\t\tcameraToVertex = normalize( worldPosition.xyz - cameraPosition );\n\t\t}\n\t\tvec3 worldNormal = inverseTransformDirection( transformedNormal, viewMatrix );\n\t\t#ifdef ENVMAP_MODE_REFLECTION\n\t\t\tvReflect = reflect( cameraToVertex, worldNormal );\n\t\t#else\n\t\t\tvReflect = refract( cameraToVertex, worldNormal, refractionRatio );\n\t\t#endif\n\t#endif\n#endif",
								fog_vertex:
									"#ifdef USE_FOG\n\tfogDepth = - mvPosition.z;\n#endif",
								fog_pars_vertex:
									"#ifdef USE_FOG\n\tvarying float fogDepth;\n#endif",
								fog_fragment:
									"#ifdef USE_FOG\n\t#ifdef FOG_EXP2\n\t\tfloat fogFactor = 1.0 - exp( - fogDensity * fogDensity * fogDepth * fogDepth );\n\t#else\n\t\tfloat fogFactor = smoothstep( fogNear, fogFar, fogDepth );\n\t#endif\n\tgl_FragColor.rgb = mix( gl_FragColor.rgb, fogColor, fogFactor );\n#endif",
								fog_pars_fragment:
									"#ifdef USE_FOG\n\tuniform vec3 fogColor;\n\tvarying float fogDepth;\n\t#ifdef FOG_EXP2\n\t\tuniform float fogDensity;\n\t#else\n\t\tuniform float fogNear;\n\t\tuniform float fogFar;\n\t#endif\n#endif",
								gradientmap_pars_fragment:
									"#ifdef USE_GRADIENTMAP\n\tuniform sampler2D gradientMap;\n#endif\nvec3 getGradientIrradiance( vec3 normal, vec3 lightDirection ) {\n\tfloat dotNL = dot( normal, lightDirection );\n\tvec2 coord = vec2( dotNL * 0.5 + 0.5, 0.0 );\n\t#ifdef USE_GRADIENTMAP\n\t\treturn texture2D( gradientMap, coord ).rgb;\n\t#else\n\t\treturn ( coord.x < 0.7 ) ? vec3( 0.7 ) : vec3( 1.0 );\n\t#endif\n}",
								lightmap_fragment:
									"#ifdef USE_LIGHTMAP\n\tvec4 lightMapTexel= texture2D( lightMap, vUv2 );\n\treflectedLight.indirectDiffuse += PI * lightMapTexelToLinear( lightMapTexel ).rgb * lightMapIntensity;\n#endif",
								lightmap_pars_fragment:
									"#ifdef USE_LIGHTMAP\n\tuniform sampler2D lightMap;\n\tuniform float lightMapIntensity;\n#endif",
								lights_lambert_vertex:
									"vec3 diffuse = vec3( 1.0 );\nGeometricContext geometry;\ngeometry.position = mvPosition.xyz;\ngeometry.normal = normalize( transformedNormal );\ngeometry.viewDir = ( isOrthographic ) ? vec3( 0, 0, 1 ) : normalize( -mvPosition.xyz );\nGeometricContext backGeometry;\nbackGeometry.position = geometry.position;\nbackGeometry.normal = -geometry.normal;\nbackGeometry.viewDir = geometry.viewDir;\nvLightFront = vec3( 0.0 );\nvIndirectFront = vec3( 0.0 );\n#ifdef DOUBLE_SIDED\n\tvLightBack = vec3( 0.0 );\n\tvIndirectBack = vec3( 0.0 );\n#endif\nIncidentLight directLight;\nfloat dotNL;\nvec3 directLightColor_Diffuse;\nvIndirectFront += getAmbientLightIrradiance( ambientLightColor );\nvIndirectFront += getLightProbeIrradiance( lightProbe, geometry );\n#ifdef DOUBLE_SIDED\n\tvIndirectBack += getAmbientLightIrradiance( ambientLightColor );\n\tvIndirectBack += getLightProbeIrradiance( lightProbe, backGeometry );\n#endif\n#if NUM_POINT_LIGHTS > 0\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_POINT_LIGHTS; i ++ ) {\n\t\tgetPointDirectLightIrradiance( pointLights[ i ], geometry, directLight );\n\t\tdotNL = dot( geometry.normal, directLight.direction );\n\t\tdirectLightColor_Diffuse = PI * directLight.color;\n\t\tvLightFront += saturate( dotNL ) * directLightColor_Diffuse;\n\t\t#ifdef DOUBLE_SIDED\n\t\t\tvLightBack += saturate( -dotNL ) * directLightColor_Diffuse;\n\t\t#endif\n\t}\n\t#pragma unroll_loop_end\n#endif\n#if NUM_SPOT_LIGHTS > 0\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_SPOT_LIGHTS; i ++ ) {\n\t\tgetSpotDirectLightIrradiance( spotLights[ i ], geometry, directLight );\n\t\tdotNL = dot( geometry.normal, directLight.direction );\n\t\tdirectLightColor_Diffuse = PI * directLight.color;\n\t\tvLightFront += saturate( dotNL ) * directLightColor_Diffuse;\n\t\t#ifdef DOUBLE_SIDED\n\t\t\tvLightBack += saturate( -dotNL ) * directLightColor_Diffuse;\n\t\t#endif\n\t}\n\t#pragma unroll_loop_end\n#endif\n#if NUM_DIR_LIGHTS > 0\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_DIR_LIGHTS; i ++ ) {\n\t\tgetDirectionalDirectLightIrradiance( directionalLights[ i ], geometry, directLight );\n\t\tdotNL = dot( geometry.normal, directLight.direction );\n\t\tdirectLightColor_Diffuse = PI * directLight.color;\n\t\tvLightFront += saturate( dotNL ) * directLightColor_Diffuse;\n\t\t#ifdef DOUBLE_SIDED\n\t\t\tvLightBack += saturate( -dotNL ) * directLightColor_Diffuse;\n\t\t#endif\n\t}\n\t#pragma unroll_loop_end\n#endif\n#if NUM_HEMI_LIGHTS > 0\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_HEMI_LIGHTS; i ++ ) {\n\t\tvIndirectFront += getHemisphereLightIrradiance( hemisphereLights[ i ], geometry );\n\t\t#ifdef DOUBLE_SIDED\n\t\t\tvIndirectBack += getHemisphereLightIrradiance( hemisphereLights[ i ], backGeometry );\n\t\t#endif\n\t}\n\t#pragma unroll_loop_end\n#endif",
								lights_pars_begin:
									"uniform bool receiveShadow;\nuniform vec3 ambientLightColor;\nuniform vec3 lightProbe[ 9 ];\nvec3 shGetIrradianceAt( in vec3 normal, in vec3 shCoefficients[ 9 ] ) {\n\tfloat x = normal.x, y = normal.y, z = normal.z;\n\tvec3 result = shCoefficients[ 0 ] * 0.886227;\n\tresult += shCoefficients[ 1 ] * 2.0 * 0.511664 * y;\n\tresult += shCoefficients[ 2 ] * 2.0 * 0.511664 * z;\n\tresult += shCoefficients[ 3 ] * 2.0 * 0.511664 * x;\n\tresult += shCoefficients[ 4 ] * 2.0 * 0.429043 * x * y;\n\tresult += shCoefficients[ 5 ] * 2.0 * 0.429043 * y * z;\n\tresult += shCoefficients[ 6 ] * ( 0.743125 * z * z - 0.247708 );\n\tresult += shCoefficients[ 7 ] * 2.0 * 0.429043 * x * z;\n\tresult += shCoefficients[ 8 ] * 0.429043 * ( x * x - y * y );\n\treturn result;\n}\nvec3 getLightProbeIrradiance( const in vec3 lightProbe[ 9 ], const in GeometricContext geometry ) {\n\tvec3 worldNormal = inverseTransformDirection( geometry.normal, viewMatrix );\n\tvec3 irradiance = shGetIrradianceAt( worldNormal, lightProbe );\n\treturn irradiance;\n}\nvec3 getAmbientLightIrradiance( const in vec3 ambientLightColor ) {\n\tvec3 irradiance = ambientLightColor;\n\t#ifndef PHYSICALLY_CORRECT_LIGHTS\n\t\tirradiance *= PI;\n\t#endif\n\treturn irradiance;\n}\n#if NUM_DIR_LIGHTS > 0\n\tstruct DirectionalLight {\n\t\tvec3 direction;\n\t\tvec3 color;\n\t};\n\tuniform DirectionalLight directionalLights[ NUM_DIR_LIGHTS ];\n\tvoid getDirectionalDirectLightIrradiance( const in DirectionalLight directionalLight, const in GeometricContext geometry, out IncidentLight directLight ) {\n\t\tdirectLight.color = directionalLight.color;\n\t\tdirectLight.direction = directionalLight.direction;\n\t\tdirectLight.visible = true;\n\t}\n#endif\n#if NUM_POINT_LIGHTS > 0\n\tstruct PointLight {\n\t\tvec3 position;\n\t\tvec3 color;\n\t\tfloat distance;\n\t\tfloat decay;\n\t};\n\tuniform PointLight pointLights[ NUM_POINT_LIGHTS ];\n\tvoid getPointDirectLightIrradiance( const in PointLight pointLight, const in GeometricContext geometry, out IncidentLight directLight ) {\n\t\tvec3 lVector = pointLight.position - geometry.position;\n\t\tdirectLight.direction = normalize( lVector );\n\t\tfloat lightDistance = length( lVector );\n\t\tdirectLight.color = pointLight.color;\n\t\tdirectLight.color *= punctualLightIntensityToIrradianceFactor( lightDistance, pointLight.distance, pointLight.decay );\n\t\tdirectLight.visible = ( directLight.color != vec3( 0.0 ) );\n\t}\n#endif\n#if NUM_SPOT_LIGHTS > 0\n\tstruct SpotLight {\n\t\tvec3 position;\n\t\tvec3 direction;\n\t\tvec3 color;\n\t\tfloat distance;\n\t\tfloat decay;\n\t\tfloat coneCos;\n\t\tfloat penumbraCos;\n\t};\n\tuniform SpotLight spotLights[ NUM_SPOT_LIGHTS ];\n\tvoid getSpotDirectLightIrradiance( const in SpotLight spotLight, const in GeometricContext geometry, out IncidentLight directLight  ) {\n\t\tvec3 lVector = spotLight.position - geometry.position;\n\t\tdirectLight.direction = normalize( lVector );\n\t\tfloat lightDistance = length( lVector );\n\t\tfloat angleCos = dot( directLight.direction, spotLight.direction );\n\t\tif ( angleCos > spotLight.coneCos ) {\n\t\t\tfloat spotEffect = smoothstep( spotLight.coneCos, spotLight.penumbraCos, angleCos );\n\t\t\tdirectLight.color = spotLight.color;\n\t\t\tdirectLight.color *= spotEffect * punctualLightIntensityToIrradianceFactor( lightDistance, spotLight.distance, spotLight.decay );\n\t\t\tdirectLight.visible = true;\n\t\t} else {\n\t\t\tdirectLight.color = vec3( 0.0 );\n\t\t\tdirectLight.visible = false;\n\t\t}\n\t}\n#endif\n#if NUM_RECT_AREA_LIGHTS > 0\n\tstruct RectAreaLight {\n\t\tvec3 color;\n\t\tvec3 position;\n\t\tvec3 halfWidth;\n\t\tvec3 halfHeight;\n\t};\n\tuniform sampler2D ltc_1;\tuniform sampler2D ltc_2;\n\tuniform RectAreaLight rectAreaLights[ NUM_RECT_AREA_LIGHTS ];\n#endif\n#if NUM_HEMI_LIGHTS > 0\n\tstruct HemisphereLight {\n\t\tvec3 direction;\n\t\tvec3 skyColor;\n\t\tvec3 groundColor;\n\t};\n\tuniform HemisphereLight hemisphereLights[ NUM_HEMI_LIGHTS ];\n\tvec3 getHemisphereLightIrradiance( const in HemisphereLight hemiLight, const in GeometricContext geometry ) {\n\t\tfloat dotNL = dot( geometry.normal, hemiLight.direction );\n\t\tfloat hemiDiffuseWeight = 0.5 * dotNL + 0.5;\n\t\tvec3 irradiance = mix( hemiLight.groundColor, hemiLight.skyColor, hemiDiffuseWeight );\n\t\t#ifndef PHYSICALLY_CORRECT_LIGHTS\n\t\t\tirradiance *= PI;\n\t\t#endif\n\t\treturn irradiance;\n\t}\n#endif",
								lights_toon_fragment:
									"ToonMaterial material;\nmaterial.diffuseColor = diffuseColor.rgb;",
								lights_toon_pars_fragment:
									"varying vec3 vViewPosition;\n#ifndef FLAT_SHADED\n\tvarying vec3 vNormal;\n#endif\nstruct ToonMaterial {\n\tvec3 diffuseColor;\n};\nvoid RE_Direct_Toon( const in IncidentLight directLight, const in GeometricContext geometry, const in ToonMaterial material, inout ReflectedLight reflectedLight ) {\n\tvec3 irradiance = getGradientIrradiance( geometry.normal, directLight.direction ) * directLight.color;\n\t#ifndef PHYSICALLY_CORRECT_LIGHTS\n\t\tirradiance *= PI;\n\t#endif\n\treflectedLight.directDiffuse += irradiance * BRDF_Diffuse_Lambert( material.diffuseColor );\n}\nvoid RE_IndirectDiffuse_Toon( const in vec3 irradiance, const in GeometricContext geometry, const in ToonMaterial material, inout ReflectedLight reflectedLight ) {\n\treflectedLight.indirectDiffuse += irradiance * BRDF_Diffuse_Lambert( material.diffuseColor );\n}\n#define RE_Direct\t\t\t\tRE_Direct_Toon\n#define RE_IndirectDiffuse\t\tRE_IndirectDiffuse_Toon\n#define Material_LightProbeLOD( material )\t(0)",
								lights_phong_fragment:
									"BlinnPhongMaterial material;\nmaterial.diffuseColor = diffuseColor.rgb;\nmaterial.specularColor = specular;\nmaterial.specularShininess = shininess;\nmaterial.specularStrength = specularStrength;",
								lights_phong_pars_fragment:
									"varying vec3 vViewPosition;\n#ifndef FLAT_SHADED\n\tvarying vec3 vNormal;\n#endif\nstruct BlinnPhongMaterial {\n\tvec3 diffuseColor;\n\tvec3 specularColor;\n\tfloat specularShininess;\n\tfloat specularStrength;\n};\nvoid RE_Direct_BlinnPhong( const in IncidentLight directLight, const in GeometricContext geometry, const in BlinnPhongMaterial material, inout ReflectedLight reflectedLight ) {\n\tfloat dotNL = saturate( dot( geometry.normal, directLight.direction ) );\n\tvec3 irradiance = dotNL * directLight.color;\n\t#ifndef PHYSICALLY_CORRECT_LIGHTS\n\t\tirradiance *= PI;\n\t#endif\n\treflectedLight.directDiffuse += irradiance * BRDF_Diffuse_Lambert( material.diffuseColor );\n\treflectedLight.directSpecular += irradiance * BRDF_Specular_BlinnPhong( directLight, geometry, material.specularColor, material.specularShininess ) * material.specularStrength;\n}\nvoid RE_IndirectDiffuse_BlinnPhong( const in vec3 irradiance, const in GeometricContext geometry, const in BlinnPhongMaterial material, inout ReflectedLight reflectedLight ) {\n\treflectedLight.indirectDiffuse += irradiance * BRDF_Diffuse_Lambert( material.diffuseColor );\n}\n#define RE_Direct\t\t\t\tRE_Direct_BlinnPhong\n#define RE_IndirectDiffuse\t\tRE_IndirectDiffuse_BlinnPhong\n#define Material_LightProbeLOD( material )\t(0)",
								lights_physical_fragment:
									"PhysicalMaterial material;\nmaterial.diffuseColor = diffuseColor.rgb * ( 1.0 - metalnessFactor );\nvec3 dxy = max( abs( dFdx( geometryNormal ) ), abs( dFdy( geometryNormal ) ) );\nfloat geometryRoughness = max( max( dxy.x, dxy.y ), dxy.z );\nmaterial.specularRoughness = max( roughnessFactor, 0.0525 );material.specularRoughness += geometryRoughness;\nmaterial.specularRoughness = min( material.specularRoughness, 1.0 );\n#ifdef REFLECTIVITY\n\tmaterial.specularColor = mix( vec3( MAXIMUM_SPECULAR_COEFFICIENT * pow2( reflectivity ) ), diffuseColor.rgb, metalnessFactor );\n#else\n\tmaterial.specularColor = mix( vec3( DEFAULT_SPECULAR_COEFFICIENT ), diffuseColor.rgb, metalnessFactor );\n#endif\n#ifdef CLEARCOAT\n\tmaterial.clearcoat = clearcoat;\n\tmaterial.clearcoatRoughness = clearcoatRoughness;\n\t#ifdef USE_CLEARCOATMAP\n\t\tmaterial.clearcoat *= texture2D( clearcoatMap, vUv ).x;\n\t#endif\n\t#ifdef USE_CLEARCOAT_ROUGHNESSMAP\n\t\tmaterial.clearcoatRoughness *= texture2D( clearcoatRoughnessMap, vUv ).y;\n\t#endif\n\tmaterial.clearcoat = saturate( material.clearcoat );\tmaterial.clearcoatRoughness = max( material.clearcoatRoughness, 0.0525 );\n\tmaterial.clearcoatRoughness += geometryRoughness;\n\tmaterial.clearcoatRoughness = min( material.clearcoatRoughness, 1.0 );\n#endif\n#ifdef USE_SHEEN\n\tmaterial.sheenColor = sheen;\n#endif",
								lights_physical_pars_fragment:
									"struct PhysicalMaterial {\n\tvec3 diffuseColor;\n\tfloat specularRoughness;\n\tvec3 specularColor;\n#ifdef CLEARCOAT\n\tfloat clearcoat;\n\tfloat clearcoatRoughness;\n#endif\n#ifdef USE_SHEEN\n\tvec3 sheenColor;\n#endif\n};\n#define MAXIMUM_SPECULAR_COEFFICIENT 0.16\n#define DEFAULT_SPECULAR_COEFFICIENT 0.04\nfloat clearcoatDHRApprox( const in float roughness, const in float dotNL ) {\n\treturn DEFAULT_SPECULAR_COEFFICIENT + ( 1.0 - DEFAULT_SPECULAR_COEFFICIENT ) * ( pow( 1.0 - dotNL, 5.0 ) * pow( 1.0 - roughness, 2.0 ) );\n}\n#if NUM_RECT_AREA_LIGHTS > 0\n\tvoid RE_Direct_RectArea_Physical( const in RectAreaLight rectAreaLight, const in GeometricContext geometry, const in PhysicalMaterial material, inout ReflectedLight reflectedLight ) {\n\t\tvec3 normal = geometry.normal;\n\t\tvec3 viewDir = geometry.viewDir;\n\t\tvec3 position = geometry.position;\n\t\tvec3 lightPos = rectAreaLight.position;\n\t\tvec3 halfWidth = rectAreaLight.halfWidth;\n\t\tvec3 halfHeight = rectAreaLight.halfHeight;\n\t\tvec3 lightColor = rectAreaLight.color;\n\t\tfloat roughness = material.specularRoughness;\n\t\tvec3 rectCoords[ 4 ];\n\t\trectCoords[ 0 ] = lightPos + halfWidth - halfHeight;\t\trectCoords[ 1 ] = lightPos - halfWidth - halfHeight;\n\t\trectCoords[ 2 ] = lightPos - halfWidth + halfHeight;\n\t\trectCoords[ 3 ] = lightPos + halfWidth + halfHeight;\n\t\tvec2 uv = LTC_Uv( normal, viewDir, roughness );\n\t\tvec4 t1 = texture2D( ltc_1, uv );\n\t\tvec4 t2 = texture2D( ltc_2, uv );\n\t\tmat3 mInv = mat3(\n\t\t\tvec3( t1.x, 0, t1.y ),\n\t\t\tvec3(    0, 1,    0 ),\n\t\t\tvec3( t1.z, 0, t1.w )\n\t\t);\n\t\tvec3 fresnel = ( material.specularColor * t2.x + ( vec3( 1.0 ) - material.specularColor ) * t2.y );\n\t\treflectedLight.directSpecular += lightColor * fresnel * LTC_Evaluate( normal, viewDir, position, mInv, rectCoords );\n\t\treflectedLight.directDiffuse += lightColor * material.diffuseColor * LTC_Evaluate( normal, viewDir, position, mat3( 1.0 ), rectCoords );\n\t}\n#endif\nvoid RE_Direct_Physical( const in IncidentLight directLight, const in GeometricContext geometry, const in PhysicalMaterial material, inout ReflectedLight reflectedLight ) {\n\tfloat dotNL = saturate( dot( geometry.normal, directLight.direction ) );\n\tvec3 irradiance = dotNL * directLight.color;\n\t#ifndef PHYSICALLY_CORRECT_LIGHTS\n\t\tirradiance *= PI;\n\t#endif\n\t#ifdef CLEARCOAT\n\t\tfloat ccDotNL = saturate( dot( geometry.clearcoatNormal, directLight.direction ) );\n\t\tvec3 ccIrradiance = ccDotNL * directLight.color;\n\t\t#ifndef PHYSICALLY_CORRECT_LIGHTS\n\t\t\tccIrradiance *= PI;\n\t\t#endif\n\t\tfloat clearcoatDHR = material.clearcoat * clearcoatDHRApprox( material.clearcoatRoughness, ccDotNL );\n\t\treflectedLight.directSpecular += ccIrradiance * material.clearcoat * BRDF_Specular_GGX( directLight, geometry.viewDir, geometry.clearcoatNormal, vec3( DEFAULT_SPECULAR_COEFFICIENT ), material.clearcoatRoughness );\n\t#else\n\t\tfloat clearcoatDHR = 0.0;\n\t#endif\n\t#ifdef USE_SHEEN\n\t\treflectedLight.directSpecular += ( 1.0 - clearcoatDHR ) * irradiance * BRDF_Specular_Sheen(\n\t\t\tmaterial.specularRoughness,\n\t\t\tdirectLight.direction,\n\t\t\tgeometry,\n\t\t\tmaterial.sheenColor\n\t\t);\n\t#else\n\t\treflectedLight.directSpecular += ( 1.0 - clearcoatDHR ) * irradiance * BRDF_Specular_GGX( directLight, geometry.viewDir, geometry.normal, material.specularColor, material.specularRoughness);\n\t#endif\n\treflectedLight.directDiffuse += ( 1.0 - clearcoatDHR ) * irradiance * BRDF_Diffuse_Lambert( material.diffuseColor );\n}\nvoid RE_IndirectDiffuse_Physical( const in vec3 irradiance, const in GeometricContext geometry, const in PhysicalMaterial material, inout ReflectedLight reflectedLight ) {\n\treflectedLight.indirectDiffuse += irradiance * BRDF_Diffuse_Lambert( material.diffuseColor );\n}\nvoid RE_IndirectSpecular_Physical( const in vec3 radiance, const in vec3 irradiance, const in vec3 clearcoatRadiance, const in GeometricContext geometry, const in PhysicalMaterial material, inout ReflectedLight reflectedLight) {\n\t#ifdef CLEARCOAT\n\t\tfloat ccDotNV = saturate( dot( geometry.clearcoatNormal, geometry.viewDir ) );\n\t\treflectedLight.indirectSpecular += clearcoatRadiance * material.clearcoat * BRDF_Specular_GGX_Environment( geometry.viewDir, geometry.clearcoatNormal, vec3( DEFAULT_SPECULAR_COEFFICIENT ), material.clearcoatRoughness );\n\t\tfloat ccDotNL = ccDotNV;\n\t\tfloat clearcoatDHR = material.clearcoat * clearcoatDHRApprox( material.clearcoatRoughness, ccDotNL );\n\t#else\n\t\tfloat clearcoatDHR = 0.0;\n\t#endif\n\tfloat clearcoatInv = 1.0 - clearcoatDHR;\n\tvec3 singleScattering = vec3( 0.0 );\n\tvec3 multiScattering = vec3( 0.0 );\n\tvec3 cosineWeightedIrradiance = irradiance * RECIPROCAL_PI;\n\tBRDF_Specular_Multiscattering_Environment( geometry, material.specularColor, material.specularRoughness, singleScattering, multiScattering );\n\tvec3 diffuse = material.diffuseColor * ( 1.0 - ( singleScattering + multiScattering ) );\n\treflectedLight.indirectSpecular += clearcoatInv * radiance * singleScattering;\n\treflectedLight.indirectSpecular += multiScattering * cosineWeightedIrradiance;\n\treflectedLight.indirectDiffuse += diffuse * cosineWeightedIrradiance;\n}\n#define RE_Direct\t\t\t\tRE_Direct_Physical\n#define RE_Direct_RectArea\t\tRE_Direct_RectArea_Physical\n#define RE_IndirectDiffuse\t\tRE_IndirectDiffuse_Physical\n#define RE_IndirectSpecular\t\tRE_IndirectSpecular_Physical\nfloat computeSpecularOcclusion( const in float dotNV, const in float ambientOcclusion, const in float roughness ) {\n\treturn saturate( pow( dotNV + ambientOcclusion, exp2( - 16.0 * roughness - 1.0 ) ) - 1.0 + ambientOcclusion );\n}",
								lights_fragment_begin:
									"\nGeometricContext geometry;\ngeometry.position = - vViewPosition;\ngeometry.normal = normal;\ngeometry.viewDir = ( isOrthographic ) ? vec3( 0, 0, 1 ) : normalize( vViewPosition );\n#ifdef CLEARCOAT\n\tgeometry.clearcoatNormal = clearcoatNormal;\n#endif\nIncidentLight directLight;\n#if ( NUM_POINT_LIGHTS > 0 ) && defined( RE_Direct )\n\tPointLight pointLight;\n\t#if defined( USE_SHADOWMAP ) && NUM_POINT_LIGHT_SHADOWS > 0\n\tPointLightShadow pointLightShadow;\n\t#endif\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_POINT_LIGHTS; i ++ ) {\n\t\tpointLight = pointLights[ i ];\n\t\tgetPointDirectLightIrradiance( pointLight, geometry, directLight );\n\t\t#if defined( USE_SHADOWMAP ) && ( UNROLLED_LOOP_INDEX < NUM_POINT_LIGHT_SHADOWS )\n\t\tpointLightShadow = pointLightShadows[ i ];\n\t\tdirectLight.color *= all( bvec2( directLight.visible, receiveShadow ) ) ? getPointShadow( pointShadowMap[ i ], pointLightShadow.shadowMapSize, pointLightShadow.shadowBias, pointLightShadow.shadowRadius, vPointShadowCoord[ i ], pointLightShadow.shadowCameraNear, pointLightShadow.shadowCameraFar ) : 1.0;\n\t\t#endif\n\t\tRE_Direct( directLight, geometry, material, reflectedLight );\n\t}\n\t#pragma unroll_loop_end\n#endif\n#if ( NUM_SPOT_LIGHTS > 0 ) && defined( RE_Direct )\n\tSpotLight spotLight;\n\t#if defined( USE_SHADOWMAP ) && NUM_SPOT_LIGHT_SHADOWS > 0\n\tSpotLightShadow spotLightShadow;\n\t#endif\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_SPOT_LIGHTS; i ++ ) {\n\t\tspotLight = spotLights[ i ];\n\t\tgetSpotDirectLightIrradiance( spotLight, geometry, directLight );\n\t\t#if defined( USE_SHADOWMAP ) && ( UNROLLED_LOOP_INDEX < NUM_SPOT_LIGHT_SHADOWS )\n\t\tspotLightShadow = spotLightShadows[ i ];\n\t\tdirectLight.color *= all( bvec2( directLight.visible, receiveShadow ) ) ? getShadow( spotShadowMap[ i ], spotLightShadow.shadowMapSize, spotLightShadow.shadowBias, spotLightShadow.shadowRadius, vSpotShadowCoord[ i ] ) : 1.0;\n\t\t#endif\n\t\tRE_Direct( directLight, geometry, material, reflectedLight );\n\t}\n\t#pragma unroll_loop_end\n#endif\n#if ( NUM_DIR_LIGHTS > 0 ) && defined( RE_Direct )\n\tDirectionalLight directionalLight;\n\t#if defined( USE_SHADOWMAP ) && NUM_DIR_LIGHT_SHADOWS > 0\n\tDirectionalLightShadow directionalLightShadow;\n\t#endif\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_DIR_LIGHTS; i ++ ) {\n\t\tdirectionalLight = directionalLights[ i ];\n\t\tgetDirectionalDirectLightIrradiance( directionalLight, geometry, directLight );\n\t\t#if defined( USE_SHADOWMAP ) && ( UNROLLED_LOOP_INDEX < NUM_DIR_LIGHT_SHADOWS )\n\t\tdirectionalLightShadow = directionalLightShadows[ i ];\n\t\tdirectLight.color *= all( bvec2( directLight.visible, receiveShadow ) ) ? getShadow( directionalShadowMap[ i ], directionalLightShadow.shadowMapSize, directionalLightShadow.shadowBias, directionalLightShadow.shadowRadius, vDirectionalShadowCoord[ i ] ) : 1.0;\n\t\t#endif\n\t\tRE_Direct( directLight, geometry, material, reflectedLight );\n\t}\n\t#pragma unroll_loop_end\n#endif\n#if ( NUM_RECT_AREA_LIGHTS > 0 ) && defined( RE_Direct_RectArea )\n\tRectAreaLight rectAreaLight;\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_RECT_AREA_LIGHTS; i ++ ) {\n\t\trectAreaLight = rectAreaLights[ i ];\n\t\tRE_Direct_RectArea( rectAreaLight, geometry, material, reflectedLight );\n\t}\n\t#pragma unroll_loop_end\n#endif\n#if defined( RE_IndirectDiffuse )\n\tvec3 iblIrradiance = vec3( 0.0 );\n\tvec3 irradiance = getAmbientLightIrradiance( ambientLightColor );\n\tirradiance += getLightProbeIrradiance( lightProbe, geometry );\n\t#if ( NUM_HEMI_LIGHTS > 0 )\n\t\t#pragma unroll_loop_start\n\t\tfor ( int i = 0; i < NUM_HEMI_LIGHTS; i ++ ) {\n\t\t\tirradiance += getHemisphereLightIrradiance( hemisphereLights[ i ], geometry );\n\t\t}\n\t\t#pragma unroll_loop_end\n\t#endif\n#endif\n#if defined( RE_IndirectSpecular )\n\tvec3 radiance = vec3( 0.0 );\n\tvec3 clearcoatRadiance = vec3( 0.0 );\n#endif",
								lights_fragment_maps:
									"#if defined( RE_IndirectDiffuse )\n\t#ifdef USE_LIGHTMAP\n\t\tvec4 lightMapTexel= texture2D( lightMap, vUv2 );\n\t\tvec3 lightMapIrradiance = lightMapTexelToLinear( lightMapTexel ).rgb * lightMapIntensity;\n\t\t#ifndef PHYSICALLY_CORRECT_LIGHTS\n\t\t\tlightMapIrradiance *= PI;\n\t\t#endif\n\t\tirradiance += lightMapIrradiance;\n\t#endif\n\t#if defined( USE_ENVMAP ) && defined( STANDARD ) && defined( ENVMAP_TYPE_CUBE_UV )\n\t\tiblIrradiance += getLightProbeIndirectIrradiance( geometry, maxMipLevel );\n\t#endif\n#endif\n#if defined( USE_ENVMAP ) && defined( RE_IndirectSpecular )\n\tradiance += getLightProbeIndirectRadiance( geometry.viewDir, geometry.normal, material.specularRoughness, maxMipLevel );\n\t#ifdef CLEARCOAT\n\t\tclearcoatRadiance += getLightProbeIndirectRadiance( geometry.viewDir, geometry.clearcoatNormal, material.clearcoatRoughness, maxMipLevel );\n\t#endif\n#endif",
								lights_fragment_end:
									"#if defined( RE_IndirectDiffuse )\n\tRE_IndirectDiffuse( irradiance, geometry, material, reflectedLight );\n#endif\n#if defined( RE_IndirectSpecular )\n\tRE_IndirectSpecular( radiance, iblIrradiance, clearcoatRadiance, geometry, material, reflectedLight );\n#endif",
								logdepthbuf_fragment:
									"#if defined( USE_LOGDEPTHBUF ) && defined( USE_LOGDEPTHBUF_EXT )\n\tgl_FragDepthEXT = vIsPerspective == 0.0 ? gl_FragCoord.z : log2( vFragDepth ) * logDepthBufFC * 0.5;\n#endif",
								logdepthbuf_pars_fragment:
									"#if defined( USE_LOGDEPTHBUF ) && defined( USE_LOGDEPTHBUF_EXT )\n\tuniform float logDepthBufFC;\n\tvarying float vFragDepth;\n\tvarying float vIsPerspective;\n#endif",
								logdepthbuf_pars_vertex:
									"#ifdef USE_LOGDEPTHBUF\n\t#ifdef USE_LOGDEPTHBUF_EXT\n\t\tvarying float vFragDepth;\n\t\tvarying float vIsPerspective;\n\t#else\n\t\tuniform float logDepthBufFC;\n\t#endif\n#endif",
								logdepthbuf_vertex:
									"#ifdef USE_LOGDEPTHBUF\n\t#ifdef USE_LOGDEPTHBUF_EXT\n\t\tvFragDepth = 1.0 + gl_Position.w;\n\t\tvIsPerspective = float( isPerspectiveMatrix( projectionMatrix ) );\n\t#else\n\t\tif ( isPerspectiveMatrix( projectionMatrix ) ) {\n\t\t\tgl_Position.z = log2( max( EPSILON, gl_Position.w + 1.0 ) ) * logDepthBufFC - 1.0;\n\t\t\tgl_Position.z *= gl_Position.w;\n\t\t}\n\t#endif\n#endif",
								map_fragment:
									"#ifdef USE_MAP\n\tvec4 texelColor = texture2D( map, vUv );\n\ttexelColor = mapTexelToLinear( texelColor );\n\tdiffuseColor *= texelColor;\n#endif",
								map_pars_fragment:
									"#ifdef USE_MAP\n\tuniform sampler2D map;\n#endif",
								map_particle_fragment:
									"#if defined( USE_MAP ) || defined( USE_ALPHAMAP )\n\tvec2 uv = ( uvTransform * vec3( gl_PointCoord.x, 1.0 - gl_PointCoord.y, 1 ) ).xy;\n#endif\n#ifdef USE_MAP\n\tvec4 mapTexel = texture2D( map, uv );\n\tdiffuseColor *= mapTexelToLinear( mapTexel );\n#endif\n#ifdef USE_ALPHAMAP\n\tdiffuseColor.a *= texture2D( alphaMap, uv ).g;\n#endif",
								map_particle_pars_fragment:
									"#if defined( USE_MAP ) || defined( USE_ALPHAMAP )\n\tuniform mat3 uvTransform;\n#endif\n#ifdef USE_MAP\n\tuniform sampler2D map;\n#endif\n#ifdef USE_ALPHAMAP\n\tuniform sampler2D alphaMap;\n#endif",
								metalnessmap_fragment:
									"float metalnessFactor = metalness;\n#ifdef USE_METALNESSMAP\n\tvec4 texelMetalness = texture2D( metalnessMap, vUv );\n\tmetalnessFactor *= texelMetalness.b;\n#endif",
								metalnessmap_pars_fragment:
									"#ifdef USE_METALNESSMAP\n\tuniform sampler2D metalnessMap;\n#endif",
								morphnormal_vertex:
									"#ifdef USE_MORPHNORMALS\n\tobjectNormal *= morphTargetBaseInfluence;\n\tobjectNormal += morphNormal0 * morphTargetInfluences[ 0 ];\n\tobjectNormal += morphNormal1 * morphTargetInfluences[ 1 ];\n\tobjectNormal += morphNormal2 * morphTargetInfluences[ 2 ];\n\tobjectNormal += morphNormal3 * morphTargetInfluences[ 3 ];\n#endif",
								morphtarget_pars_vertex:
									"#ifdef USE_MORPHTARGETS\n\tuniform float morphTargetBaseInfluence;\n\t#ifndef USE_MORPHNORMALS\n\t\tuniform float morphTargetInfluences[ 8 ];\n\t#else\n\t\tuniform float morphTargetInfluences[ 4 ];\n\t#endif\n#endif",
								morphtarget_vertex:
									"#ifdef USE_MORPHTARGETS\n\ttransformed *= morphTargetBaseInfluence;\n\ttransformed += morphTarget0 * morphTargetInfluences[ 0 ];\n\ttransformed += morphTarget1 * morphTargetInfluences[ 1 ];\n\ttransformed += morphTarget2 * morphTargetInfluences[ 2 ];\n\ttransformed += morphTarget3 * morphTargetInfluences[ 3 ];\n\t#ifndef USE_MORPHNORMALS\n\t\ttransformed += morphTarget4 * morphTargetInfluences[ 4 ];\n\t\ttransformed += morphTarget5 * morphTargetInfluences[ 5 ];\n\t\ttransformed += morphTarget6 * morphTargetInfluences[ 6 ];\n\t\ttransformed += morphTarget7 * morphTargetInfluences[ 7 ];\n\t#endif\n#endif",
								normal_fragment_begin:
									"#ifdef FLAT_SHADED\n\tvec3 fdx = vec3( dFdx( vViewPosition.x ), dFdx( vViewPosition.y ), dFdx( vViewPosition.z ) );\n\tvec3 fdy = vec3( dFdy( vViewPosition.x ), dFdy( vViewPosition.y ), dFdy( vViewPosition.z ) );\n\tvec3 normal = normalize( cross( fdx, fdy ) );\n#else\n\tvec3 normal = normalize( vNormal );\n\t#ifdef DOUBLE_SIDED\n\t\tnormal = normal * ( float( gl_FrontFacing ) * 2.0 - 1.0 );\n\t#endif\n\t#ifdef USE_TANGENT\n\t\tvec3 tangent = normalize( vTangent );\n\t\tvec3 bitangent = normalize( vBitangent );\n\t\t#ifdef DOUBLE_SIDED\n\t\t\ttangent = tangent * ( float( gl_FrontFacing ) * 2.0 - 1.0 );\n\t\t\tbitangent = bitangent * ( float( gl_FrontFacing ) * 2.0 - 1.0 );\n\t\t#endif\n\t\t#if defined( TANGENTSPACE_NORMALMAP ) || defined( USE_CLEARCOAT_NORMALMAP )\n\t\t\tmat3 vTBN = mat3( tangent, bitangent, normal );\n\t\t#endif\n\t#endif\n#endif\nvec3 geometryNormal = normal;",
								normal_fragment_maps:
									"#ifdef OBJECTSPACE_NORMALMAP\n\tnormal = texture2D( normalMap, vUv ).xyz * 2.0 - 1.0;\n\t#ifdef FLIP_SIDED\n\t\tnormal = - normal;\n\t#endif\n\t#ifdef DOUBLE_SIDED\n\t\tnormal = normal * ( float( gl_FrontFacing ) * 2.0 - 1.0 );\n\t#endif\n\tnormal = normalize( normalMatrix * normal );\n#elif defined( TANGENTSPACE_NORMALMAP )\n\tvec3 mapN = texture2D( normalMap, vUv ).xyz * 2.0 - 1.0;\n\tmapN.xy *= normalScale;\n\t#ifdef USE_TANGENT\n\t\tnormal = normalize( vTBN * mapN );\n\t#else\n\t\tnormal = perturbNormal2Arb( -vViewPosition, normal, mapN );\n\t#endif\n#elif defined( USE_BUMPMAP )\n\tnormal = perturbNormalArb( -vViewPosition, normal, dHdxy_fwd() );\n#endif",
								normalmap_pars_fragment:
									"#ifdef USE_NORMALMAP\n\tuniform sampler2D normalMap;\n\tuniform vec2 normalScale;\n#endif\n#ifdef OBJECTSPACE_NORMALMAP\n\tuniform mat3 normalMatrix;\n#endif\n#if ! defined ( USE_TANGENT ) && ( defined ( TANGENTSPACE_NORMALMAP ) || defined ( USE_CLEARCOAT_NORMALMAP ) )\n\tvec3 perturbNormal2Arb( vec3 eye_pos, vec3 surf_norm, vec3 mapN ) {\n\t\tvec3 q0 = vec3( dFdx( eye_pos.x ), dFdx( eye_pos.y ), dFdx( eye_pos.z ) );\n\t\tvec3 q1 = vec3( dFdy( eye_pos.x ), dFdy( eye_pos.y ), dFdy( eye_pos.z ) );\n\t\tvec2 st0 = dFdx( vUv.st );\n\t\tvec2 st1 = dFdy( vUv.st );\n\t\tfloat scale = sign( st1.t * st0.s - st0.t * st1.s );\n\t\tvec3 S = normalize( ( q0 * st1.t - q1 * st0.t ) * scale );\n\t\tvec3 T = normalize( ( - q0 * st1.s + q1 * st0.s ) * scale );\n\t\tvec3 N = normalize( surf_norm );\n\t\tmat3 tsn = mat3( S, T, N );\n\t\tmapN.xy *= ( float( gl_FrontFacing ) * 2.0 - 1.0 );\n\t\treturn normalize( tsn * mapN );\n\t}\n#endif",
								clearcoat_normal_fragment_begin:
									"#ifdef CLEARCOAT\n\tvec3 clearcoatNormal = geometryNormal;\n#endif",
								clearcoat_normal_fragment_maps:
									"#ifdef USE_CLEARCOAT_NORMALMAP\n\tvec3 clearcoatMapN = texture2D( clearcoatNormalMap, vUv ).xyz * 2.0 - 1.0;\n\tclearcoatMapN.xy *= clearcoatNormalScale;\n\t#ifdef USE_TANGENT\n\t\tclearcoatNormal = normalize( vTBN * clearcoatMapN );\n\t#else\n\t\tclearcoatNormal = perturbNormal2Arb( - vViewPosition, clearcoatNormal, clearcoatMapN );\n\t#endif\n#endif",
								clearcoat_pars_fragment:
									"#ifdef USE_CLEARCOATMAP\n\tuniform sampler2D clearcoatMap;\n#endif\n#ifdef USE_CLEARCOAT_ROUGHNESSMAP\n\tuniform sampler2D clearcoatRoughnessMap;\n#endif\n#ifdef USE_CLEARCOAT_NORMALMAP\n\tuniform sampler2D clearcoatNormalMap;\n\tuniform vec2 clearcoatNormalScale;\n#endif",
								packing:
									"vec3 packNormalToRGB( const in vec3 normal ) {\n\treturn normalize( normal ) * 0.5 + 0.5;\n}\nvec3 unpackRGBToNormal( const in vec3 rgb ) {\n\treturn 2.0 * rgb.xyz - 1.0;\n}\nconst float PackUpscale = 256. / 255.;const float UnpackDownscale = 255. / 256.;\nconst vec3 PackFactors = vec3( 256. * 256. * 256., 256. * 256.,  256. );\nconst vec4 UnpackFactors = UnpackDownscale / vec4( PackFactors, 1. );\nconst float ShiftRight8 = 1. / 256.;\nvec4 packDepthToRGBA( const in float v ) {\n\tvec4 r = vec4( fract( v * PackFactors ), v );\n\tr.yzw -= r.xyz * ShiftRight8;\treturn r * PackUpscale;\n}\nfloat unpackRGBAToDepth( const in vec4 v ) {\n\treturn dot( v, UnpackFactors );\n}\nvec4 pack2HalfToRGBA( vec2 v ) {\n\tvec4 r = vec4( v.x, fract( v.x * 255.0 ), v.y, fract( v.y * 255.0 ));\n\treturn vec4( r.x - r.y / 255.0, r.y, r.z - r.w / 255.0, r.w);\n}\nvec2 unpackRGBATo2Half( vec4 v ) {\n\treturn vec2( v.x + ( v.y / 255.0 ), v.z + ( v.w / 255.0 ) );\n}\nfloat viewZToOrthographicDepth( const in float viewZ, const in float near, const in float far ) {\n\treturn ( viewZ + near ) / ( near - far );\n}\nfloat orthographicDepthToViewZ( const in float linearClipZ, const in float near, const in float far ) {\n\treturn linearClipZ * ( near - far ) - near;\n}\nfloat viewZToPerspectiveDepth( const in float viewZ, const in float near, const in float far ) {\n\treturn (( near + viewZ ) * far ) / (( far - near ) * viewZ );\n}\nfloat perspectiveDepthToViewZ( const in float invClipZ, const in float near, const in float far ) {\n\treturn ( near * far ) / ( ( far - near ) * invClipZ - far );\n}",
								premultiplied_alpha_fragment:
									"#ifdef PREMULTIPLIED_ALPHA\n\tgl_FragColor.rgb *= gl_FragColor.a;\n#endif",
								project_vertex:
									"vec4 mvPosition = vec4( transformed, 1.0 );\n#ifdef USE_INSTANCING\n\tmvPosition = instanceMatrix * mvPosition;\n#endif\nmvPosition = modelViewMatrix * mvPosition;\ngl_Position = projectionMatrix * mvPosition;",
								dithering_fragment:
									"#ifdef DITHERING\n\tgl_FragColor.rgb = dithering( gl_FragColor.rgb );\n#endif",
								dithering_pars_fragment:
									"#ifdef DITHERING\n\tvec3 dithering( vec3 color ) {\n\t\tfloat grid_position = rand( gl_FragCoord.xy );\n\t\tvec3 dither_shift_RGB = vec3( 0.25 / 255.0, -0.25 / 255.0, 0.25 / 255.0 );\n\t\tdither_shift_RGB = mix( 2.0 * dither_shift_RGB, -2.0 * dither_shift_RGB, grid_position );\n\t\treturn color + dither_shift_RGB;\n\t}\n#endif",
								roughnessmap_fragment:
									"float roughnessFactor = roughness;\n#ifdef USE_ROUGHNESSMAP\n\tvec4 texelRoughness = texture2D( roughnessMap, vUv );\n\troughnessFactor *= texelRoughness.g;\n#endif",
								roughnessmap_pars_fragment:
									"#ifdef USE_ROUGHNESSMAP\n\tuniform sampler2D roughnessMap;\n#endif",
								shadowmap_pars_fragment:
									"#ifdef USE_SHADOWMAP\n\t#if NUM_DIR_LIGHT_SHADOWS > 0\n\t\tuniform sampler2D directionalShadowMap[ NUM_DIR_LIGHT_SHADOWS ];\n\t\tvarying vec4 vDirectionalShadowCoord[ NUM_DIR_LIGHT_SHADOWS ];\n\t\tstruct DirectionalLightShadow {\n\t\t\tfloat shadowBias;\n\t\t\tfloat shadowNormalBias;\n\t\t\tfloat shadowRadius;\n\t\t\tvec2 shadowMapSize;\n\t\t};\n\t\tuniform DirectionalLightShadow directionalLightShadows[ NUM_DIR_LIGHT_SHADOWS ];\n\t#endif\n\t#if NUM_SPOT_LIGHT_SHADOWS > 0\n\t\tuniform sampler2D spotShadowMap[ NUM_SPOT_LIGHT_SHADOWS ];\n\t\tvarying vec4 vSpotShadowCoord[ NUM_SPOT_LIGHT_SHADOWS ];\n\t\tstruct SpotLightShadow {\n\t\t\tfloat shadowBias;\n\t\t\tfloat shadowNormalBias;\n\t\t\tfloat shadowRadius;\n\t\t\tvec2 shadowMapSize;\n\t\t};\n\t\tuniform SpotLightShadow spotLightShadows[ NUM_SPOT_LIGHT_SHADOWS ];\n\t#endif\n\t#if NUM_POINT_LIGHT_SHADOWS > 0\n\t\tuniform sampler2D pointShadowMap[ NUM_POINT_LIGHT_SHADOWS ];\n\t\tvarying vec4 vPointShadowCoord[ NUM_POINT_LIGHT_SHADOWS ];\n\t\tstruct PointLightShadow {\n\t\t\tfloat shadowBias;\n\t\t\tfloat shadowNormalBias;\n\t\t\tfloat shadowRadius;\n\t\t\tvec2 shadowMapSize;\n\t\t\tfloat shadowCameraNear;\n\t\t\tfloat shadowCameraFar;\n\t\t};\n\t\tuniform PointLightShadow pointLightShadows[ NUM_POINT_LIGHT_SHADOWS ];\n\t#endif\n\tfloat texture2DCompare( sampler2D depths, vec2 uv, float compare ) {\n\t\treturn step( compare, unpackRGBAToDepth( texture2D( depths, uv ) ) );\n\t}\n\tvec2 texture2DDistribution( sampler2D shadow, vec2 uv ) {\n\t\treturn unpackRGBATo2Half( texture2D( shadow, uv ) );\n\t}\n\tfloat VSMShadow (sampler2D shadow, vec2 uv, float compare ){\n\t\tfloat occlusion = 1.0;\n\t\tvec2 distribution = texture2DDistribution( shadow, uv );\n\t\tfloat hard_shadow = step( compare , distribution.x );\n\t\tif (hard_shadow != 1.0 ) {\n\t\t\tfloat distance = compare - distribution.x ;\n\t\t\tfloat variance = max( 0.00000, distribution.y * distribution.y );\n\t\t\tfloat softness_probability = variance / (variance + distance * distance );\t\t\tsoftness_probability = clamp( ( softness_probability - 0.3 ) / ( 0.95 - 0.3 ), 0.0, 1.0 );\t\t\tocclusion = clamp( max( hard_shadow, softness_probability ), 0.0, 1.0 );\n\t\t}\n\t\treturn occlusion;\n\t}\n\tfloat getShadow( sampler2D shadowMap, vec2 shadowMapSize, float shadowBias, float shadowRadius, vec4 shadowCoord ) {\n\t\tfloat shadow = 1.0;\n\t\tshadowCoord.xyz /= shadowCoord.w;\n\t\tshadowCoord.z += shadowBias;\n\t\tbvec4 inFrustumVec = bvec4 ( shadowCoord.x >= 0.0, shadowCoord.x <= 1.0, shadowCoord.y >= 0.0, shadowCoord.y <= 1.0 );\n\t\tbool inFrustum = all( inFrustumVec );\n\t\tbvec2 frustumTestVec = bvec2( inFrustum, shadowCoord.z <= 1.0 );\n\t\tbool frustumTest = all( frustumTestVec );\n\t\tif ( frustumTest ) {\n\t\t#if defined( SHADOWMAP_TYPE_PCF )\n\t\t\tvec2 texelSize = vec2( 1.0 ) / shadowMapSize;\n\t\t\tfloat dx0 = - texelSize.x * shadowRadius;\n\t\t\tfloat dy0 = - texelSize.y * shadowRadius;\n\t\t\tfloat dx1 = + texelSize.x * shadowRadius;\n\t\t\tfloat dy1 = + texelSize.y * shadowRadius;\n\t\t\tfloat dx2 = dx0 / 2.0;\n\t\t\tfloat dy2 = dy0 / 2.0;\n\t\t\tfloat dx3 = dx1 / 2.0;\n\t\t\tfloat dy3 = dy1 / 2.0;\n\t\t\tshadow = (\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, dy0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, dy0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx2, dy2 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy2 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx3, dy2 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, 0.0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx2, 0.0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy, shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx3, 0.0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, 0.0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx2, dy3 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy3 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx3, dy3 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, dy1 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy1 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, dy1 ), shadowCoord.z )\n\t\t\t) * ( 1.0 / 17.0 );\n\t\t#elif defined( SHADOWMAP_TYPE_PCF_SOFT )\n\t\t\tvec2 texelSize = vec2( 1.0 ) / shadowMapSize;\n\t\t\tfloat dx = texelSize.x;\n\t\t\tfloat dy = texelSize.y;\n\t\t\tvec2 uv = shadowCoord.xy;\n\t\t\tvec2 f = fract( uv * shadowMapSize + 0.5 );\n\t\t\tuv -= f * texelSize;\n\t\t\tshadow = (\n\t\t\t\ttexture2DCompare( shadowMap, uv, shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, uv + vec2( dx, 0.0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, uv + vec2( 0.0, dy ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, uv + texelSize, shadowCoord.z ) +\n\t\t\t\tmix( texture2DCompare( shadowMap, uv + vec2( -dx, 0.0 ), shadowCoord.z ), \n\t\t\t\t\t texture2DCompare( shadowMap, uv + vec2( 2.0 * dx, 0.0 ), shadowCoord.z ),\n\t\t\t\t\t f.x ) +\n\t\t\t\tmix( texture2DCompare( shadowMap, uv + vec2( -dx, dy ), shadowCoord.z ), \n\t\t\t\t\t texture2DCompare( shadowMap, uv + vec2( 2.0 * dx, dy ), shadowCoord.z ),\n\t\t\t\t\t f.x ) +\n\t\t\t\tmix( texture2DCompare( shadowMap, uv + vec2( 0.0, -dy ), shadowCoord.z ), \n\t\t\t\t\t texture2DCompare( shadowMap, uv + vec2( 0.0, 2.0 * dy ), shadowCoord.z ),\n\t\t\t\t\t f.y ) +\n\t\t\t\tmix( texture2DCompare( shadowMap, uv + vec2( dx, -dy ), shadowCoord.z ), \n\t\t\t\t\t texture2DCompare( shadowMap, uv + vec2( dx, 2.0 * dy ), shadowCoord.z ),\n\t\t\t\t\t f.y ) +\n\t\t\t\tmix( mix( texture2DCompare( shadowMap, uv + vec2( -dx, -dy ), shadowCoord.z ), \n\t\t\t\t\t\t  texture2DCompare( shadowMap, uv + vec2( 2.0 * dx, -dy ), shadowCoord.z ),\n\t\t\t\t\t\t  f.x ),\n\t\t\t\t\t mix( texture2DCompare( shadowMap, uv + vec2( -dx, 2.0 * dy ), shadowCoord.z ), \n\t\t\t\t\t\t  texture2DCompare( shadowMap, uv + vec2( 2.0 * dx, 2.0 * dy ), shadowCoord.z ),\n\t\t\t\t\t\t  f.x ),\n\t\t\t\t\t f.y )\n\t\t\t) * ( 1.0 / 9.0 );\n\t\t#elif defined( SHADOWMAP_TYPE_VSM )\n\t\t\tshadow = VSMShadow( shadowMap, shadowCoord.xy, shadowCoord.z );\n\t\t#else\n\t\t\tshadow = texture2DCompare( shadowMap, shadowCoord.xy, shadowCoord.z );\n\t\t#endif\n\t\t}\n\t\treturn shadow;\n\t}\n\tvec2 cubeToUV( vec3 v, float texelSizeY ) {\n\t\tvec3 absV = abs( v );\n\t\tfloat scaleToCube = 1.0 / max( absV.x, max( absV.y, absV.z ) );\n\t\tabsV *= scaleToCube;\n\t\tv *= scaleToCube * ( 1.0 - 2.0 * texelSizeY );\n\t\tvec2 planar = v.xy;\n\t\tfloat almostATexel = 1.5 * texelSizeY;\n\t\tfloat almostOne = 1.0 - almostATexel;\n\t\tif ( absV.z >= almostOne ) {\n\t\t\tif ( v.z > 0.0 )\n\t\t\t\tplanar.x = 4.0 - v.x;\n\t\t} else if ( absV.x >= almostOne ) {\n\t\t\tfloat signX = sign( v.x );\n\t\t\tplanar.x = v.z * signX + 2.0 * signX;\n\t\t} else if ( absV.y >= almostOne ) {\n\t\t\tfloat signY = sign( v.y );\n\t\t\tplanar.x = v.x + 2.0 * signY + 2.0;\n\t\t\tplanar.y = v.z * signY - 2.0;\n\t\t}\n\t\treturn vec2( 0.125, 0.25 ) * planar + vec2( 0.375, 0.75 );\n\t}\n\tfloat getPointShadow( sampler2D shadowMap, vec2 shadowMapSize, float shadowBias, float shadowRadius, vec4 shadowCoord, float shadowCameraNear, float shadowCameraFar ) {\n\t\tvec2 texelSize = vec2( 1.0 ) / ( shadowMapSize * vec2( 4.0, 2.0 ) );\n\t\tvec3 lightToPosition = shadowCoord.xyz;\n\t\tfloat dp = ( length( lightToPosition ) - shadowCameraNear ) / ( shadowCameraFar - shadowCameraNear );\t\tdp += shadowBias;\n\t\tvec3 bd3D = normalize( lightToPosition );\n\t\t#if defined( SHADOWMAP_TYPE_PCF ) || defined( SHADOWMAP_TYPE_PCF_SOFT ) || defined( SHADOWMAP_TYPE_VSM )\n\t\t\tvec2 offset = vec2( - 1, 1 ) * shadowRadius * texelSize.y;\n\t\t\treturn (\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.xyy, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.yyy, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.xyx, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.yyx, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.xxy, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.yxy, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.xxx, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.yxx, texelSize.y ), dp )\n\t\t\t) * ( 1.0 / 9.0 );\n\t\t#else\n\t\t\treturn texture2DCompare( shadowMap, cubeToUV( bd3D, texelSize.y ), dp );\n\t\t#endif\n\t}\n#endif",
								shadowmap_pars_vertex:
									"#ifdef USE_SHADOWMAP\n\t#if NUM_DIR_LIGHT_SHADOWS > 0\n\t\tuniform mat4 directionalShadowMatrix[ NUM_DIR_LIGHT_SHADOWS ];\n\t\tvarying vec4 vDirectionalShadowCoord[ NUM_DIR_LIGHT_SHADOWS ];\n\t\tstruct DirectionalLightShadow {\n\t\t\tfloat shadowBias;\n\t\t\tfloat shadowNormalBias;\n\t\t\tfloat shadowRadius;\n\t\t\tvec2 shadowMapSize;\n\t\t};\n\t\tuniform DirectionalLightShadow directionalLightShadows[ NUM_DIR_LIGHT_SHADOWS ];\n\t#endif\n\t#if NUM_SPOT_LIGHT_SHADOWS > 0\n\t\tuniform mat4 spotShadowMatrix[ NUM_SPOT_LIGHT_SHADOWS ];\n\t\tvarying vec4 vSpotShadowCoord[ NUM_SPOT_LIGHT_SHADOWS ];\n\t\tstruct SpotLightShadow {\n\t\t\tfloat shadowBias;\n\t\t\tfloat shadowNormalBias;\n\t\t\tfloat shadowRadius;\n\t\t\tvec2 shadowMapSize;\n\t\t};\n\t\tuniform SpotLightShadow spotLightShadows[ NUM_SPOT_LIGHT_SHADOWS ];\n\t#endif\n\t#if NUM_POINT_LIGHT_SHADOWS > 0\n\t\tuniform mat4 pointShadowMatrix[ NUM_POINT_LIGHT_SHADOWS ];\n\t\tvarying vec4 vPointShadowCoord[ NUM_POINT_LIGHT_SHADOWS ];\n\t\tstruct PointLightShadow {\n\t\t\tfloat shadowBias;\n\t\t\tfloat shadowNormalBias;\n\t\t\tfloat shadowRadius;\n\t\t\tvec2 shadowMapSize;\n\t\t\tfloat shadowCameraNear;\n\t\t\tfloat shadowCameraFar;\n\t\t};\n\t\tuniform PointLightShadow pointLightShadows[ NUM_POINT_LIGHT_SHADOWS ];\n\t#endif\n#endif",
								shadowmap_vertex:
									"#ifdef USE_SHADOWMAP\n\t#if NUM_DIR_LIGHT_SHADOWS > 0 || NUM_SPOT_LIGHT_SHADOWS > 0 || NUM_POINT_LIGHT_SHADOWS > 0\n\t\tvec3 shadowWorldNormal = inverseTransformDirection( transformedNormal, viewMatrix );\n\t\tvec4 shadowWorldPosition;\n\t#endif\n\t#if NUM_DIR_LIGHT_SHADOWS > 0\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_DIR_LIGHT_SHADOWS; i ++ ) {\n\t\tshadowWorldPosition = worldPosition + vec4( shadowWorldNormal * directionalLightShadows[ i ].shadowNormalBias, 0 );\n\t\tvDirectionalShadowCoord[ i ] = directionalShadowMatrix[ i ] * shadowWorldPosition;\n\t}\n\t#pragma unroll_loop_end\n\t#endif\n\t#if NUM_SPOT_LIGHT_SHADOWS > 0\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_SPOT_LIGHT_SHADOWS; i ++ ) {\n\t\tshadowWorldPosition = worldPosition + vec4( shadowWorldNormal * spotLightShadows[ i ].shadowNormalBias, 0 );\n\t\tvSpotShadowCoord[ i ] = spotShadowMatrix[ i ] * shadowWorldPosition;\n\t}\n\t#pragma unroll_loop_end\n\t#endif\n\t#if NUM_POINT_LIGHT_SHADOWS > 0\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_POINT_LIGHT_SHADOWS; i ++ ) {\n\t\tshadowWorldPosition = worldPosition + vec4( shadowWorldNormal * pointLightShadows[ i ].shadowNormalBias, 0 );\n\t\tvPointShadowCoord[ i ] = pointShadowMatrix[ i ] * shadowWorldPosition;\n\t}\n\t#pragma unroll_loop_end\n\t#endif\n#endif",
								shadowmask_pars_fragment:
									"float getShadowMask() {\n\tfloat shadow = 1.0;\n\t#ifdef USE_SHADOWMAP\n\t#if NUM_DIR_LIGHT_SHADOWS > 0\n\tDirectionalLightShadow directionalLight;\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_DIR_LIGHT_SHADOWS; i ++ ) {\n\t\tdirectionalLight = directionalLightShadows[ i ];\n\t\tshadow *= receiveShadow ? getShadow( directionalShadowMap[ i ], directionalLight.shadowMapSize, directionalLight.shadowBias, directionalLight.shadowRadius, vDirectionalShadowCoord[ i ] ) : 1.0;\n\t}\n\t#pragma unroll_loop_end\n\t#endif\n\t#if NUM_SPOT_LIGHT_SHADOWS > 0\n\tSpotLightShadow spotLight;\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_SPOT_LIGHT_SHADOWS; i ++ ) {\n\t\tspotLight = spotLightShadows[ i ];\n\t\tshadow *= receiveShadow ? getShadow( spotShadowMap[ i ], spotLight.shadowMapSize, spotLight.shadowBias, spotLight.shadowRadius, vSpotShadowCoord[ i ] ) : 1.0;\n\t}\n\t#pragma unroll_loop_end\n\t#endif\n\t#if NUM_POINT_LIGHT_SHADOWS > 0\n\tPointLightShadow pointLight;\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_POINT_LIGHT_SHADOWS; i ++ ) {\n\t\tpointLight = pointLightShadows[ i ];\n\t\tshadow *= receiveShadow ? getPointShadow( pointShadowMap[ i ], pointLight.shadowMapSize, pointLight.shadowBias, pointLight.shadowRadius, vPointShadowCoord[ i ], pointLight.shadowCameraNear, pointLight.shadowCameraFar ) : 1.0;\n\t}\n\t#pragma unroll_loop_end\n\t#endif\n\t#endif\n\treturn shadow;\n}",
								skinbase_vertex:
									"#ifdef USE_SKINNING\n\tmat4 boneMatX = getBoneMatrix( skinIndex.x );\n\tmat4 boneMatY = getBoneMatrix( skinIndex.y );\n\tmat4 boneMatZ = getBoneMatrix( skinIndex.z );\n\tmat4 boneMatW = getBoneMatrix( skinIndex.w );\n#endif",
								skinning_pars_vertex:
									"#ifdef USE_SKINNING\n\tuniform mat4 bindMatrix;\n\tuniform mat4 bindMatrixInverse;\n\t#ifdef BONE_TEXTURE\n\t\tuniform highp sampler2D boneTexture;\n\t\tuniform int boneTextureSize;\n\t\tmat4 getBoneMatrix( const in float i ) {\n\t\t\tfloat j = i * 4.0;\n\t\t\tfloat x = mod( j, float( boneTextureSize ) );\n\t\t\tfloat y = floor( j / float( boneTextureSize ) );\n\t\t\tfloat dx = 1.0 / float( boneTextureSize );\n\t\t\tfloat dy = 1.0 / float( boneTextureSize );\n\t\t\ty = dy * ( y + 0.5 );\n\t\t\tvec4 v1 = texture2D( boneTexture, vec2( dx * ( x + 0.5 ), y ) );\n\t\t\tvec4 v2 = texture2D( boneTexture, vec2( dx * ( x + 1.5 ), y ) );\n\t\t\tvec4 v3 = texture2D( boneTexture, vec2( dx * ( x + 2.5 ), y ) );\n\t\t\tvec4 v4 = texture2D( boneTexture, vec2( dx * ( x + 3.5 ), y ) );\n\t\t\tmat4 bone = mat4( v1, v2, v3, v4 );\n\t\t\treturn bone;\n\t\t}\n\t#else\n\t\tuniform mat4 boneMatrices[ MAX_BONES ];\n\t\tmat4 getBoneMatrix( const in float i ) {\n\t\t\tmat4 bone = boneMatrices[ int(i) ];\n\t\t\treturn bone;\n\t\t}\n\t#endif\n#endif",
								skinning_vertex:
									"#ifdef USE_SKINNING\n\tvec4 skinVertex = bindMatrix * vec4( transformed, 1.0 );\n\tvec4 skinned = vec4( 0.0 );\n\tskinned += boneMatX * skinVertex * skinWeight.x;\n\tskinned += boneMatY * skinVertex * skinWeight.y;\n\tskinned += boneMatZ * skinVertex * skinWeight.z;\n\tskinned += boneMatW * skinVertex * skinWeight.w;\n\ttransformed = ( bindMatrixInverse * skinned ).xyz;\n#endif",
								skinnormal_vertex:
									"#ifdef USE_SKINNING\n\tmat4 skinMatrix = mat4( 0.0 );\n\tskinMatrix += skinWeight.x * boneMatX;\n\tskinMatrix += skinWeight.y * boneMatY;\n\tskinMatrix += skinWeight.z * boneMatZ;\n\tskinMatrix += skinWeight.w * boneMatW;\n\tskinMatrix  = bindMatrixInverse * skinMatrix * bindMatrix;\n\tobjectNormal = vec4( skinMatrix * vec4( objectNormal, 0.0 ) ).xyz;\n\t#ifdef USE_TANGENT\n\t\tobjectTangent = vec4( skinMatrix * vec4( objectTangent, 0.0 ) ).xyz;\n\t#endif\n#endif",
								specularmap_fragment:
									"float specularStrength;\n#ifdef USE_SPECULARMAP\n\tvec4 texelSpecular = texture2D( specularMap, vUv );\n\tspecularStrength = texelSpecular.r;\n#else\n\tspecularStrength = 1.0;\n#endif",
								specularmap_pars_fragment:
									"#ifdef USE_SPECULARMAP\n\tuniform sampler2D specularMap;\n#endif",
								tonemapping_fragment:
									"#if defined( TONE_MAPPING )\n\tgl_FragColor.rgb = toneMapping( gl_FragColor.rgb );\n#endif",
								tonemapping_pars_fragment:
									"#ifndef saturate\n#define saturate(a) clamp( a, 0.0, 1.0 )\n#endif\nuniform float toneMappingExposure;\nvec3 LinearToneMapping( vec3 color ) {\n\treturn toneMappingExposure * color;\n}\nvec3 ReinhardToneMapping( vec3 color ) {\n\tcolor *= toneMappingExposure;\n\treturn saturate( color / ( vec3( 1.0 ) + color ) );\n}\nvec3 OptimizedCineonToneMapping( vec3 color ) {\n\tcolor *= toneMappingExposure;\n\tcolor = max( vec3( 0.0 ), color - 0.004 );\n\treturn pow( ( color * ( 6.2 * color + 0.5 ) ) / ( color * ( 6.2 * color + 1.7 ) + 0.06 ), vec3( 2.2 ) );\n}\nvec3 RRTAndODTFit( vec3 v ) {\n\tvec3 a = v * ( v + 0.0245786 ) - 0.000090537;\n\tvec3 b = v * ( 0.983729 * v + 0.4329510 ) + 0.238081;\n\treturn a / b;\n}\nvec3 ACESFilmicToneMapping( vec3 color ) {\n\tconst mat3 ACESInputMat = mat3(\n\t\tvec3( 0.59719, 0.07600, 0.02840 ),\t\tvec3( 0.35458, 0.90834, 0.13383 ),\n\t\tvec3( 0.04823, 0.01566, 0.83777 )\n\t);\n\tconst mat3 ACESOutputMat = mat3(\n\t\tvec3(  1.60475, -0.10208, -0.00327 ),\t\tvec3( -0.53108,  1.10813, -0.07276 ),\n\t\tvec3( -0.07367, -0.00605,  1.07602 )\n\t);\n\tcolor *= toneMappingExposure / 0.6;\n\tcolor = ACESInputMat * color;\n\tcolor = RRTAndODTFit( color );\n\tcolor = ACESOutputMat * color;\n\treturn saturate( color );\n}\nvec3 CustomToneMapping( vec3 color ) { return color; }",
								transmissionmap_fragment:
									"#ifdef USE_TRANSMISSIONMAP\n\ttotalTransmission *= texture2D( transmissionMap, vUv ).r;\n#endif",
								transmissionmap_pars_fragment:
									"#ifdef USE_TRANSMISSIONMAP\n\tuniform sampler2D transmissionMap;\n#endif",
								uv_pars_fragment:
									"#if ( defined( USE_UV ) && ! defined( UVS_VERTEX_ONLY ) )\n\tvarying vec2 vUv;\n#endif",
								uv_pars_vertex:
									"#ifdef USE_UV\n\t#ifdef UVS_VERTEX_ONLY\n\t\tvec2 vUv;\n\t#else\n\t\tvarying vec2 vUv;\n\t#endif\n\tuniform mat3 uvTransform;\n#endif",
								uv_vertex:
									"#ifdef USE_UV\n\tvUv = ( uvTransform * vec3( uv, 1 ) ).xy;\n#endif",
								uv2_pars_fragment:
									"#if defined( USE_LIGHTMAP ) || defined( USE_AOMAP )\n\tvarying vec2 vUv2;\n#endif",
								uv2_pars_vertex:
									"#if defined( USE_LIGHTMAP ) || defined( USE_AOMAP )\n\tattribute vec2 uv2;\n\tvarying vec2 vUv2;\n\tuniform mat3 uv2Transform;\n#endif",
								uv2_vertex:
									"#if defined( USE_LIGHTMAP ) || defined( USE_AOMAP )\n\tvUv2 = ( uv2Transform * vec3( uv2, 1 ) ).xy;\n#endif",
								worldpos_vertex:
									"#if defined( USE_ENVMAP ) || defined( DISTANCE ) || defined ( USE_SHADOWMAP )\n\tvec4 worldPosition = vec4( transformed, 1.0 );\n\t#ifdef USE_INSTANCING\n\t\tworldPosition = instanceMatrix * worldPosition;\n\t#endif\n\tworldPosition = modelMatrix * worldPosition;\n#endif",
								background_frag:
									"uniform sampler2D t2D;\nvarying vec2 vUv;\nvoid main() {\n\tvec4 texColor = texture2D( t2D, vUv );\n\tgl_FragColor = mapTexelToLinear( texColor );\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n}",
								background_vert:
									"varying vec2 vUv;\nuniform mat3 uvTransform;\nvoid main() {\n\tvUv = ( uvTransform * vec3( uv, 1 ) ).xy;\n\tgl_Position = vec4( position.xy, 1.0, 1.0 );\n}",
								cube_frag:
									"#include <envmap_common_pars_fragment>\nuniform float opacity;\nvarying vec3 vWorldDirection;\n#include <cube_uv_reflection_fragment>\nvoid main() {\n\tvec3 vReflect = vWorldDirection;\n\t#include <envmap_fragment>\n\tgl_FragColor = envColor;\n\tgl_FragColor.a *= opacity;\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n}",
								cube_vert:
									"varying vec3 vWorldDirection;\n#include <common>\nvoid main() {\n\tvWorldDirection = transformDirection( position, modelMatrix );\n\t#include <begin_vertex>\n\t#include <project_vertex>\n\tgl_Position.z = gl_Position.w;\n}",
								depth_frag:
									"#if DEPTH_PACKING == 3200\n\tuniform float opacity;\n#endif\n#include <common>\n#include <packing>\n#include <uv_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvarying vec2 vHighPrecisionZW;\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tvec4 diffuseColor = vec4( 1.0 );\n\t#if DEPTH_PACKING == 3200\n\t\tdiffuseColor.a = opacity;\n\t#endif\n\t#include <map_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\t#include <logdepthbuf_fragment>\n\tfloat fragCoordZ = 0.5 * vHighPrecisionZW[0] / vHighPrecisionZW[1] + 0.5;\n\t#if DEPTH_PACKING == 3200\n\t\tgl_FragColor = vec4( vec3( 1.0 - fragCoordZ ), opacity );\n\t#elif DEPTH_PACKING == 3201\n\t\tgl_FragColor = packDepthToRGBA( fragCoordZ );\n\t#endif\n}",
								depth_vert:
									"#include <common>\n#include <uv_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvarying vec2 vHighPrecisionZW;\nvoid main() {\n\t#include <uv_vertex>\n\t#include <skinbase_vertex>\n\t#ifdef USE_DISPLACEMENTMAP\n\t\t#include <beginnormal_vertex>\n\t\t#include <morphnormal_vertex>\n\t\t#include <skinnormal_vertex>\n\t#endif\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <displacementmap_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\tvHighPrecisionZW = gl_Position.zw;\n}",
								distanceRGBA_frag:
									"#define DISTANCE\nuniform vec3 referencePosition;\nuniform float nearDistance;\nuniform float farDistance;\nvarying vec3 vWorldPosition;\n#include <common>\n#include <packing>\n#include <uv_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main () {\n\t#include <clipping_planes_fragment>\n\tvec4 diffuseColor = vec4( 1.0 );\n\t#include <map_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\tfloat dist = length( vWorldPosition - referencePosition );\n\tdist = ( dist - nearDistance ) / ( farDistance - nearDistance );\n\tdist = saturate( dist );\n\tgl_FragColor = packDepthToRGBA( dist );\n}",
								distanceRGBA_vert:
									"#define DISTANCE\nvarying vec3 vWorldPosition;\n#include <common>\n#include <uv_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <skinbase_vertex>\n\t#ifdef USE_DISPLACEMENTMAP\n\t\t#include <beginnormal_vertex>\n\t\t#include <morphnormal_vertex>\n\t\t#include <skinnormal_vertex>\n\t#endif\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <displacementmap_vertex>\n\t#include <project_vertex>\n\t#include <worldpos_vertex>\n\t#include <clipping_planes_vertex>\n\tvWorldPosition = worldPosition.xyz;\n}",
								equirect_frag:
									"uniform sampler2D tEquirect;\nvarying vec3 vWorldDirection;\n#include <common>\nvoid main() {\n\tvec3 direction = normalize( vWorldDirection );\n\tvec2 sampleUV = equirectUv( direction );\n\tvec4 texColor = texture2D( tEquirect, sampleUV );\n\tgl_FragColor = mapTexelToLinear( texColor );\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n}",
								equirect_vert:
									"varying vec3 vWorldDirection;\n#include <common>\nvoid main() {\n\tvWorldDirection = transformDirection( position, modelMatrix );\n\t#include <begin_vertex>\n\t#include <project_vertex>\n}",
								linedashed_frag:
									"uniform vec3 diffuse;\nuniform float opacity;\nuniform float dashSize;\nuniform float totalSize;\nvarying float vLineDistance;\n#include <common>\n#include <color_pars_fragment>\n#include <fog_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tif ( mod( vLineDistance, totalSize ) > dashSize ) {\n\t\tdiscard;\n\t}\n\tvec3 outgoingLight = vec3( 0.0 );\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\t#include <logdepthbuf_fragment>\n\t#include <color_fragment>\n\toutgoingLight = diffuseColor.rgb;\n\tgl_FragColor = vec4( outgoingLight, diffuseColor.a );\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n\t#include <premultiplied_alpha_fragment>\n}",
								linedashed_vert:
									"uniform float scale;\nattribute float lineDistance;\nvarying float vLineDistance;\n#include <common>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\tvLineDistance = scale * lineDistance;\n\t#include <color_vertex>\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\t#include <fog_vertex>\n}",
								meshbasic_frag:
									"uniform vec3 diffuse;\nuniform float opacity;\n#ifndef FLAT_SHADED\n\tvarying vec3 vNormal;\n#endif\n#include <common>\n#include <dithering_pars_fragment>\n#include <color_pars_fragment>\n#include <uv_pars_fragment>\n#include <uv2_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <aomap_pars_fragment>\n#include <lightmap_pars_fragment>\n#include <envmap_common_pars_fragment>\n#include <envmap_pars_fragment>\n#include <cube_uv_reflection_fragment>\n#include <fog_pars_fragment>\n#include <specularmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\t#include <logdepthbuf_fragment>\n\t#include <map_fragment>\n\t#include <color_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\t#include <specularmap_fragment>\n\tReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );\n\t#ifdef USE_LIGHTMAP\n\t\n\t\tvec4 lightMapTexel= texture2D( lightMap, vUv2 );\n\t\treflectedLight.indirectDiffuse += lightMapTexelToLinear( lightMapTexel ).rgb * lightMapIntensity;\n\t#else\n\t\treflectedLight.indirectDiffuse += vec3( 1.0 );\n\t#endif\n\t#include <aomap_fragment>\n\treflectedLight.indirectDiffuse *= diffuseColor.rgb;\n\tvec3 outgoingLight = reflectedLight.indirectDiffuse;\n\t#include <envmap_fragment>\n\tgl_FragColor = vec4( outgoingLight, diffuseColor.a );\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n\t#include <premultiplied_alpha_fragment>\n\t#include <dithering_fragment>\n}",
								meshbasic_vert:
									"#include <common>\n#include <uv_pars_vertex>\n#include <uv2_pars_vertex>\n#include <envmap_pars_vertex>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <uv2_vertex>\n\t#include <color_vertex>\n\t#include <skinbase_vertex>\n\t#ifdef USE_ENVMAP\n\t#include <beginnormal_vertex>\n\t#include <morphnormal_vertex>\n\t#include <skinnormal_vertex>\n\t#include <defaultnormal_vertex>\n\t#endif\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <worldpos_vertex>\n\t#include <clipping_planes_vertex>\n\t#include <envmap_vertex>\n\t#include <fog_vertex>\n}",
								meshlambert_frag:
									"uniform vec3 diffuse;\nuniform vec3 emissive;\nuniform float opacity;\nvarying vec3 vLightFront;\nvarying vec3 vIndirectFront;\n#ifdef DOUBLE_SIDED\n\tvarying vec3 vLightBack;\n\tvarying vec3 vIndirectBack;\n#endif\n#include <common>\n#include <packing>\n#include <dithering_pars_fragment>\n#include <color_pars_fragment>\n#include <uv_pars_fragment>\n#include <uv2_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <aomap_pars_fragment>\n#include <lightmap_pars_fragment>\n#include <emissivemap_pars_fragment>\n#include <envmap_common_pars_fragment>\n#include <envmap_pars_fragment>\n#include <cube_uv_reflection_fragment>\n#include <bsdfs>\n#include <lights_pars_begin>\n#include <fog_pars_fragment>\n#include <shadowmap_pars_fragment>\n#include <shadowmask_pars_fragment>\n#include <specularmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\tReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );\n\tvec3 totalEmissiveRadiance = emissive;\n\t#include <logdepthbuf_fragment>\n\t#include <map_fragment>\n\t#include <color_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\t#include <specularmap_fragment>\n\t#include <emissivemap_fragment>\n\t#ifdef DOUBLE_SIDED\n\t\treflectedLight.indirectDiffuse += ( gl_FrontFacing ) ? vIndirectFront : vIndirectBack;\n\t#else\n\t\treflectedLight.indirectDiffuse += vIndirectFront;\n\t#endif\n\t#include <lightmap_fragment>\n\treflectedLight.indirectDiffuse *= BRDF_Diffuse_Lambert( diffuseColor.rgb );\n\t#ifdef DOUBLE_SIDED\n\t\treflectedLight.directDiffuse = ( gl_FrontFacing ) ? vLightFront : vLightBack;\n\t#else\n\t\treflectedLight.directDiffuse = vLightFront;\n\t#endif\n\treflectedLight.directDiffuse *= BRDF_Diffuse_Lambert( diffuseColor.rgb ) * getShadowMask();\n\t#include <aomap_fragment>\n\tvec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + totalEmissiveRadiance;\n\t#include <envmap_fragment>\n\tgl_FragColor = vec4( outgoingLight, diffuseColor.a );\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n\t#include <premultiplied_alpha_fragment>\n\t#include <dithering_fragment>\n}",
								meshlambert_vert:
									"#define LAMBERT\nvarying vec3 vLightFront;\nvarying vec3 vIndirectFront;\n#ifdef DOUBLE_SIDED\n\tvarying vec3 vLightBack;\n\tvarying vec3 vIndirectBack;\n#endif\n#include <common>\n#include <uv_pars_vertex>\n#include <uv2_pars_vertex>\n#include <envmap_pars_vertex>\n#include <bsdfs>\n#include <lights_pars_begin>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <shadowmap_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <uv2_vertex>\n\t#include <color_vertex>\n\t#include <beginnormal_vertex>\n\t#include <morphnormal_vertex>\n\t#include <skinbase_vertex>\n\t#include <skinnormal_vertex>\n\t#include <defaultnormal_vertex>\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\t#include <worldpos_vertex>\n\t#include <envmap_vertex>\n\t#include <lights_lambert_vertex>\n\t#include <shadowmap_vertex>\n\t#include <fog_vertex>\n}",
								meshmatcap_frag:
									"#define MATCAP\nuniform vec3 diffuse;\nuniform float opacity;\nuniform sampler2D matcap;\nvarying vec3 vViewPosition;\n#ifndef FLAT_SHADED\n\tvarying vec3 vNormal;\n#endif\n#include <common>\n#include <dithering_pars_fragment>\n#include <color_pars_fragment>\n#include <uv_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <fog_pars_fragment>\n#include <bumpmap_pars_fragment>\n#include <normalmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\t#include <logdepthbuf_fragment>\n\t#include <map_fragment>\n\t#include <color_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\t#include <normal_fragment_begin>\n\t#include <normal_fragment_maps>\n\tvec3 viewDir = normalize( vViewPosition );\n\tvec3 x = normalize( vec3( viewDir.z, 0.0, - viewDir.x ) );\n\tvec3 y = cross( viewDir, x );\n\tvec2 uv = vec2( dot( x, normal ), dot( y, normal ) ) * 0.495 + 0.5;\n\t#ifdef USE_MATCAP\n\t\tvec4 matcapColor = texture2D( matcap, uv );\n\t\tmatcapColor = matcapTexelToLinear( matcapColor );\n\t#else\n\t\tvec4 matcapColor = vec4( 1.0 );\n\t#endif\n\tvec3 outgoingLight = diffuseColor.rgb * matcapColor.rgb;\n\tgl_FragColor = vec4( outgoingLight, diffuseColor.a );\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n\t#include <premultiplied_alpha_fragment>\n\t#include <dithering_fragment>\n}",
								meshmatcap_vert:
									"#define MATCAP\nvarying vec3 vViewPosition;\n#ifndef FLAT_SHADED\n\tvarying vec3 vNormal;\n#endif\n#include <common>\n#include <uv_pars_vertex>\n#include <color_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <fog_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <color_vertex>\n\t#include <beginnormal_vertex>\n\t#include <morphnormal_vertex>\n\t#include <skinbase_vertex>\n\t#include <skinnormal_vertex>\n\t#include <defaultnormal_vertex>\n\t#ifndef FLAT_SHADED\n\t\tvNormal = normalize( transformedNormal );\n\t#endif\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <displacementmap_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\t#include <fog_vertex>\n\tvViewPosition = - mvPosition.xyz;\n}",
								meshtoon_frag:
									"#define TOON\nuniform vec3 diffuse;\nuniform vec3 emissive;\nuniform float opacity;\n#include <common>\n#include <packing>\n#include <dithering_pars_fragment>\n#include <color_pars_fragment>\n#include <uv_pars_fragment>\n#include <uv2_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <aomap_pars_fragment>\n#include <lightmap_pars_fragment>\n#include <emissivemap_pars_fragment>\n#include <gradientmap_pars_fragment>\n#include <fog_pars_fragment>\n#include <bsdfs>\n#include <lights_pars_begin>\n#include <lights_toon_pars_fragment>\n#include <shadowmap_pars_fragment>\n#include <bumpmap_pars_fragment>\n#include <normalmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\tReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );\n\tvec3 totalEmissiveRadiance = emissive;\n\t#include <logdepthbuf_fragment>\n\t#include <map_fragment>\n\t#include <color_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\t#include <normal_fragment_begin>\n\t#include <normal_fragment_maps>\n\t#include <emissivemap_fragment>\n\t#include <lights_toon_fragment>\n\t#include <lights_fragment_begin>\n\t#include <lights_fragment_maps>\n\t#include <lights_fragment_end>\n\t#include <aomap_fragment>\n\tvec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + totalEmissiveRadiance;\n\tgl_FragColor = vec4( outgoingLight, diffuseColor.a );\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n\t#include <premultiplied_alpha_fragment>\n\t#include <dithering_fragment>\n}",
								meshtoon_vert:
									"#define TOON\nvarying vec3 vViewPosition;\n#ifndef FLAT_SHADED\n\tvarying vec3 vNormal;\n#endif\n#include <common>\n#include <uv_pars_vertex>\n#include <uv2_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <shadowmap_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <uv2_vertex>\n\t#include <color_vertex>\n\t#include <beginnormal_vertex>\n\t#include <morphnormal_vertex>\n\t#include <skinbase_vertex>\n\t#include <skinnormal_vertex>\n\t#include <defaultnormal_vertex>\n#ifndef FLAT_SHADED\n\tvNormal = normalize( transformedNormal );\n#endif\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <displacementmap_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\tvViewPosition = - mvPosition.xyz;\n\t#include <worldpos_vertex>\n\t#include <shadowmap_vertex>\n\t#include <fog_vertex>\n}",
								meshphong_frag:
									"#define PHONG\nuniform vec3 diffuse;\nuniform vec3 emissive;\nuniform vec3 specular;\nuniform float shininess;\nuniform float opacity;\n#include <common>\n#include <packing>\n#include <dithering_pars_fragment>\n#include <color_pars_fragment>\n#include <uv_pars_fragment>\n#include <uv2_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <aomap_pars_fragment>\n#include <lightmap_pars_fragment>\n#include <emissivemap_pars_fragment>\n#include <envmap_common_pars_fragment>\n#include <envmap_pars_fragment>\n#include <cube_uv_reflection_fragment>\n#include <fog_pars_fragment>\n#include <bsdfs>\n#include <lights_pars_begin>\n#include <lights_phong_pars_fragment>\n#include <shadowmap_pars_fragment>\n#include <bumpmap_pars_fragment>\n#include <normalmap_pars_fragment>\n#include <specularmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\tReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );\n\tvec3 totalEmissiveRadiance = emissive;\n\t#include <logdepthbuf_fragment>\n\t#include <map_fragment>\n\t#include <color_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\t#include <specularmap_fragment>\n\t#include <normal_fragment_begin>\n\t#include <normal_fragment_maps>\n\t#include <emissivemap_fragment>\n\t#include <lights_phong_fragment>\n\t#include <lights_fragment_begin>\n\t#include <lights_fragment_maps>\n\t#include <lights_fragment_end>\n\t#include <aomap_fragment>\n\tvec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + reflectedLight.directSpecular + reflectedLight.indirectSpecular + totalEmissiveRadiance;\n\t#include <envmap_fragment>\n\tgl_FragColor = vec4( outgoingLight, diffuseColor.a );\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n\t#include <premultiplied_alpha_fragment>\n\t#include <dithering_fragment>\n}",
								meshphong_vert:
									"#define PHONG\nvarying vec3 vViewPosition;\n#ifndef FLAT_SHADED\n\tvarying vec3 vNormal;\n#endif\n#include <common>\n#include <uv_pars_vertex>\n#include <uv2_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <envmap_pars_vertex>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <shadowmap_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <uv2_vertex>\n\t#include <color_vertex>\n\t#include <beginnormal_vertex>\n\t#include <morphnormal_vertex>\n\t#include <skinbase_vertex>\n\t#include <skinnormal_vertex>\n\t#include <defaultnormal_vertex>\n#ifndef FLAT_SHADED\n\tvNormal = normalize( transformedNormal );\n#endif\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <displacementmap_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\tvViewPosition = - mvPosition.xyz;\n\t#include <worldpos_vertex>\n\t#include <envmap_vertex>\n\t#include <shadowmap_vertex>\n\t#include <fog_vertex>\n}",
								meshphysical_frag:
									"#define STANDARD\n#ifdef PHYSICAL\n\t#define REFLECTIVITY\n\t#define CLEARCOAT\n\t#define TRANSMISSION\n#endif\nuniform vec3 diffuse;\nuniform vec3 emissive;\nuniform float roughness;\nuniform float metalness;\nuniform float opacity;\n#ifdef TRANSMISSION\n\tuniform float transmission;\n#endif\n#ifdef REFLECTIVITY\n\tuniform float reflectivity;\n#endif\n#ifdef CLEARCOAT\n\tuniform float clearcoat;\n\tuniform float clearcoatRoughness;\n#endif\n#ifdef USE_SHEEN\n\tuniform vec3 sheen;\n#endif\nvarying vec3 vViewPosition;\n#ifndef FLAT_SHADED\n\tvarying vec3 vNormal;\n\t#ifdef USE_TANGENT\n\t\tvarying vec3 vTangent;\n\t\tvarying vec3 vBitangent;\n\t#endif\n#endif\n#include <common>\n#include <packing>\n#include <dithering_pars_fragment>\n#include <color_pars_fragment>\n#include <uv_pars_fragment>\n#include <uv2_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <aomap_pars_fragment>\n#include <lightmap_pars_fragment>\n#include <emissivemap_pars_fragment>\n#include <transmissionmap_pars_fragment>\n#include <bsdfs>\n#include <cube_uv_reflection_fragment>\n#include <envmap_common_pars_fragment>\n#include <envmap_physical_pars_fragment>\n#include <fog_pars_fragment>\n#include <lights_pars_begin>\n#include <lights_physical_pars_fragment>\n#include <shadowmap_pars_fragment>\n#include <bumpmap_pars_fragment>\n#include <normalmap_pars_fragment>\n#include <clearcoat_pars_fragment>\n#include <roughnessmap_pars_fragment>\n#include <metalnessmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\tReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );\n\tvec3 totalEmissiveRadiance = emissive;\n\t#ifdef TRANSMISSION\n\t\tfloat totalTransmission = transmission;\n\t#endif\n\t#include <logdepthbuf_fragment>\n\t#include <map_fragment>\n\t#include <color_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\t#include <roughnessmap_fragment>\n\t#include <metalnessmap_fragment>\n\t#include <normal_fragment_begin>\n\t#include <normal_fragment_maps>\n\t#include <clearcoat_normal_fragment_begin>\n\t#include <clearcoat_normal_fragment_maps>\n\t#include <emissivemap_fragment>\n\t#include <transmissionmap_fragment>\n\t#include <lights_physical_fragment>\n\t#include <lights_fragment_begin>\n\t#include <lights_fragment_maps>\n\t#include <lights_fragment_end>\n\t#include <aomap_fragment>\n\tvec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + reflectedLight.directSpecular + reflectedLight.indirectSpecular + totalEmissiveRadiance;\n\t#ifdef TRANSMISSION\n\t\tdiffuseColor.a *= saturate( 1. - totalTransmission + linearToRelativeLuminance( reflectedLight.directSpecular + reflectedLight.indirectSpecular ) );\n\t#endif\n\tgl_FragColor = vec4( outgoingLight, diffuseColor.a );\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n\t#include <premultiplied_alpha_fragment>\n\t#include <dithering_fragment>\n}",
								meshphysical_vert:
									"#define STANDARD\nvarying vec3 vViewPosition;\n#ifndef FLAT_SHADED\n\tvarying vec3 vNormal;\n\t#ifdef USE_TANGENT\n\t\tvarying vec3 vTangent;\n\t\tvarying vec3 vBitangent;\n\t#endif\n#endif\n#include <common>\n#include <uv_pars_vertex>\n#include <uv2_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <shadowmap_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <uv2_vertex>\n\t#include <color_vertex>\n\t#include <beginnormal_vertex>\n\t#include <morphnormal_vertex>\n\t#include <skinbase_vertex>\n\t#include <skinnormal_vertex>\n\t#include <defaultnormal_vertex>\n#ifndef FLAT_SHADED\n\tvNormal = normalize( transformedNormal );\n\t#ifdef USE_TANGENT\n\t\tvTangent = normalize( transformedTangent );\n\t\tvBitangent = normalize( cross( vNormal, vTangent ) * tangent.w );\n\t#endif\n#endif\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <displacementmap_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\tvViewPosition = - mvPosition.xyz;\n\t#include <worldpos_vertex>\n\t#include <shadowmap_vertex>\n\t#include <fog_vertex>\n}",
								normal_frag:
									"#define NORMAL\nuniform float opacity;\n#if defined( FLAT_SHADED ) || defined( USE_BUMPMAP ) || defined( TANGENTSPACE_NORMALMAP )\n\tvarying vec3 vViewPosition;\n#endif\n#ifndef FLAT_SHADED\n\tvarying vec3 vNormal;\n\t#ifdef USE_TANGENT\n\t\tvarying vec3 vTangent;\n\t\tvarying vec3 vBitangent;\n\t#endif\n#endif\n#include <packing>\n#include <uv_pars_fragment>\n#include <bumpmap_pars_fragment>\n#include <normalmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\t#include <logdepthbuf_fragment>\n\t#include <normal_fragment_begin>\n\t#include <normal_fragment_maps>\n\tgl_FragColor = vec4( packNormalToRGB( normal ), opacity );\n}",
								normal_vert:
									"#define NORMAL\n#if defined( FLAT_SHADED ) || defined( USE_BUMPMAP ) || defined( TANGENTSPACE_NORMALMAP )\n\tvarying vec3 vViewPosition;\n#endif\n#ifndef FLAT_SHADED\n\tvarying vec3 vNormal;\n\t#ifdef USE_TANGENT\n\t\tvarying vec3 vTangent;\n\t\tvarying vec3 vBitangent;\n\t#endif\n#endif\n#include <common>\n#include <uv_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <beginnormal_vertex>\n\t#include <morphnormal_vertex>\n\t#include <skinbase_vertex>\n\t#include <skinnormal_vertex>\n\t#include <defaultnormal_vertex>\n#ifndef FLAT_SHADED\n\tvNormal = normalize( transformedNormal );\n\t#ifdef USE_TANGENT\n\t\tvTangent = normalize( transformedTangent );\n\t\tvBitangent = normalize( cross( vNormal, vTangent ) * tangent.w );\n\t#endif\n#endif\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <displacementmap_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n#if defined( FLAT_SHADED ) || defined( USE_BUMPMAP ) || defined( TANGENTSPACE_NORMALMAP )\n\tvViewPosition = - mvPosition.xyz;\n#endif\n}",
								points_frag:
									"uniform vec3 diffuse;\nuniform float opacity;\n#include <common>\n#include <color_pars_fragment>\n#include <map_particle_pars_fragment>\n#include <fog_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tvec3 outgoingLight = vec3( 0.0 );\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\t#include <logdepthbuf_fragment>\n\t#include <map_particle_fragment>\n\t#include <color_fragment>\n\t#include <alphatest_fragment>\n\toutgoingLight = diffuseColor.rgb;\n\tgl_FragColor = vec4( outgoingLight, diffuseColor.a );\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n\t#include <premultiplied_alpha_fragment>\n}",
								points_vert:
									"uniform float size;\nuniform float scale;\n#include <common>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <color_vertex>\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <project_vertex>\n\tgl_PointSize = size;\n\t#ifdef USE_SIZEATTENUATION\n\t\tbool isPerspective = isPerspectiveMatrix( projectionMatrix );\n\t\tif ( isPerspective ) gl_PointSize *= ( scale / - mvPosition.z );\n\t#endif\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\t#include <worldpos_vertex>\n\t#include <fog_vertex>\n}",
								shadow_frag:
									"uniform vec3 color;\nuniform float opacity;\n#include <common>\n#include <packing>\n#include <fog_pars_fragment>\n#include <bsdfs>\n#include <lights_pars_begin>\n#include <shadowmap_pars_fragment>\n#include <shadowmask_pars_fragment>\nvoid main() {\n\tgl_FragColor = vec4( color, opacity * ( 1.0 - getShadowMask() ) );\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n}",
								shadow_vert:
									"#include <common>\n#include <fog_pars_vertex>\n#include <shadowmap_pars_vertex>\nvoid main() {\n\t#include <begin_vertex>\n\t#include <project_vertex>\n\t#include <worldpos_vertex>\n\t#include <beginnormal_vertex>\n\t#include <morphnormal_vertex>\n\t#include <skinbase_vertex>\n\t#include <skinnormal_vertex>\n\t#include <defaultnormal_vertex>\n\t#include <shadowmap_vertex>\n\t#include <fog_vertex>\n}",
								sprite_frag:
									"uniform vec3 diffuse;\nuniform float opacity;\n#include <common>\n#include <uv_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <fog_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tvec3 outgoingLight = vec3( 0.0 );\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\t#include <logdepthbuf_fragment>\n\t#include <map_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\toutgoingLight = diffuseColor.rgb;\n\tgl_FragColor = vec4( outgoingLight, diffuseColor.a );\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n}",
								sprite_vert:
									"uniform float rotation;\nuniform vec2 center;\n#include <common>\n#include <uv_pars_vertex>\n#include <fog_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\tvec4 mvPosition = modelViewMatrix * vec4( 0.0, 0.0, 0.0, 1.0 );\n\tvec2 scale;\n\tscale.x = length( vec3( modelMatrix[ 0 ].x, modelMatrix[ 0 ].y, modelMatrix[ 0 ].z ) );\n\tscale.y = length( vec3( modelMatrix[ 1 ].x, modelMatrix[ 1 ].y, modelMatrix[ 1 ].z ) );\n\t#ifndef USE_SIZEATTENUATION\n\t\tbool isPerspective = isPerspectiveMatrix( projectionMatrix );\n\t\tif ( isPerspective ) scale *= - mvPosition.z;\n\t#endif\n\tvec2 alignedPosition = ( position.xy - ( center - vec2( 0.5 ) ) ) * scale;\n\tvec2 rotatedPosition;\n\trotatedPosition.x = cos( rotation ) * alignedPosition.x - sin( rotation ) * alignedPosition.y;\n\trotatedPosition.y = sin( rotation ) * alignedPosition.x + cos( rotation ) * alignedPosition.y;\n\tmvPosition.xy += rotatedPosition;\n\tgl_Position = projectionMatrix * mvPosition;\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\t#include <fog_vertex>\n}",
							},
							ys = {
								basic: {
									uniforms: ts([
										us.common,
										us.specularmap,
										us.envmap,
										us.aomap,
										us.lightmap,
										us.fog,
									]),
									vertexShader: Ss.meshbasic_vert,
									fragmentShader: Ss.meshbasic_frag,
								},
								lambert: {
									uniforms: ts([
										us.common,
										us.specularmap,
										us.envmap,
										us.aomap,
										us.lightmap,
										us.emissivemap,
										us.fog,
										us.lights,
										{ emissive: { value: new Yo(0) } },
									]),
									vertexShader: Ss.meshlambert_vert,
									fragmentShader: Ss.meshlambert_frag,
								},
								phong: {
									uniforms: ts([
										us.common,
										us.specularmap,
										us.envmap,
										us.aomap,
										us.lightmap,
										us.emissivemap,
										us.bumpmap,
										us.normalmap,
										us.displacementmap,
										us.fog,
										us.lights,
										{
											emissive: { value: new Yo(0) },
											specular: { value: new Yo(1118481) },
											shininess: { value: 30 },
										},
									]),
									vertexShader: Ss.meshphong_vert,
									fragmentShader: Ss.meshphong_frag,
								},
								standard: {
									uniforms: ts([
										us.common,
										us.envmap,
										us.aomap,
										us.lightmap,
										us.emissivemap,
										us.bumpmap,
										us.normalmap,
										us.displacementmap,
										us.roughnessmap,
										us.metalnessmap,
										us.fog,
										us.lights,
										{
											emissive: { value: new Yo(0) },
											roughness: { value: 1 },
											metalness: { value: 0 },
											envMapIntensity: { value: 1 },
										},
									]),
									vertexShader: Ss.meshphysical_vert,
									fragmentShader: Ss.meshphysical_frag,
								},
								toon: {
									uniforms: ts([
										us.common,
										us.aomap,
										us.lightmap,
										us.emissivemap,
										us.bumpmap,
										us.normalmap,
										us.displacementmap,
										us.gradientmap,
										us.fog,
										us.lights,
										{ emissive: { value: new Yo(0) } },
									]),
									vertexShader: Ss.meshtoon_vert,
									fragmentShader: Ss.meshtoon_frag,
								},
								matcap: {
									uniforms: ts([
										us.common,
										us.bumpmap,
										us.normalmap,
										us.displacementmap,
										us.fog,
										{ matcap: { value: null } },
									]),
									vertexShader: Ss.meshmatcap_vert,
									fragmentShader: Ss.meshmatcap_frag,
								},
								points: {
									uniforms: ts([us.points, us.fog]),
									vertexShader: Ss.points_vert,
									fragmentShader: Ss.points_frag,
								},
								dashed: {
									uniforms: ts([
										us.common,
										us.fog,
										{
											scale: { value: 1 },
											dashSize: { value: 1 },
											totalSize: { value: 2 },
										},
									]),
									vertexShader: Ss.linedashed_vert,
									fragmentShader: Ss.linedashed_frag,
								},
								depth: {
									uniforms: ts([us.common, us.displacementmap]),
									vertexShader: Ss.depth_vert,
									fragmentShader: Ss.depth_frag,
								},
								normal: {
									uniforms: ts([
										us.common,
										us.bumpmap,
										us.normalmap,
										us.displacementmap,
										{ opacity: { value: 1 } },
									]),
									vertexShader: Ss.normal_vert,
									fragmentShader: Ss.normal_frag,
								},
								sprite: {
									uniforms: ts([us.sprite, us.fog]),
									vertexShader: Ss.sprite_vert,
									fragmentShader: Ss.sprite_frag,
								},
								background: {
									uniforms: {
										uvTransform: { value: new Mr() },
										t2D: { value: null },
									},
									vertexShader: Ss.background_vert,
									fragmentShader: Ss.background_frag,
								},
								cube: {
									uniforms: ts([us.envmap, { opacity: { value: 1 } }]),
									vertexShader: Ss.cube_vert,
									fragmentShader: Ss.cube_frag,
								},
								equirect: {
									uniforms: { tEquirect: { value: null } },
									vertexShader: Ss.equirect_vert,
									fragmentShader: Ss.equirect_frag,
								},
								distanceRGBA: {
									uniforms: ts([
										us.common,
										us.displacementmap,
										{
											referencePosition: { value: new zr() },
											nearDistance: { value: 1 },
											farDistance: { value: 1e3 },
										},
									]),
									vertexShader: Ss.distanceRGBA_vert,
									fragmentShader: Ss.distanceRGBA_frag,
								},
								shadow: {
									uniforms: ts([
										us.lights,
										us.fog,
										{ color: { value: new Yo(0) }, opacity: { value: 1 } },
									]),
									vertexShader: Ss.shadow_vert,
									fragmentShader: Ss.shadow_frag,
								},
							};
						function Vs(t, e, n, i) {
							const r = new Yo(0);
							let o,
								a,
								s = 0,
								c = null,
								l = 0,
								h = null;
							function p(t, n) {
								e.buffers.color.setClear(t.r, t.g, t.b, n, i);
							}
							return {
								getClearColor: function () {
									return r;
								},
								setClearColor: function (t, e) {
									r.set(t), (s = void 0 !== e ? e : 1), p(r, s);
								},
								getClearAlpha: function () {
									return s;
								},
								setClearAlpha: function (t) {
									(s = t), p(r, s);
								},
								render: function (e, i, u, d) {
									let m = !0 === i.isScene ? i.background : null;
									const f = t.xr,
										g = f.getSession && f.getSession();
									if (
										(g && "additive" === g.environmentBlendMode && (m = null),
										null === m
											? p(r, s)
											: m && m.isColor && (p(m, 1), (d = !0)),
										(t.autoClear || d) &&
											t.clear(
												t.autoClearColor,
												t.autoClearDepth,
												t.autoClearStencil
											),
										m &&
											(m.isCubeTexture ||
												m.isWebGLCubeRenderTarget ||
												m.mapping === Fi))
									) {
										void 0 === a &&
											((a = new La(
												new Xa(1, 1, 1),
												new ns({
													name: "BackgroundCubeMaterial",
													uniforms: $a(ys.cube.uniforms),
													vertexShader: ys.cube.vertexShader,
													fragmentShader: ys.cube.fragmentShader,
													side: 1,
													depthTest: !1,
													depthWrite: !1,
													fog: !1,
												})
											)),
											a.geometry.deleteAttribute("normal"),
											a.geometry.deleteAttribute("uv"),
											(a.onBeforeRender = function (t, e, n) {
												this.matrixWorld.copyPosition(n.matrixWorld);
											}),
											Object.defineProperty(a.material, "envMap", {
												get: function () {
													return this.uniforms.envMap.value;
												},
											}),
											n.update(a));
										const i = m.isWebGLCubeRenderTarget ? m.texture : m;
										(a.material.uniforms.envMap.value = i),
											(a.material.uniforms.flipEnvMap.value = i.isCubeTexture
												? -1
												: 1),
											(c === m && l === i.version && h === t.toneMapping) ||
												((a.material.needsUpdate = !0),
												(c = m),
												(l = i.version),
												(h = t.toneMapping)),
											e.unshift(a, a.geometry, a.material, 0, 0, null);
									} else
										m &&
											m.isTexture &&
											(void 0 === o &&
												((o = new La(
													new gs(2, 2),
													new ns({
														name: "BackgroundMaterial",
														uniforms: $a(ys.background.uniforms),
														vertexShader: ys.background.vertexShader,
														fragmentShader: ys.background.fragmentShader,
														side: 0,
														depthTest: !1,
														depthWrite: !1,
														fog: !1,
													})
												)),
												o.geometry.deleteAttribute("normal"),
												Object.defineProperty(o.material, "map", {
													get: function () {
														return this.uniforms.t2D.value;
													},
												}),
												n.update(o)),
											(o.material.uniforms.t2D.value = m),
											!0 === m.matrixAutoUpdate && m.updateMatrix(),
											o.material.uniforms.uvTransform.value.copy(m.matrix),
											(c === m && l === m.version && h === t.toneMapping) ||
												((o.material.needsUpdate = !0),
												(c = m),
												(l = m.version),
												(h = t.toneMapping)),
											e.unshift(o, o.geometry, o.material, 0, 0, null));
								},
							};
						}
						function qs(t, e, n, i) {
							const r = t.getParameter(34921),
								o = i.isWebGL2 ? null : e.get("OES_vertex_array_object"),
								a = i.isWebGL2 || null !== o,
								s = {},
								c = u(null);
							let l = c;
							function h(e) {
								return i.isWebGL2
									? t.bindVertexArray(e)
									: o.bindVertexArrayOES(e);
							}
							function p(e) {
								return i.isWebGL2
									? t.deleteVertexArray(e)
									: o.deleteVertexArrayOES(e);
							}
							function u(t) {
								const e = [],
									n = [],
									i = [];
								for (let t = 0; t < r; t++) (e[t] = 0), (n[t] = 0), (i[t] = 0);
								return {
									geometry: null,
									program: null,
									wireframe: !1,
									newAttributes: e,
									enabledAttributes: n,
									attributeDivisors: i,
									object: t,
									attributes: {},
								};
							}
							function d() {
								const t = l.newAttributes;
								for (let e = 0, n = t.length; e < n; e++) t[e] = 0;
							}
							function m(t) {
								f(t, 0);
							}
							function f(n, r) {
								const o = l.newAttributes,
									a = l.enabledAttributes,
									s = l.attributeDivisors;
								(o[n] = 1),
									0 === a[n] && (t.enableVertexAttribArray(n), (a[n] = 1)),
									s[n] !== r &&
										((i.isWebGL2 ? t : e.get("ANGLE_instanced_arrays"))[
											i.isWebGL2
												? "vertexAttribDivisor"
												: "vertexAttribDivisorANGLE"
										](n, r),
										(s[n] = r));
							}
							function g() {
								const e = l.newAttributes,
									n = l.enabledAttributes;
								for (let i = 0, r = n.length; i < r; i++)
									n[i] !== e[i] && (t.disableVertexAttribArray(i), (n[i] = 0));
							}
							function S(e, n, r, o, a, s) {
								!0 !== i.isWebGL2 || (5124 !== r && 5125 !== r)
									? t.vertexAttribPointer(e, n, r, o, a, s)
									: t.vertexAttribIPointer(e, n, r, a, s);
							}
							function y() {
								V(), l !== c && ((l = c), h(l.object));
							}
							function V() {
								(c.geometry = null), (c.program = null), (c.wireframe = !1);
							}
							return {
								setup: function (r, c, p, y, V) {
									let q = !1;
									if (a) {
										const e = (function (e, n, r) {
											const a = !0 === r.wireframe;
											let c = s[e.id];
											void 0 === c && ((c = {}), (s[e.id] = c));
											let l = c[n.id];
											void 0 === l && ((l = {}), (c[n.id] = l));
											let h = l[a];
											return (
												void 0 === h &&
													((h = u(
														i.isWebGL2
															? t.createVertexArray()
															: o.createVertexArrayOES()
													)),
													(l[a] = h)),
												h
											);
										})(y, p, c);
										l !== e && ((l = e), h(l.object)),
											(q = (function (t) {
												const e = l.attributes,
													n = t.attributes;
												if (Object.keys(e).length !== Object.keys(n).length)
													return !0;
												for (const t in n) {
													const i = e[t],
														r = n[t];
													if (i.attribute !== r) return !0;
													if (i.data !== r.data) return !0;
												}
												return !1;
											})(y)),
											q &&
												(function (t) {
													const e = {},
														n = t.attributes;
													for (const t in n) {
														const i = n[t],
															r = {};
														(r.attribute = i),
															i.data && (r.data = i.data),
															(e[t] = r);
													}
													l.attributes = e;
												})(y);
									} else {
										const t = !0 === c.wireframe;
										(l.geometry === y.id &&
											l.program === p.id &&
											l.wireframe === t) ||
											((l.geometry = y.id),
											(l.program = p.id),
											(l.wireframe = t),
											(q = !0));
									}
									!0 === r.isInstancedMesh && (q = !0),
										null !== V && n.update(V, 34963),
										q &&
											((function (r, o, a, s) {
												if (
													!1 === i.isWebGL2 &&
													(r.isInstancedMesh || s.isInstancedBufferGeometry) &&
													null === e.get("ANGLE_instanced_arrays")
												)
													return;
												d();
												const c = s.attributes,
													l = a.getAttributes(),
													h = o.defaultAttributeValues;
												for (const e in l) {
													const i = l[e];
													if (i >= 0) {
														const o = c[e];
														if (void 0 !== o) {
															const e = o.normalized,
																r = o.itemSize,
																a = n.get(o);
															if (void 0 === a) continue;
															const c = a.buffer,
																l = a.type,
																h = a.bytesPerElement;
															if (o.isInterleavedBufferAttribute) {
																const n = o.data,
																	a = n.stride,
																	p = o.offset;
																n && n.isInstancedInterleavedBuffer
																	? (f(i, n.meshPerAttribute),
																	  void 0 === s._maxInstanceCount &&
																			(s._maxInstanceCount =
																				n.meshPerAttribute * n.count))
																	: m(i),
																	t.bindBuffer(34962, c),
																	S(i, r, l, e, a * h, p * h);
															} else
																o.isInstancedBufferAttribute
																	? (f(i, o.meshPerAttribute),
																	  void 0 === s._maxInstanceCount &&
																			(s._maxInstanceCount =
																				o.meshPerAttribute * o.count))
																	: m(i),
																	t.bindBuffer(34962, c),
																	S(i, r, l, e, 0, 0);
														} else if ("instanceMatrix" === e) {
															const e = n.get(r.instanceMatrix);
															if (void 0 === e) continue;
															const o = e.buffer,
																a = e.type;
															f(i + 0, 1),
																f(i + 1, 1),
																f(i + 2, 1),
																f(i + 3, 1),
																t.bindBuffer(34962, o),
																t.vertexAttribPointer(i + 0, 4, a, !1, 64, 0),
																t.vertexAttribPointer(i + 1, 4, a, !1, 64, 16),
																t.vertexAttribPointer(i + 2, 4, a, !1, 64, 32),
																t.vertexAttribPointer(i + 3, 4, a, !1, 64, 48);
														} else if (void 0 !== h) {
															const n = h[e];
															if (void 0 !== n)
																switch (n.length) {
																	case 2:
																		t.vertexAttrib2fv(i, n);
																		break;
																	case 3:
																		t.vertexAttrib3fv(i, n);
																		break;
																	case 4:
																		t.vertexAttrib4fv(i, n);
																		break;
																	default:
																		t.vertexAttrib1fv(i, n);
																}
														}
													}
												}
												g();
											})(r, c, p, y),
											null !== V && t.bindBuffer(34963, n.get(V).buffer));
								},
								reset: y,
								resetDefaultState: V,
								dispose: function () {
									y();
									for (const t in s) {
										const e = s[t];
										for (const t in e) {
											const n = e[t];
											for (const t in n) p(n[t].object), delete n[t];
											delete e[t];
										}
										delete s[t];
									}
								},
								releaseStatesOfGeometry: function (t) {
									if (void 0 === s[t.id]) return;
									const e = s[t.id];
									for (const t in e) {
										const n = e[t];
										for (const t in n) p(n[t].object), delete n[t];
										delete e[t];
									}
									delete s[t.id];
								},
								releaseStatesOfProgram: function (t) {
									for (const e in s) {
										const n = s[e];
										if (void 0 === n[t.id]) continue;
										const i = n[t.id];
										for (const t in i) p(i[t].object), delete i[t];
										delete n[t.id];
									}
								},
								initAttributes: d,
								enableAttribute: m,
								disableUnusedAttributes: g,
							};
						}
						function Rs(t, e, n, i) {
							const r = i.isWebGL2;
							let o;
							(this.setMode = function (t) {
								o = t;
							}),
								(this.render = function (e, i) {
									t.drawArrays(o, e, i), n.update(i, o, 1);
								}),
								(this.renderInstances = function (i, a, s) {
									if (0 === s) return;
									let c, l;
									if (r) (c = t), (l = "drawArraysInstanced");
									else if (
										((c = e.get("ANGLE_instanced_arrays")),
										(l = "drawArraysInstancedANGLE"),
										null === c)
									)
										return void console.error(
											"THREE.WebGLBufferRenderer: using THREE.InstancedBufferGeometry but hardware does not support extension ANGLE_instanced_arrays."
										);
									c[l](o, i, a, s), n.update(a, o, s);
								});
						}
						function Ms(t, e, n) {
							let i;
							function r(e) {
								if ("highp" === e) {
									if (
										t.getShaderPrecisionFormat(35633, 36338).precision > 0 &&
										t.getShaderPrecisionFormat(35632, 36338).precision > 0
									)
										return "highp";
									e = "mediump";
								}
								return "mediump" === e &&
									t.getShaderPrecisionFormat(35633, 36337).precision > 0 &&
									t.getShaderPrecisionFormat(35632, 36337).precision > 0
									? "mediump"
									: "lowp";
							}
							const o =
								("undefined" != typeof WebGL2RenderingContext &&
									t instanceof WebGL2RenderingContext) ||
								("undefined" != typeof WebGL2ComputeRenderingContext &&
									t instanceof WebGL2ComputeRenderingContext);
							let a = void 0 !== n.precision ? n.precision : "highp";
							const s = r(a);
							s !== a &&
								(console.warn(
									"THREE.WebGLRenderer:",
									a,
									"not supported, using",
									s,
									"instead."
								),
								(a = s));
							const c = !0 === n.logarithmicDepthBuffer,
								l = t.getParameter(34930),
								h = t.getParameter(35660),
								p = t.getParameter(3379),
								u = t.getParameter(34076),
								d = t.getParameter(34921),
								m = t.getParameter(36347),
								f = t.getParameter(36348),
								g = t.getParameter(36349),
								S = h > 0,
								y = o || !!e.get("OES_texture_float");
							return {
								isWebGL2: o,
								getMaxAnisotropy: function () {
									if (void 0 !== i) return i;
									const n = e.get("EXT_texture_filter_anisotropic");
									return (
										(i =
											null !== n
												? t.getParameter(n.MAX_TEXTURE_MAX_ANISOTROPY_EXT)
												: 0),
										i
									);
								},
								getMaxPrecision: r,
								precision: a,
								logarithmicDepthBuffer: c,
								maxTextures: l,
								maxVertexTextures: h,
								maxTextureSize: p,
								maxCubemapSize: u,
								maxAttributes: d,
								maxVertexUniforms: m,
								maxVaryings: f,
								maxFragmentUniforms: g,
								vertexTextures: S,
								floatFragmentTextures: y,
								floatVertexTextures: S && y,
								maxSamples: o ? t.getParameter(36183) : 0,
							};
						}
						function Is() {
							const t = this;
							let e = null,
								n = 0,
								i = !1,
								r = !1;
							const o = new Co(),
								a = new Mr(),
								s = { value: null, needsUpdate: !1 };
							function c() {
								s.value !== e && ((s.value = e), (s.needsUpdate = n > 0)),
									(t.numPlanes = n),
									(t.numIntersection = 0);
							}
							function l(e, n, i, r) {
								let c = null !== e ? e.length : 0,
									l = null;
								if (0 !== c) {
									if (((l = s.value), !0 !== r || null === l)) {
										const t = i + 4 * c,
											r = n.matrixWorldInverse;
										a.getNormalMatrix(r),
											(null === l || l.length < t) && (l = new Float32Array(t));
										for (let t = 0, n = i; t !== c; ++t, n += 4)
											o.copy(e[t]).applyMatrix4(r, a),
												o.normal.toArray(l, n),
												(l[n + 3] = o.constant);
									}
									(s.value = l), (s.needsUpdate = !0);
								}
								return (t.numPlanes = c), (t.numIntersection = 0), l;
							}
							(this.uniform = s),
								(this.numPlanes = 0),
								(this.numIntersection = 0),
								(this.init = function (t, r, o) {
									const a = 0 !== t.length || r || 0 !== n || i;
									return (i = r), (e = l(t, o, 0)), (n = t.length), a;
								}),
								(this.beginShadows = function () {
									(r = !0), l(null);
								}),
								(this.endShadows = function () {
									(r = !1), c();
								}),
								(this.setState = function (t, o, a, h, p, u) {
									if (!i || null === t || 0 === t.length || (r && !a))
										r ? l(null) : c();
									else {
										const i = r ? 0 : n,
											a = 4 * i;
										let c = p.clippingState || null;
										(s.value = c), (c = l(t, h, a, u));
										for (let t = 0; t !== a; ++t) c[t] = e[t];
										(p.clippingState = c),
											(this.numIntersection = o ? this.numPlanes : 0),
											(this.numPlanes += i);
									}
								});
						}
						function vs(t) {
							const e = {};
							return {
								has: function (n) {
									if (void 0 !== e[n]) return e[n];
									let i;
									switch (n) {
										case "WEBGL_depth_texture":
											i =
												t.getExtension("WEBGL_depth_texture") ||
												t.getExtension("MOZ_WEBGL_depth_texture") ||
												t.getExtension("WEBKIT_WEBGL_depth_texture");
											break;
										case "EXT_texture_filter_anisotropic":
											i =
												t.getExtension("EXT_texture_filter_anisotropic") ||
												t.getExtension("MOZ_EXT_texture_filter_anisotropic") ||
												t.getExtension("WEBKIT_EXT_texture_filter_anisotropic");
											break;
										case "WEBGL_compressed_texture_s3tc":
											i =
												t.getExtension("WEBGL_compressed_texture_s3tc") ||
												t.getExtension("MOZ_WEBGL_compressed_texture_s3tc") ||
												t.getExtension("WEBKIT_WEBGL_compressed_texture_s3tc");
											break;
										case "WEBGL_compressed_texture_pvrtc":
											i =
												t.getExtension("WEBGL_compressed_texture_pvrtc") ||
												t.getExtension("WEBKIT_WEBGL_compressed_texture_pvrtc");
											break;
										default:
											i = t.getExtension(n);
									}
									return (e[n] = i), !!i;
								},
								get: function (t) {
									return (
										this.has(t) ||
											console.warn(
												"THREE.WebGLRenderer: " +
													t +
													" extension not supported."
											),
										e[t]
									);
								},
							};
						}
						function ks(t, e, n, i) {
							const r = new WeakMap(),
								o = new WeakMap();
							function a(t) {
								const s = t.target,
									c = r.get(s);
								null !== c.index && e.remove(c.index);
								for (const t in c.attributes) e.remove(c.attributes[t]);
								s.removeEventListener("dispose", a), r.delete(s);
								const l = o.get(c);
								l && (e.remove(l), o.delete(c)),
									i.releaseStatesOfGeometry(s),
									!0 === s.isInstancedBufferGeometry &&
										delete s._maxInstanceCount,
									n.memory.geometries--;
							}
							function s(t) {
								const n = [],
									i = t.index,
									r = t.attributes.position;
								let a = 0;
								if (null !== i) {
									const t = i.array;
									a = i.version;
									for (let e = 0, i = t.length; e < i; e += 3) {
										const i = t[e + 0],
											r = t[e + 1],
											o = t[e + 2];
										n.push(i, r, r, o, o, i);
									}
								} else {
									const t = r.array;
									a = r.version;
									for (let e = 0, i = t.length / 3 - 1; e < i; e += 3) {
										const t = e + 0,
											i = e + 1,
											r = e + 2;
										n.push(t, i, i, r, r, t);
									}
								}
								const s = new (ya(n) > 65535 ? ma : ua)(n, 1);
								s.version = a;
								const c = o.get(t);
								c && e.remove(c), o.set(t, s);
							}
							return {
								get: function (t, e) {
									let i = r.get(e);
									return (
										i ||
										(e.addEventListener("dispose", a),
										e.isBufferGeometry
											? (i = e)
											: e.isGeometry &&
											  (void 0 === e._bufferGeometry &&
													(e._bufferGeometry = new Ua().setFromObject(t)),
											  (i = e._bufferGeometry)),
										r.set(e, i),
										n.memory.geometries++,
										i)
									);
								},
								update: function (t) {
									const n = t.attributes;
									for (const t in n) e.update(n[t], 34962);
									const i = t.morphAttributes;
									for (const t in i) {
										const n = i[t];
										for (let t = 0, i = n.length; t < i; t++)
											e.update(n[t], 34962);
									}
								},
								getWireframeAttribute: function (t) {
									const e = o.get(t);
									if (e) {
										const n = t.index;
										null !== n && e.version < n.version && s(t);
									} else s(t);
									return o.get(t);
								},
							};
						}
						function Us(t, e, n, i) {
							const r = i.isWebGL2;
							let o, a, s;
							(this.setMode = function (t) {
								o = t;
							}),
								(this.setIndex = function (t) {
									(a = t.type), (s = t.bytesPerElement);
								}),
								(this.render = function (e, i) {
									t.drawElements(o, i, a, e * s), n.update(i, o, 1);
								}),
								(this.renderInstances = function (i, c, l) {
									if (0 === l) return;
									let h, p;
									if (r) (h = t), (p = "drawElementsInstanced");
									else if (
										((h = e.get("ANGLE_instanced_arrays")),
										(p = "drawElementsInstancedANGLE"),
										null === h)
									)
										return void console.error(
											"THREE.WebGLIndexedBufferRenderer: using THREE.InstancedBufferGeometry but hardware does not support extension ANGLE_instanced_arrays."
										);
									h[p](o, c, a, i * s, l), n.update(c, o, l);
								});
						}
						function ws(t) {
							const e = {
								frame: 0,
								calls: 0,
								triangles: 0,
								points: 0,
								lines: 0,
							};
							return {
								memory: { geometries: 0, textures: 0 },
								render: e,
								programs: null,
								autoReset: !0,
								reset: function () {
									e.frame++,
										(e.calls = 0),
										(e.triangles = 0),
										(e.points = 0),
										(e.lines = 0);
								},
								update: function (t, n, i) {
									switch ((e.calls++, n)) {
										case 4:
											e.triangles += i * (t / 3);
											break;
										case 1:
											e.lines += i * (t / 2);
											break;
										case 3:
											e.lines += i * (t - 1);
											break;
										case 2:
											e.lines += i * t;
											break;
										case 0:
											e.points += i * t;
											break;
										default:
											console.error("THREE.WebGLInfo: Unknown draw mode:", n);
									}
								},
							};
						}
						function xs(t, e) {
							return t[0] - e[0];
						}
						function Os(t, e) {
							return Math.abs(e[1]) - Math.abs(t[1]);
						}
						function bs(t) {
							const e = {},
								n = new Float32Array(8),
								i = [];
							for (let t = 0; t < 8; t++) i[t] = [t, 0];
							return {
								update: function (r, o, a, s) {
									const c = r.morphTargetInfluences,
										l = void 0 === c ? 0 : c.length;
									let h = e[o.id];
									if (void 0 === h) {
										h = [];
										for (let t = 0; t < l; t++) h[t] = [t, 0];
										e[o.id] = h;
									}
									for (let t = 0; t < l; t++) {
										const e = h[t];
										(e[0] = t), (e[1] = c[t]);
									}
									h.sort(Os);
									for (let t = 0; t < 8; t++)
										t < l && h[t][1]
											? ((i[t][0] = h[t][0]), (i[t][1] = h[t][1]))
											: ((i[t][0] = Number.MAX_SAFE_INTEGER), (i[t][1] = 0));
									i.sort(xs);
									const p = a.morphTargets && o.morphAttributes.position,
										u = a.morphNormals && o.morphAttributes.normal;
									let d = 0;
									for (let t = 0; t < 8; t++) {
										const e = i[t],
											r = e[0],
											a = e[1];
										r !== Number.MAX_SAFE_INTEGER && a
											? (p &&
													o.getAttribute("morphTarget" + t) !== p[r] &&
													o.setAttribute("morphTarget" + t, p[r]),
											  u &&
													o.getAttribute("morphNormal" + t) !== u[r] &&
													o.setAttribute("morphNormal" + t, u[r]),
											  (n[t] = a),
											  (d += a))
											: (p &&
													void 0 !== o.getAttribute("morphTarget" + t) &&
													o.deleteAttribute("morphTarget" + t),
											  u &&
													void 0 !== o.getAttribute("morphNormal" + t) &&
													o.deleteAttribute("morphNormal" + t),
											  (n[t] = 0));
									}
									const m = o.morphTargetsRelative ? 1 : 1 - d;
									s.getUniforms().setValue(t, "morphTargetBaseInfluence", m),
										s.getUniforms().setValue(t, "morphTargetInfluences", n);
								},
							};
						}
						function Ks(t, e, n, i) {
							let r = new WeakMap();
							return {
								update: function (t) {
									const o = i.render.frame,
										a = t.geometry,
										s = e.get(t, a);
									return (
										r.get(s) !== o &&
											(a.isGeometry && s.updateFromObject(t),
											e.update(s),
											r.set(s, o)),
										t.isInstancedMesh && n.update(t.instanceMatrix, 34962),
										s
									);
								},
								dispose: function () {
									r = new WeakMap();
								},
							};
						}
						function Ts(t, e, n, i, r, o, a, s, c, l) {
							(t = void 0 !== t ? t : []),
								(e = void 0 !== e ? e : 301),
								(a = void 0 !== a ? a : $i),
								Ur.call(this, t, e, n, i, r, o, a, s, c, l),
								(this.flipY = !1);
						}
						function zs(t, e, n, i) {
							Ur.call(this, null),
								(this.image = {
									data: t || null,
									width: e || 1,
									height: n || 1,
									depth: i || 1,
								}),
								(this.magFilter = Di),
								(this.minFilter = Di),
								(this.wrapR = Ni),
								(this.generateMipmaps = !1),
								(this.flipY = !1),
								(this.needsUpdate = !0);
						}
						function Ws(t, e, n, i) {
							Ur.call(this, null),
								(this.image = {
									data: t || null,
									width: e || 1,
									height: n || 1,
									depth: i || 1,
								}),
								(this.magFilter = Di),
								(this.minFilter = Di),
								(this.wrapR = Ni),
								(this.generateMipmaps = !1),
								(this.flipY = !1),
								(this.needsUpdate = !0);
						}
						(ys.physical = {
							uniforms: ts([
								ys.standard.uniforms,
								{
									clearcoat: { value: 0 },
									clearcoatMap: { value: null },
									clearcoatRoughness: { value: 0 },
									clearcoatRoughnessMap: { value: null },
									clearcoatNormalScale: { value: new Rr(1, 1) },
									clearcoatNormalMap: { value: null },
									sheen: { value: new Yo(0) },
									transmission: { value: 0 },
									transmissionMap: { value: null },
								},
							]),
							vertexShader: Ss.meshphysical_vert,
							fragmentShader: Ss.meshphysical_frag,
						}),
							(Ts.prototype = Object.create(Ur.prototype)),
							(Ts.prototype.constructor = Ts),
							(Ts.prototype.isCubeTexture = !0),
							Object.defineProperty(Ts.prototype, "images", {
								get: function () {
									return this.image;
								},
								set: function (t) {
									this.image = t;
								},
							}),
							(zs.prototype = Object.create(Ur.prototype)),
							(zs.prototype.constructor = zs),
							(zs.prototype.isDataTexture2DArray = !0),
							(Ws.prototype = Object.create(Ur.prototype)),
							(Ws.prototype.constructor = Ws),
							(Ws.prototype.isDataTexture3D = !0);
						const Es = new Ur(),
							Cs = new zs(),
							Fs = new Ws(),
							Zs = new Ts(),
							Hs = [],
							Ns = [],
							js = new Float32Array(16),
							Ds = new Float32Array(9),
							As = new Float32Array(4);
						function Ls(t, e, n) {
							const i = t[0];
							if (i <= 0 || i > 0) return t;
							let r = e * n,
								o = Hs[r];
							if (
								(void 0 === o && ((o = new Float32Array(r)), (Hs[r] = o)),
								0 !== e)
							) {
								i.toArray(o, 0);
								for (let i = 1, r = 0; i !== e; ++i)
									(r += n), t[i].toArray(o, r);
							}
							return o;
						}
						function Bs(t, e) {
							if (t.length !== e.length) return !1;
							for (let n = 0, i = t.length; n < i; n++)
								if (t[n] !== e[n]) return !1;
							return !0;
						}
						function Gs(t, e) {
							for (let n = 0, i = e.length; n < i; n++) t[n] = e[n];
						}
						function Qs(t, e) {
							let n = Ns[e];
							void 0 === n && ((n = new Int32Array(e)), (Ns[e] = n));
							for (let i = 0; i !== e; ++i) n[i] = t.allocateTextureUnit();
							return n;
						}
						function _s(t, e) {
							const n = this.cache;
							n[0] !== e && (t.uniform1f(this.addr, e), (n[0] = e));
						}
						function Ps(t, e) {
							const n = this.cache;
							if (void 0 !== e.x)
								(n[0] === e.x && n[1] === e.y) ||
									(t.uniform2f(this.addr, e.x, e.y),
									(n[0] = e.x),
									(n[1] = e.y));
							else {
								if (Bs(n, e)) return;
								t.uniform2fv(this.addr, e), Gs(n, e);
							}
						}
						function Js(t, e) {
							const n = this.cache;
							if (void 0 !== e.x)
								(n[0] === e.x && n[1] === e.y && n[2] === e.z) ||
									(t.uniform3f(this.addr, e.x, e.y, e.z),
									(n[0] = e.x),
									(n[1] = e.y),
									(n[2] = e.z));
							else if (void 0 !== e.r)
								(n[0] === e.r && n[1] === e.g && n[2] === e.b) ||
									(t.uniform3f(this.addr, e.r, e.g, e.b),
									(n[0] = e.r),
									(n[1] = e.g),
									(n[2] = e.b));
							else {
								if (Bs(n, e)) return;
								t.uniform3fv(this.addr, e), Gs(n, e);
							}
						}
						function Ys(t, e) {
							const n = this.cache;
							if (void 0 !== e.x)
								(n[0] === e.x &&
									n[1] === e.y &&
									n[2] === e.z &&
									n[3] === e.w) ||
									(t.uniform4f(this.addr, e.x, e.y, e.z, e.w),
									(n[0] = e.x),
									(n[1] = e.y),
									(n[2] = e.z),
									(n[3] = e.w));
							else {
								if (Bs(n, e)) return;
								t.uniform4fv(this.addr, e), Gs(n, e);
							}
						}
						function Xs(t, e) {
							const n = this.cache,
								i = e.elements;
							if (void 0 === i) {
								if (Bs(n, e)) return;
								t.uniformMatrix2fv(this.addr, !1, e), Gs(n, e);
							} else {
								if (Bs(n, i)) return;
								As.set(i), t.uniformMatrix2fv(this.addr, !1, As), Gs(n, i);
							}
						}
						function $s(t, e) {
							const n = this.cache,
								i = e.elements;
							if (void 0 === i) {
								if (Bs(n, e)) return;
								t.uniformMatrix3fv(this.addr, !1, e), Gs(n, e);
							} else {
								if (Bs(n, i)) return;
								Ds.set(i), t.uniformMatrix3fv(this.addr, !1, Ds), Gs(n, i);
							}
						}
						function tc(t, e) {
							const n = this.cache,
								i = e.elements;
							if (void 0 === i) {
								if (Bs(n, e)) return;
								t.uniformMatrix4fv(this.addr, !1, e), Gs(n, e);
							} else {
								if (Bs(n, i)) return;
								js.set(i), t.uniformMatrix4fv(this.addr, !1, js), Gs(n, i);
							}
						}
						function ec(t, e, n) {
							const i = this.cache,
								r = n.allocateTextureUnit();
							i[0] !== r && (t.uniform1i(this.addr, r), (i[0] = r)),
								n.safeSetTexture2D(e || Es, r);
						}
						function nc(t, e, n) {
							const i = this.cache,
								r = n.allocateTextureUnit();
							i[0] !== r && (t.uniform1i(this.addr, r), (i[0] = r)),
								n.setTexture2DArray(e || Cs, r);
						}
						function ic(t, e, n) {
							const i = this.cache,
								r = n.allocateTextureUnit();
							i[0] !== r && (t.uniform1i(this.addr, r), (i[0] = r)),
								n.setTexture3D(e || Fs, r);
						}
						function rc(t, e, n) {
							const i = this.cache,
								r = n.allocateTextureUnit();
							i[0] !== r && (t.uniform1i(this.addr, r), (i[0] = r)),
								n.safeSetTextureCube(e || Zs, r);
						}
						function oc(t, e) {
							const n = this.cache;
							n[0] !== e && (t.uniform1i(this.addr, e), (n[0] = e));
						}
						function ac(t, e) {
							const n = this.cache;
							Bs(n, e) || (t.uniform2iv(this.addr, e), Gs(n, e));
						}
						function sc(t, e) {
							const n = this.cache;
							Bs(n, e) || (t.uniform3iv(this.addr, e), Gs(n, e));
						}
						function cc(t, e) {
							const n = this.cache;
							Bs(n, e) || (t.uniform4iv(this.addr, e), Gs(n, e));
						}
						function lc(t, e) {
							const n = this.cache;
							n[0] !== e && (t.uniform1ui(this.addr, e), (n[0] = e));
						}
						function hc(t, e) {
							t.uniform1fv(this.addr, e);
						}
						function pc(t, e) {
							t.uniform1iv(this.addr, e);
						}
						function uc(t, e) {
							t.uniform2iv(this.addr, e);
						}
						function dc(t, e) {
							t.uniform3iv(this.addr, e);
						}
						function mc(t, e) {
							t.uniform4iv(this.addr, e);
						}
						function fc(t, e) {
							const n = Ls(e, this.size, 2);
							t.uniform2fv(this.addr, n);
						}
						function gc(t, e) {
							const n = Ls(e, this.size, 3);
							t.uniform3fv(this.addr, n);
						}
						function Sc(t, e) {
							const n = Ls(e, this.size, 4);
							t.uniform4fv(this.addr, n);
						}
						function yc(t, e) {
							const n = Ls(e, this.size, 4);
							t.uniformMatrix2fv(this.addr, !1, n);
						}
						function Vc(t, e) {
							const n = Ls(e, this.size, 9);
							t.uniformMatrix3fv(this.addr, !1, n);
						}
						function qc(t, e) {
							const n = Ls(e, this.size, 16);
							t.uniformMatrix4fv(this.addr, !1, n);
						}
						function Rc(t, e, n) {
							const i = e.length,
								r = Qs(n, i);
							t.uniform1iv(this.addr, r);
							for (let t = 0; t !== i; ++t)
								n.safeSetTexture2D(e[t] || Es, r[t]);
						}
						function Mc(t, e, n) {
							const i = e.length,
								r = Qs(n, i);
							t.uniform1iv(this.addr, r);
							for (let t = 0; t !== i; ++t)
								n.safeSetTextureCube(e[t] || Zs, r[t]);
						}
						function Ic(t, e, n) {
							(this.id = t),
								(this.addr = n),
								(this.cache = []),
								(this.setValue = (function (t) {
									switch (t) {
										case 5126:
											return _s;
										case 35664:
											return Ps;
										case 35665:
											return Js;
										case 35666:
											return Ys;
										case 35674:
											return Xs;
										case 35675:
											return $s;
										case 35676:
											return tc;
										case 5124:
										case 35670:
											return oc;
										case 35667:
										case 35671:
											return ac;
										case 35668:
										case 35672:
											return sc;
										case 35669:
										case 35673:
											return cc;
										case 5125:
											return lc;
										case 35678:
										case 36198:
										case 36298:
										case 36306:
										case 35682:
											return ec;
										case 35679:
										case 36299:
										case 36307:
											return ic;
										case 35680:
										case 36300:
										case 36308:
										case 36293:
											return rc;
										case 36289:
										case 36303:
										case 36311:
										case 36292:
											return nc;
									}
								})(e.type));
						}
						function vc(t, e, n) {
							(this.id = t),
								(this.addr = n),
								(this.cache = []),
								(this.size = e.size),
								(this.setValue = (function (t) {
									switch (t) {
										case 5126:
											return hc;
										case 35664:
											return fc;
										case 35665:
											return gc;
										case 35666:
											return Sc;
										case 35674:
											return yc;
										case 35675:
											return Vc;
										case 35676:
											return qc;
										case 5124:
										case 35670:
											return pc;
										case 35667:
										case 35671:
											return uc;
										case 35668:
										case 35672:
											return dc;
										case 35669:
										case 35673:
											return mc;
										case 35678:
										case 36198:
										case 36298:
										case 36306:
										case 35682:
											return Rc;
										case 35680:
										case 36300:
										case 36308:
										case 36293:
											return Mc;
									}
								})(e.type));
						}
						function kc(t) {
							(this.id = t), (this.seq = []), (this.map = {});
						}
						(vc.prototype.updateCache = function (t) {
							let e = this.cache;
							t instanceof Float32Array &&
								e.length !== t.length &&
								(this.cache = new Float32Array(t.length)),
								Gs(e, t);
						}),
							(kc.prototype.setValue = function (t, e, n) {
								const i = this.seq;
								for (let r = 0, o = i.length; r !== o; ++r) {
									const o = i[r];
									o.setValue(t, e[o.id], n);
								}
							});
						const Uc = /([\w\d_]+)(\])?(\[|\.)?/g;
						function wc(t, e) {
							t.seq.push(e), (t.map[e.id] = e);
						}
						function xc(t, e, n) {
							const i = t.name,
								r = i.length;
							for (Uc.lastIndex = 0; ; ) {
								const o = Uc.exec(i),
									a = Uc.lastIndex;
								let s = o[1],
									c = "]" === o[2],
									l = o[3];
								if (
									(c && (s |= 0), void 0 === l || ("[" === l && a + 2 === r))
								) {
									wc(n, void 0 === l ? new Ic(s, t, e) : new vc(s, t, e));
									break;
								}
								{
									let t = n.map[s];
									void 0 === t && ((t = new kc(s)), wc(n, t)), (n = t);
								}
							}
						}
						function Oc(t, e) {
							(this.seq = []), (this.map = {});
							const n = t.getProgramParameter(e, 35718);
							for (let i = 0; i < n; ++i) {
								const n = t.getActiveUniform(e, i);
								xc(n, t.getUniformLocation(e, n.name), this);
							}
						}
						function bc(t, e, n) {
							const i = t.createShader(e);
							return t.shaderSource(i, n), t.compileShader(i), i;
						}
						(Oc.prototype.setValue = function (t, e, n, i) {
							const r = this.map[e];
							void 0 !== r && r.setValue(t, n, i);
						}),
							(Oc.prototype.setOptional = function (t, e, n) {
								const i = e[n];
								void 0 !== i && this.setValue(t, n, i);
							}),
							(Oc.upload = function (t, e, n, i) {
								for (let r = 0, o = e.length; r !== o; ++r) {
									const o = e[r],
										a = n[o.id];
									!1 !== a.needsUpdate && o.setValue(t, a.value, i);
								}
							}),
							(Oc.seqWithValue = function (t, e) {
								const n = [];
								for (let i = 0, r = t.length; i !== r; ++i) {
									const r = t[i];
									r.id in e && n.push(r);
								}
								return n;
							});
						let Kc = 0;
						function Tc(t) {
							switch (t) {
								case hr:
									return ["Linear", "( value )"];
								case pr:
									return ["sRGB", "( value )"];
								case dr:
									return ["RGBE", "( value )"];
								case 3004:
									return ["RGBM", "( value, 7.0 )"];
								case 3005:
									return ["RGBM", "( value, 16.0 )"];
								case 3006:
									return ["RGBD", "( value, 256.0 )"];
								case ur:
									return ["Gamma", "( value, float( GAMMA_FACTOR ) )"];
								case 3003:
									return ["LogLuv", "( value )"];
								default:
									return (
										console.warn(
											"THREE.WebGLProgram: Unsupported encoding:",
											t
										),
										["Linear", "( value )"]
									);
							}
						}
						function zc(t, e, n) {
							const i = t.getShaderParameter(e, 35713),
								r = t.getShaderInfoLog(e).trim();
							return i && "" === r
								? ""
								: "THREE.WebGLShader: gl.getShaderInfoLog() " +
										n +
										"\n" +
										r +
										(function (t) {
											const e = t.split("\n");
											for (let t = 0; t < e.length; t++)
												e[t] = t + 1 + ": " + e[t];
											return e.join("\n");
										})(t.getShaderSource(e));
						}
						function Wc(t, e) {
							const n = Tc(e);
							return (
								"vec4 " +
								t +
								"( vec4 value ) { return " +
								n[0] +
								"ToLinear" +
								n[1] +
								"; }"
							);
						}
						function Ec(t, e) {
							const n = Tc(e);
							return (
								"vec4 " +
								t +
								"( vec4 value ) { return LinearTo" +
								n[0] +
								n[1] +
								"; }"
							);
						}
						function Cc(t, e) {
							let n;
							switch (e) {
								case 1:
									n = "Linear";
									break;
								case 2:
									n = "Reinhard";
									break;
								case 3:
									n = "OptimizedCineon";
									break;
								case 4:
									n = "ACESFilmic";
									break;
								case 5:
									n = "Custom";
									break;
								default:
									console.warn(
										"THREE.WebGLProgram: Unsupported toneMapping:",
										e
									),
										(n = "Linear");
							}
							return (
								"vec3 " +
								t +
								"( vec3 color ) { return " +
								n +
								"ToneMapping( color ); }"
							);
						}
						function Fc(t) {
							return "" !== t;
						}
						function Zc(t, e) {
							return t
								.replace(/NUM_DIR_LIGHTS/g, e.numDirLights)
								.replace(/NUM_SPOT_LIGHTS/g, e.numSpotLights)
								.replace(/NUM_RECT_AREA_LIGHTS/g, e.numRectAreaLights)
								.replace(/NUM_POINT_LIGHTS/g, e.numPointLights)
								.replace(/NUM_HEMI_LIGHTS/g, e.numHemiLights)
								.replace(/NUM_DIR_LIGHT_SHADOWS/g, e.numDirLightShadows)
								.replace(/NUM_SPOT_LIGHT_SHADOWS/g, e.numSpotLightShadows)
								.replace(/NUM_POINT_LIGHT_SHADOWS/g, e.numPointLightShadows);
						}
						function Hc(t, e) {
							return t
								.replace(/NUM_CLIPPING_PLANES/g, e.numClippingPlanes)
								.replace(
									/UNION_CLIPPING_PLANES/g,
									e.numClippingPlanes - e.numClipIntersection
								);
						}
						const Nc = /^[ \t]*#include +<([\w\d./]+)>/gm;
						function jc(t) {
							return t.replace(Nc, Dc);
						}
						function Dc(t, e) {
							const n = Ss[e];
							if (void 0 === n)
								throw new Error("Can not resolve #include <" + e + ">");
							return jc(n);
						}
						const Ac =
								/#pragma unroll_loop[\s]+?for \( int i \= (\d+)\; i < (\d+)\; i \+\+ \) \{([\s\S]+?)(?=\})\}/g,
							Lc =
								/#pragma unroll_loop_start[\s]+?for \( int i \= (\d+)\; i < (\d+)\; i \+\+ \) \{([\s\S]+?)(?=\})\}[\s]+?#pragma unroll_loop_end/g;
						function Bc(t) {
							return t.replace(Lc, Qc).replace(Ac, Gc);
						}
						function Gc(t, e, n, i) {
							return (
								console.warn(
									"WebGLProgram: #pragma unroll_loop shader syntax is deprecated. Please use #pragma unroll_loop_start syntax instead."
								),
								Qc(0, e, n, i)
							);
						}
						function Qc(t, e, n, i) {
							let r = "";
							for (let t = parseInt(e); t < parseInt(n); t++)
								r += i
									.replace(/\[ i \]/g, "[ " + t + " ]")
									.replace(/UNROLLED_LOOP_INDEX/g, t);
							return r;
						}
						function _c(t) {
							let e =
								"precision " +
								t.precision +
								" float;\nprecision " +
								t.precision +
								" int;";
							return (
								"highp" === t.precision
									? (e += "\n#define HIGH_PRECISION")
									: "mediump" === t.precision
									? (e += "\n#define MEDIUM_PRECISION")
									: "lowp" === t.precision && (e += "\n#define LOW_PRECISION"),
								e
							);
						}
						function Pc(t, e, n, i) {
							const r = t.getContext(),
								o = n.defines;
							let a = n.vertexShader,
								s = n.fragmentShader;
							const c = (function (t) {
									let e = "SHADOWMAP_TYPE_BASIC";
									return (
										1 === t.shadowMapType
											? (e = "SHADOWMAP_TYPE_PCF")
											: 2 === t.shadowMapType
											? (e = "SHADOWMAP_TYPE_PCF_SOFT")
											: 3 === t.shadowMapType && (e = "SHADOWMAP_TYPE_VSM"),
										e
									);
								})(n),
								l = (function (t) {
									let e = "ENVMAP_TYPE_CUBE";
									if (t.envMap)
										switch (t.envMapMode) {
											case 301:
											case 302:
												e = "ENVMAP_TYPE_CUBE";
												break;
											case Fi:
											case Zi:
												e = "ENVMAP_TYPE_CUBE_UV";
												break;
											case 303:
											case 304:
												e = "ENVMAP_TYPE_EQUIREC";
										}
									return e;
								})(n),
								h = (function (t) {
									let e = "ENVMAP_MODE_REFLECTION";
									if (t.envMap)
										switch (t.envMapMode) {
											case 302:
											case 304:
											case Zi:
												e = "ENVMAP_MODE_REFRACTION";
										}
									return e;
								})(n),
								p = (function (t) {
									let e = "ENVMAP_BLENDING_NONE";
									if (t.envMap)
										switch (t.combine) {
											case 0:
												e = "ENVMAP_BLENDING_MULTIPLY";
												break;
											case 1:
												e = "ENVMAP_BLENDING_MIX";
												break;
											case 2:
												e = "ENVMAP_BLENDING_ADD";
										}
									return e;
								})(n),
								u = t.gammaFactor > 0 ? t.gammaFactor : 1,
								d = n.isWebGL2
									? ""
									: (function (t) {
											return [
												t.extensionDerivatives ||
												t.envMapCubeUV ||
												t.bumpMap ||
												t.tangentSpaceNormalMap ||
												t.clearcoatNormalMap ||
												t.flatShading ||
												"physical" === t.shaderID
													? "#extension GL_OES_standard_derivatives : enable"
													: "",
												(t.extensionFragDepth || t.logarithmicDepthBuffer) &&
												t.rendererExtensionFragDepth
													? "#extension GL_EXT_frag_depth : enable"
													: "",
												t.extensionDrawBuffers && t.rendererExtensionDrawBuffers
													? "#extension GL_EXT_draw_buffers : require"
													: "",
												(t.extensionShaderTextureLOD || t.envMap) &&
												t.rendererExtensionShaderTextureLod
													? "#extension GL_EXT_shader_texture_lod : enable"
													: "",
											]
												.filter(Fc)
												.join("\n");
									  })(n),
								m = (function (t) {
									const e = [];
									for (const n in t) {
										const i = t[n];
										!1 !== i && e.push("#define " + n + " " + i);
									}
									return e.join("\n");
								})(o),
								f = r.createProgram();
							let g, S;
							n.isRawShaderMaterial
								? ((g = [m].filter(Fc).join("\n")),
								  g.length > 0 && (g += "\n"),
								  (S = [d, m].filter(Fc).join("\n")),
								  S.length > 0 && (S += "\n"))
								: ((g = [
										_c(n),
										"#define SHADER_NAME " + n.shaderName,
										m,
										n.instancing ? "#define USE_INSTANCING" : "",
										n.supportsVertexTextures ? "#define VERTEX_TEXTURES" : "",
										"#define GAMMA_FACTOR " + u,
										"#define MAX_BONES " + n.maxBones,
										n.useFog && n.fog ? "#define USE_FOG" : "",
										n.useFog && n.fogExp2 ? "#define FOG_EXP2" : "",
										n.map ? "#define USE_MAP" : "",
										n.envMap ? "#define USE_ENVMAP" : "",
										n.envMap ? "#define " + h : "",
										n.lightMap ? "#define USE_LIGHTMAP" : "",
										n.aoMap ? "#define USE_AOMAP" : "",
										n.emissiveMap ? "#define USE_EMISSIVEMAP" : "",
										n.bumpMap ? "#define USE_BUMPMAP" : "",
										n.normalMap ? "#define USE_NORMALMAP" : "",
										n.normalMap && n.objectSpaceNormalMap
											? "#define OBJECTSPACE_NORMALMAP"
											: "",
										n.normalMap && n.tangentSpaceNormalMap
											? "#define TANGENTSPACE_NORMALMAP"
											: "",
										n.clearcoatMap ? "#define USE_CLEARCOATMAP" : "",
										n.clearcoatRoughnessMap
											? "#define USE_CLEARCOAT_ROUGHNESSMAP"
											: "",
										n.clearcoatNormalMap
											? "#define USE_CLEARCOAT_NORMALMAP"
											: "",
										n.displacementMap && n.supportsVertexTextures
											? "#define USE_DISPLACEMENTMAP"
											: "",
										n.specularMap ? "#define USE_SPECULARMAP" : "",
										n.roughnessMap ? "#define USE_ROUGHNESSMAP" : "",
										n.metalnessMap ? "#define USE_METALNESSMAP" : "",
										n.alphaMap ? "#define USE_ALPHAMAP" : "",
										n.transmissionMap ? "#define USE_TRANSMISSIONMAP" : "",
										n.vertexTangents ? "#define USE_TANGENT" : "",
										n.vertexColors ? "#define USE_COLOR" : "",
										n.vertexUvs ? "#define USE_UV" : "",
										n.uvsVertexOnly ? "#define UVS_VERTEX_ONLY" : "",
										n.flatShading ? "#define FLAT_SHADED" : "",
										n.skinning ? "#define USE_SKINNING" : "",
										n.useVertexTexture ? "#define BONE_TEXTURE" : "",
										n.morphTargets ? "#define USE_MORPHTARGETS" : "",
										n.morphNormals && !1 === n.flatShading
											? "#define USE_MORPHNORMALS"
											: "",
										n.doubleSided ? "#define DOUBLE_SIDED" : "",
										n.flipSided ? "#define FLIP_SIDED" : "",
										n.shadowMapEnabled ? "#define USE_SHADOWMAP" : "",
										n.shadowMapEnabled ? "#define " + c : "",
										n.sizeAttenuation ? "#define USE_SIZEATTENUATION" : "",
										n.logarithmicDepthBuffer ? "#define USE_LOGDEPTHBUF" : "",
										n.logarithmicDepthBuffer && n.rendererExtensionFragDepth
											? "#define USE_LOGDEPTHBUF_EXT"
											: "",
										"uniform mat4 modelMatrix;",
										"uniform mat4 modelViewMatrix;",
										"uniform mat4 projectionMatrix;",
										"uniform mat4 viewMatrix;",
										"uniform mat3 normalMatrix;",
										"uniform vec3 cameraPosition;",
										"uniform bool isOrthographic;",
										"#ifdef USE_INSTANCING",
										" attribute mat4 instanceMatrix;",
										"#endif",
										"attribute vec3 position;",
										"attribute vec3 normal;",
										"attribute vec2 uv;",
										"#ifdef USE_TANGENT",
										"\tattribute vec4 tangent;",
										"#endif",
										"#ifdef USE_COLOR",
										"\tattribute vec3 color;",
										"#endif",
										"#ifdef USE_MORPHTARGETS",
										"\tattribute vec3 morphTarget0;",
										"\tattribute vec3 morphTarget1;",
										"\tattribute vec3 morphTarget2;",
										"\tattribute vec3 morphTarget3;",
										"\t#ifdef USE_MORPHNORMALS",
										"\t\tattribute vec3 morphNormal0;",
										"\t\tattribute vec3 morphNormal1;",
										"\t\tattribute vec3 morphNormal2;",
										"\t\tattribute vec3 morphNormal3;",
										"\t#else",
										"\t\tattribute vec3 morphTarget4;",
										"\t\tattribute vec3 morphTarget5;",
										"\t\tattribute vec3 morphTarget6;",
										"\t\tattribute vec3 morphTarget7;",
										"\t#endif",
										"#endif",
										"#ifdef USE_SKINNING",
										"\tattribute vec4 skinIndex;",
										"\tattribute vec4 skinWeight;",
										"#endif",
										"\n",
								  ]
										.filter(Fc)
										.join("\n")),
								  (S = [
										d,
										_c(n),
										"#define SHADER_NAME " + n.shaderName,
										m,
										n.alphaTest
											? "#define ALPHATEST " +
											  n.alphaTest +
											  (n.alphaTest % 1 ? "" : ".0")
											: "",
										"#define GAMMA_FACTOR " + u,
										n.useFog && n.fog ? "#define USE_FOG" : "",
										n.useFog && n.fogExp2 ? "#define FOG_EXP2" : "",
										n.map ? "#define USE_MAP" : "",
										n.matcap ? "#define USE_MATCAP" : "",
										n.envMap ? "#define USE_ENVMAP" : "",
										n.envMap ? "#define " + l : "",
										n.envMap ? "#define " + h : "",
										n.envMap ? "#define " + p : "",
										n.lightMap ? "#define USE_LIGHTMAP" : "",
										n.aoMap ? "#define USE_AOMAP" : "",
										n.emissiveMap ? "#define USE_EMISSIVEMAP" : "",
										n.bumpMap ? "#define USE_BUMPMAP" : "",
										n.normalMap ? "#define USE_NORMALMAP" : "",
										n.normalMap && n.objectSpaceNormalMap
											? "#define OBJECTSPACE_NORMALMAP"
											: "",
										n.normalMap && n.tangentSpaceNormalMap
											? "#define TANGENTSPACE_NORMALMAP"
											: "",
										n.clearcoatMap ? "#define USE_CLEARCOATMAP" : "",
										n.clearcoatRoughnessMap
											? "#define USE_CLEARCOAT_ROUGHNESSMAP"
											: "",
										n.clearcoatNormalMap
											? "#define USE_CLEARCOAT_NORMALMAP"
											: "",
										n.specularMap ? "#define USE_SPECULARMAP" : "",
										n.roughnessMap ? "#define USE_ROUGHNESSMAP" : "",
										n.metalnessMap ? "#define USE_METALNESSMAP" : "",
										n.alphaMap ? "#define USE_ALPHAMAP" : "",
										n.sheen ? "#define USE_SHEEN" : "",
										n.transmissionMap ? "#define USE_TRANSMISSIONMAP" : "",
										n.vertexTangents ? "#define USE_TANGENT" : "",
										n.vertexColors ? "#define USE_COLOR" : "",
										n.vertexUvs ? "#define USE_UV" : "",
										n.uvsVertexOnly ? "#define UVS_VERTEX_ONLY" : "",
										n.gradientMap ? "#define USE_GRADIENTMAP" : "",
										n.flatShading ? "#define FLAT_SHADED" : "",
										n.doubleSided ? "#define DOUBLE_SIDED" : "",
										n.flipSided ? "#define FLIP_SIDED" : "",
										n.shadowMapEnabled ? "#define USE_SHADOWMAP" : "",
										n.shadowMapEnabled ? "#define " + c : "",
										n.premultipliedAlpha ? "#define PREMULTIPLIED_ALPHA" : "",
										n.physicallyCorrectLights
											? "#define PHYSICALLY_CORRECT_LIGHTS"
											: "",
										n.logarithmicDepthBuffer ? "#define USE_LOGDEPTHBUF" : "",
										n.logarithmicDepthBuffer && n.rendererExtensionFragDepth
											? "#define USE_LOGDEPTHBUF_EXT"
											: "",
										(n.extensionShaderTextureLOD || n.envMap) &&
										n.rendererExtensionShaderTextureLod
											? "#define TEXTURE_LOD_EXT"
											: "",
										"uniform mat4 viewMatrix;",
										"uniform vec3 cameraPosition;",
										"uniform bool isOrthographic;",
										0 !== n.toneMapping ? "#define TONE_MAPPING" : "",
										0 !== n.toneMapping ? Ss.tonemapping_pars_fragment : "",
										0 !== n.toneMapping ? Cc("toneMapping", n.toneMapping) : "",
										n.dithering ? "#define DITHERING" : "",
										Ss.encodings_pars_fragment,
										n.map ? Wc("mapTexelToLinear", n.mapEncoding) : "",
										n.matcap ? Wc("matcapTexelToLinear", n.matcapEncoding) : "",
										n.envMap ? Wc("envMapTexelToLinear", n.envMapEncoding) : "",
										n.emissiveMap
											? Wc("emissiveMapTexelToLinear", n.emissiveMapEncoding)
											: "",
										n.lightMap
											? Wc("lightMapTexelToLinear", n.lightMapEncoding)
											: "",
										Ec("linearToOutputTexel", n.outputEncoding),
										n.depthPacking
											? "#define DEPTH_PACKING " + n.depthPacking
											: "",
										"\n",
								  ]
										.filter(Fc)
										.join("\n"))),
								(a = jc(a)),
								(a = Zc(a, n)),
								(a = Hc(a, n)),
								(s = jc(s)),
								(s = Zc(s, n)),
								(s = Hc(s, n)),
								(a = Bc(a)),
								(s = Bc(s)),
								n.isWebGL2 &&
									!n.isRawShaderMaterial &&
									((g =
										[
											"#version 300 es\n",
											"#define attribute in",
											"#define varying out",
											"#define texture2D texture",
										].join("\n") +
										"\n" +
										g),
									(S =
										[
											"#version 300 es\n",
											"#define varying in",
											"out highp vec4 pc_fragColor;",
											"#define gl_FragColor pc_fragColor",
											"#define gl_FragDepthEXT gl_FragDepth",
											"#define texture2D texture",
											"#define textureCube texture",
											"#define texture2DProj textureProj",
											"#define texture2DLodEXT textureLod",
											"#define texture2DProjLodEXT textureProjLod",
											"#define textureCubeLodEXT textureLod",
											"#define texture2DGradEXT textureGrad",
											"#define texture2DProjGradEXT textureProjGrad",
											"#define textureCubeGradEXT textureGrad",
										].join("\n") +
										"\n" +
										S));
							const y = S + s,
								V = bc(r, 35633, g + a),
								q = bc(r, 35632, y);
							if (
								(r.attachShader(f, V),
								r.attachShader(f, q),
								void 0 !== n.index0AttributeName
									? r.bindAttribLocation(f, 0, n.index0AttributeName)
									: !0 === n.morphTargets &&
									  r.bindAttribLocation(f, 0, "position"),
								r.linkProgram(f),
								t.debug.checkShaderErrors)
							) {
								const t = r.getProgramInfoLog(f).trim(),
									e = r.getShaderInfoLog(V).trim(),
									n = r.getShaderInfoLog(q).trim();
								let i = !0,
									o = !0;
								if (!1 === r.getProgramParameter(f, 35714)) {
									i = !1;
									const e = zc(r, V, "vertex"),
										n = zc(r, q, "fragment");
									console.error(
										"THREE.WebGLProgram: shader error: ",
										r.getError(),
										"35715",
										r.getProgramParameter(f, 35715),
										"gl.getProgramInfoLog",
										t,
										e,
										n
									);
								} else
									"" !== t
										? console.warn(
												"THREE.WebGLProgram: gl.getProgramInfoLog()",
												t
										  )
										: ("" !== e && "" !== n) || (o = !1);
								o &&
									(this.diagnostics = {
										runnable: i,
										programLog: t,
										vertexShader: { log: e, prefix: g },
										fragmentShader: { log: n, prefix: S },
									});
							}
							let R, M;
							return (
								r.deleteShader(V),
								r.deleteShader(q),
								(this.getUniforms = function () {
									return void 0 === R && (R = new Oc(r, f)), R;
								}),
								(this.getAttributes = function () {
									return (
										void 0 === M &&
											(M = (function (t, e) {
												const n = {},
													i = t.getProgramParameter(e, 35721);
												for (let r = 0; r < i; r++) {
													const i = t.getActiveAttrib(e, r).name;
													n[i] = t.getAttribLocation(e, i);
												}
												return n;
											})(r, f)),
										M
									);
								}),
								(this.destroy = function () {
									i.releaseStatesOfProgram(this),
										r.deleteProgram(f),
										(this.program = void 0);
								}),
								(this.name = n.shaderName),
								(this.id = Kc++),
								(this.cacheKey = e),
								(this.usedTimes = 1),
								(this.program = f),
								(this.vertexShader = V),
								(this.fragmentShader = q),
								this
							);
						}
						function Jc(t, e, n, i) {
							const r = [],
								o = n.isWebGL2,
								a = n.logarithmicDepthBuffer,
								s = n.floatVertexTextures,
								c = n.maxVertexUniforms,
								l = n.vertexTextures;
							let h = n.precision;
							const p = {
									MeshDepthMaterial: "depth",
									MeshDistanceMaterial: "distanceRGBA",
									MeshNormalMaterial: "normal",
									MeshBasicMaterial: "basic",
									MeshLambertMaterial: "lambert",
									MeshPhongMaterial: "phong",
									MeshToonMaterial: "toon",
									MeshStandardMaterial: "physical",
									MeshPhysicalMaterial: "physical",
									MeshMatcapMaterial: "matcap",
									LineBasicMaterial: "basic",
									LineDashedMaterial: "dashed",
									PointsMaterial: "points",
									ShadowMaterial: "shadow",
									SpriteMaterial: "sprite",
								},
								u = [
									"precision",
									"isWebGL2",
									"supportsVertexTextures",
									"outputEncoding",
									"instancing",
									"map",
									"mapEncoding",
									"matcap",
									"matcapEncoding",
									"envMap",
									"envMapMode",
									"envMapEncoding",
									"envMapCubeUV",
									"lightMap",
									"lightMapEncoding",
									"aoMap",
									"emissiveMap",
									"emissiveMapEncoding",
									"bumpMap",
									"normalMap",
									"objectSpaceNormalMap",
									"tangentSpaceNormalMap",
									"clearcoatMap",
									"clearcoatRoughnessMap",
									"clearcoatNormalMap",
									"displacementMap",
									"specularMap",
									"roughnessMap",
									"metalnessMap",
									"gradientMap",
									"alphaMap",
									"combine",
									"vertexColors",
									"vertexTangents",
									"vertexUvs",
									"uvsVertexOnly",
									"fog",
									"useFog",
									"fogExp2",
									"flatShading",
									"sizeAttenuation",
									"logarithmicDepthBuffer",
									"skinning",
									"maxBones",
									"useVertexTexture",
									"morphTargets",
									"morphNormals",
									"maxMorphTargets",
									"maxMorphNormals",
									"premultipliedAlpha",
									"numDirLights",
									"numPointLights",
									"numSpotLights",
									"numHemiLights",
									"numRectAreaLights",
									"numDirLightShadows",
									"numPointLightShadows",
									"numSpotLightShadows",
									"shadowMapEnabled",
									"shadowMapType",
									"toneMapping",
									"physicallyCorrectLights",
									"alphaTest",
									"doubleSided",
									"flipSided",
									"numClippingPlanes",
									"numClipIntersection",
									"depthPacking",
									"dithering",
									"sheen",
									"transmissionMap",
								];
							function d(t) {
								let e;
								return (
									t
										? t.isTexture
											? (e = t.encoding)
											: t.isWebGLRenderTarget &&
											  (console.warn(
													"THREE.WebGLPrograms.getTextureEncodingFromMap: don't use render targets as textures. Use their .texture property instead."
											  ),
											  (e = t.texture.encoding))
										: (e = hr),
									e
								);
							}
							return {
								getParameters: function (i, r, u, m, f, g, S) {
									const y = m.fog,
										V = i.isMeshStandardMaterial ? m.environment : null,
										q = i.envMap || V,
										R = p[i.type],
										M = S.isSkinnedMesh
											? (function (t) {
													const e = t.skeleton.bones;
													if (s) return 1024;
													{
														const t = c,
															n = Math.floor((t - 20) / 4),
															i = Math.min(n, e.length);
														return i < e.length
															? (console.warn(
																	"THREE.WebGLRenderer: Skeleton has " +
																		e.length +
																		" bones. This GPU supports " +
																		i +
																		"."
															  ),
															  0)
															: i;
													}
											  })(S)
											: 0;
									let I, v;
									if (
										(null !== i.precision &&
											((h = n.getMaxPrecision(i.precision)),
											h !== i.precision &&
												console.warn(
													"THREE.WebGLProgram.getParameters:",
													i.precision,
													"not supported, using",
													h,
													"instead."
												)),
										R)
									) {
										const t = ys[R];
										(I = t.vertexShader), (v = t.fragmentShader);
									} else (I = i.vertexShader), (v = i.fragmentShader);
									const k = t.getRenderTarget();
									return {
										isWebGL2: o,
										shaderID: R,
										shaderName: i.type,
										vertexShader: I,
										fragmentShader: v,
										defines: i.defines,
										isRawShaderMaterial: i.isRawShaderMaterial,
										isShaderMaterial: i.isShaderMaterial,
										precision: h,
										instancing: !0 === S.isInstancedMesh,
										supportsVertexTextures: l,
										outputEncoding:
											null !== k ? d(k.texture) : t.outputEncoding,
										map: !!i.map,
										mapEncoding: d(i.map),
										matcap: !!i.matcap,
										matcapEncoding: d(i.matcap),
										envMap: !!q,
										envMapMode: q && q.mapping,
										envMapEncoding: d(q),
										envMapCubeUV: !!q && (q.mapping === Fi || q.mapping === Zi),
										lightMap: !!i.lightMap,
										lightMapEncoding: d(i.lightMap),
										aoMap: !!i.aoMap,
										emissiveMap: !!i.emissiveMap,
										emissiveMapEncoding: d(i.emissiveMap),
										bumpMap: !!i.bumpMap,
										normalMap: !!i.normalMap,
										objectSpaceNormalMap: 1 === i.normalMapType,
										tangentSpaceNormalMap: 0 === i.normalMapType,
										clearcoatMap: !!i.clearcoatMap,
										clearcoatRoughnessMap: !!i.clearcoatRoughnessMap,
										clearcoatNormalMap: !!i.clearcoatNormalMap,
										displacementMap: !!i.displacementMap,
										roughnessMap: !!i.roughnessMap,
										metalnessMap: !!i.metalnessMap,
										specularMap: !!i.specularMap,
										alphaMap: !!i.alphaMap,
										gradientMap: !!i.gradientMap,
										sheen: !!i.sheen,
										transmissionMap: !!i.transmissionMap,
										combine: i.combine,
										vertexTangents: i.normalMap && i.vertexTangents,
										vertexColors: i.vertexColors,
										vertexUvs: !!(
											i.map ||
											i.bumpMap ||
											i.normalMap ||
											i.specularMap ||
											i.alphaMap ||
											i.emissiveMap ||
											i.roughnessMap ||
											i.metalnessMap ||
											i.clearcoatMap ||
											i.clearcoatRoughnessMap ||
											i.clearcoatNormalMap ||
											i.displacementMap ||
											i.transmissionMap
										),
										uvsVertexOnly: !(
											i.map ||
											i.bumpMap ||
											i.normalMap ||
											i.specularMap ||
											i.alphaMap ||
											i.emissiveMap ||
											i.roughnessMap ||
											i.metalnessMap ||
											i.clearcoatNormalMap ||
											i.transmissionMap ||
											!i.displacementMap
										),
										fog: !!y,
										useFog: i.fog,
										fogExp2: y && y.isFogExp2,
										flatShading: i.flatShading,
										sizeAttenuation: i.sizeAttenuation,
										logarithmicDepthBuffer: a,
										skinning: i.skinning && M > 0,
										maxBones: M,
										useVertexTexture: s,
										morphTargets: i.morphTargets,
										morphNormals: i.morphNormals,
										maxMorphTargets: t.maxMorphTargets,
										maxMorphNormals: t.maxMorphNormals,
										numDirLights: r.directional.length,
										numPointLights: r.point.length,
										numSpotLights: r.spot.length,
										numRectAreaLights: r.rectArea.length,
										numHemiLights: r.hemi.length,
										numDirLightShadows: r.directionalShadowMap.length,
										numPointLightShadows: r.pointShadowMap.length,
										numSpotLightShadows: r.spotShadowMap.length,
										numClippingPlanes: f,
										numClipIntersection: g,
										dithering: i.dithering,
										shadowMapEnabled: t.shadowMap.enabled && u.length > 0,
										shadowMapType: t.shadowMap.type,
										toneMapping: i.toneMapped ? t.toneMapping : 0,
										physicallyCorrectLights: t.physicallyCorrectLights,
										premultipliedAlpha: i.premultipliedAlpha,
										alphaTest: i.alphaTest,
										doubleSided: 2 === i.side,
										flipSided: 1 === i.side,
										depthPacking: void 0 !== i.depthPacking && i.depthPacking,
										index0AttributeName: i.index0AttributeName,
										extensionDerivatives:
											i.extensions && i.extensions.derivatives,
										extensionFragDepth: i.extensions && i.extensions.fragDepth,
										extensionDrawBuffers:
											i.extensions && i.extensions.drawBuffers,
										extensionShaderTextureLOD:
											i.extensions && i.extensions.shaderTextureLOD,
										rendererExtensionFragDepth:
											o || null !== e.get("EXT_frag_depth"),
										rendererExtensionDrawBuffers:
											o || null !== e.get("WEBGL_draw_buffers"),
										rendererExtensionShaderTextureLod:
											o || null !== e.get("EXT_shader_texture_lod"),
										customProgramCacheKey: i.customProgramCacheKey(),
									};
								},
								getProgramCacheKey: function (e) {
									const n = [];
									if (
										(e.shaderID
											? n.push(e.shaderID)
											: (n.push(e.fragmentShader), n.push(e.vertexShader)),
										void 0 !== e.defines)
									)
										for (const t in e.defines) n.push(t), n.push(e.defines[t]);
									if (void 0 === e.isRawShaderMaterial) {
										for (let t = 0; t < u.length; t++) n.push(e[u[t]]);
										n.push(t.outputEncoding), n.push(t.gammaFactor);
									}
									return n.push(e.customProgramCacheKey), n.join();
								},
								getUniforms: function (t) {
									const e = p[t.type];
									let n;
									if (e) {
										const t = ys[e];
										n = es.clone(t.uniforms);
									} else n = t.uniforms;
									return n;
								},
								acquireProgram: function (e, n) {
									let o;
									for (let t = 0, e = r.length; t < e; t++) {
										const e = r[t];
										if (e.cacheKey === n) {
											(o = e), ++o.usedTimes;
											break;
										}
									}
									return (
										void 0 === o && ((o = new Pc(t, n, e, i)), r.push(o)), o
									);
								},
								releaseProgram: function (t) {
									if (0 == --t.usedTimes) {
										const e = r.indexOf(t);
										(r[e] = r[r.length - 1]), r.pop(), t.destroy();
									}
								},
								programs: r,
							};
						}
						function Yc() {
							let t = new WeakMap();
							return {
								get: function (e) {
									let n = t.get(e);
									return void 0 === n && ((n = {}), t.set(e, n)), n;
								},
								remove: function (e) {
									t.delete(e);
								},
								update: function (e, n, i) {
									t.get(e)[n] = i;
								},
								dispose: function () {
									t = new WeakMap();
								},
							};
						}
						function Xc(t, e) {
							return t.groupOrder !== e.groupOrder
								? t.groupOrder - e.groupOrder
								: t.renderOrder !== e.renderOrder
								? t.renderOrder - e.renderOrder
								: t.program !== e.program
								? t.program.id - e.program.id
								: t.material.id !== e.material.id
								? t.material.id - e.material.id
								: t.z !== e.z
								? t.z - e.z
								: t.id - e.id;
						}
						function $c(t, e) {
							return t.groupOrder !== e.groupOrder
								? t.groupOrder - e.groupOrder
								: t.renderOrder !== e.renderOrder
								? t.renderOrder - e.renderOrder
								: t.z !== e.z
								? e.z - t.z
								: t.id - e.id;
						}
						function tl(t) {
							const e = [];
							let n = 0;
							const i = [],
								r = [],
								o = { id: -1 };
							function a(i, r, a, s, c, l) {
								let h = e[n];
								const p = t.get(a);
								return (
									void 0 === h
										? ((h = {
												id: i.id,
												object: i,
												geometry: r,
												material: a,
												program: p.program || o,
												groupOrder: s,
												renderOrder: i.renderOrder,
												z: c,
												group: l,
										  }),
										  (e[n] = h))
										: ((h.id = i.id),
										  (h.object = i),
										  (h.geometry = r),
										  (h.material = a),
										  (h.program = p.program || o),
										  (h.groupOrder = s),
										  (h.renderOrder = i.renderOrder),
										  (h.z = c),
										  (h.group = l)),
									n++,
									h
								);
							}
							return {
								opaque: i,
								transparent: r,
								init: function () {
									(n = 0), (i.length = 0), (r.length = 0);
								},
								push: function (t, e, n, o, s, c) {
									const l = a(t, e, n, o, s, c);
									(!0 === n.transparent ? r : i).push(l);
								},
								unshift: function (t, e, n, o, s, c) {
									const l = a(t, e, n, o, s, c);
									(!0 === n.transparent ? r : i).unshift(l);
								},
								finish: function () {
									for (let t = n, i = e.length; t < i; t++) {
										const n = e[t];
										if (null === n.id) break;
										(n.id = null),
											(n.object = null),
											(n.geometry = null),
											(n.material = null),
											(n.program = null),
											(n.group = null);
									}
								},
								sort: function (t, e) {
									i.length > 1 && i.sort(t || Xc),
										r.length > 1 && r.sort(e || $c);
								},
							};
						}
						function el(t) {
							let e = new WeakMap();
							function n(t) {
								const i = t.target;
								i.removeEventListener("dispose", n), e.delete(i);
							}
							return {
								get: function (i, r) {
									const o = e.get(i);
									let a;
									return (
										void 0 === o
											? ((a = new tl(t)),
											  e.set(i, new WeakMap()),
											  e.get(i).set(r, a),
											  i.addEventListener("dispose", n))
											: ((a = o.get(r)),
											  void 0 === a && ((a = new tl(t)), o.set(r, a))),
										a
									);
								},
								dispose: function () {
									e = new WeakMap();
								},
							};
						}
						function nl() {
							const t = {};
							return {
								get: function (e) {
									if (void 0 !== t[e.id]) return t[e.id];
									let n;
									switch (e.type) {
										case "DirectionalLight":
											n = { direction: new zr(), color: new Yo() };
											break;
										case "SpotLight":
											n = {
												position: new zr(),
												direction: new zr(),
												color: new Yo(),
												distance: 0,
												coneCos: 0,
												penumbraCos: 0,
												decay: 0,
											};
											break;
										case "PointLight":
											n = {
												position: new zr(),
												color: new Yo(),
												distance: 0,
												decay: 0,
											};
											break;
										case "HemisphereLight":
											n = {
												direction: new zr(),
												skyColor: new Yo(),
												groundColor: new Yo(),
											};
											break;
										case "RectAreaLight":
											n = {
												color: new Yo(),
												position: new zr(),
												halfWidth: new zr(),
												halfHeight: new zr(),
											};
									}
									return (t[e.id] = n), n;
								},
							};
						}
						let il = 0;
						function rl(t, e) {
							return (e.castShadow ? 1 : 0) - (t.castShadow ? 1 : 0);
						}
						function ol() {
							const t = new nl(),
								e = (function () {
									const t = {};
									return {
										get: function (e) {
											if (void 0 !== t[e.id]) return t[e.id];
											let n;
											switch (e.type) {
												case "DirectionalLight":
												case "SpotLight":
													n = {
														shadowBias: 0,
														shadowNormalBias: 0,
														shadowRadius: 1,
														shadowMapSize: new Rr(),
													};
													break;
												case "PointLight":
													n = {
														shadowBias: 0,
														shadowNormalBias: 0,
														shadowRadius: 1,
														shadowMapSize: new Rr(),
														shadowCameraNear: 1,
														shadowCameraFar: 1e3,
													};
											}
											return (t[e.id] = n), n;
										},
									};
								})(),
								n = {
									version: 0,
									hash: {
										directionalLength: -1,
										pointLength: -1,
										spotLength: -1,
										rectAreaLength: -1,
										hemiLength: -1,
										numDirectionalShadows: -1,
										numPointShadows: -1,
										numSpotShadows: -1,
									},
									ambient: [0, 0, 0],
									probe: [],
									directional: [],
									directionalShadow: [],
									directionalShadowMap: [],
									directionalShadowMatrix: [],
									spot: [],
									spotShadow: [],
									spotShadowMap: [],
									spotShadowMatrix: [],
									rectArea: [],
									point: [],
									pointShadow: [],
									pointShadowMap: [],
									pointShadowMatrix: [],
									hemi: [],
								};
							for (let t = 0; t < 9; t++) n.probe.push(new zr());
							const i = new zr(),
								r = new jr(),
								o = new jr();
							return {
								setup: function (a, s, c) {
									let l = 0,
										h = 0,
										p = 0;
									for (let t = 0; t < 9; t++) n.probe[t].set(0, 0, 0);
									let u = 0,
										d = 0,
										m = 0,
										f = 0,
										g = 0,
										S = 0,
										y = 0,
										V = 0;
									const q = c.matrixWorldInverse;
									a.sort(rl);
									for (let s = 0, c = a.length; s < c; s++) {
										const c = a[s],
											R = c.color,
											M = c.intensity,
											I = c.distance,
											v =
												c.shadow && c.shadow.map ? c.shadow.map.texture : null;
										if (c.isAmbientLight)
											(l += R.r * M), (h += R.g * M), (p += R.b * M);
										else if (c.isLightProbe)
											for (let t = 0; t < 9; t++)
												n.probe[t].addScaledVector(c.sh.coefficients[t], M);
										else if (c.isDirectionalLight) {
											const r = t.get(c);
											if (
												(r.color.copy(c.color).multiplyScalar(c.intensity),
												r.direction.setFromMatrixPosition(c.matrixWorld),
												i.setFromMatrixPosition(c.target.matrixWorld),
												r.direction.sub(i),
												r.direction.transformDirection(q),
												c.castShadow)
											) {
												const t = c.shadow,
													i = e.get(c);
												(i.shadowBias = t.bias),
													(i.shadowNormalBias = t.normalBias),
													(i.shadowRadius = t.radius),
													(i.shadowMapSize = t.mapSize),
													(n.directionalShadow[u] = i),
													(n.directionalShadowMap[u] = v),
													(n.directionalShadowMatrix[u] = c.shadow.matrix),
													S++;
											}
											(n.directional[u] = r), u++;
										} else if (c.isSpotLight) {
											const r = t.get(c);
											if (
												(r.position.setFromMatrixPosition(c.matrixWorld),
												r.position.applyMatrix4(q),
												r.color.copy(R).multiplyScalar(M),
												(r.distance = I),
												r.direction.setFromMatrixPosition(c.matrixWorld),
												i.setFromMatrixPosition(c.target.matrixWorld),
												r.direction.sub(i),
												r.direction.transformDirection(q),
												(r.coneCos = Math.cos(c.angle)),
												(r.penumbraCos = Math.cos(c.angle * (1 - c.penumbra))),
												(r.decay = c.decay),
												c.castShadow)
											) {
												const t = c.shadow,
													i = e.get(c);
												(i.shadowBias = t.bias),
													(i.shadowNormalBias = t.normalBias),
													(i.shadowRadius = t.radius),
													(i.shadowMapSize = t.mapSize),
													(n.spotShadow[m] = i),
													(n.spotShadowMap[m] = v),
													(n.spotShadowMatrix[m] = c.shadow.matrix),
													V++;
											}
											(n.spot[m] = r), m++;
										} else if (c.isRectAreaLight) {
											const e = t.get(c);
											e.color.copy(R).multiplyScalar(M),
												e.position.setFromMatrixPosition(c.matrixWorld),
												e.position.applyMatrix4(q),
												o.identity(),
												r.copy(c.matrixWorld),
												r.premultiply(q),
												o.extractRotation(r),
												e.halfWidth.set(0.5 * c.width, 0, 0),
												e.halfHeight.set(0, 0.5 * c.height, 0),
												e.halfWidth.applyMatrix4(o),
												e.halfHeight.applyMatrix4(o),
												(n.rectArea[f] = e),
												f++;
										} else if (c.isPointLight) {
											const i = t.get(c);
											if (
												(i.position.setFromMatrixPosition(c.matrixWorld),
												i.position.applyMatrix4(q),
												i.color.copy(c.color).multiplyScalar(c.intensity),
												(i.distance = c.distance),
												(i.decay = c.decay),
												c.castShadow)
											) {
												const t = c.shadow,
													i = e.get(c);
												(i.shadowBias = t.bias),
													(i.shadowNormalBias = t.normalBias),
													(i.shadowRadius = t.radius),
													(i.shadowMapSize = t.mapSize),
													(i.shadowCameraNear = t.camera.near),
													(i.shadowCameraFar = t.camera.far),
													(n.pointShadow[d] = i),
													(n.pointShadowMap[d] = v),
													(n.pointShadowMatrix[d] = c.shadow.matrix),
													y++;
											}
											(n.point[d] = i), d++;
										} else if (c.isHemisphereLight) {
											const e = t.get(c);
											e.direction.setFromMatrixPosition(c.matrixWorld),
												e.direction.transformDirection(q),
												e.direction.normalize(),
												e.skyColor.copy(c.color).multiplyScalar(M),
												e.groundColor.copy(c.groundColor).multiplyScalar(M),
												(n.hemi[g] = e),
												g++;
										}
									}
									(n.ambient[0] = l), (n.ambient[1] = h), (n.ambient[2] = p);
									const R = n.hash;
									(R.directionalLength === u &&
										R.pointLength === d &&
										R.spotLength === m &&
										R.rectAreaLength === f &&
										R.hemiLength === g &&
										R.numDirectionalShadows === S &&
										R.numPointShadows === y &&
										R.numSpotShadows === V) ||
										((n.directional.length = u),
										(n.spot.length = m),
										(n.rectArea.length = f),
										(n.point.length = d),
										(n.hemi.length = g),
										(n.directionalShadow.length = S),
										(n.directionalShadowMap.length = S),
										(n.pointShadow.length = y),
										(n.pointShadowMap.length = y),
										(n.spotShadow.length = V),
										(n.spotShadowMap.length = V),
										(n.directionalShadowMatrix.length = S),
										(n.pointShadowMatrix.length = y),
										(n.spotShadowMatrix.length = V),
										(R.directionalLength = u),
										(R.pointLength = d),
										(R.spotLength = m),
										(R.rectAreaLength = f),
										(R.hemiLength = g),
										(R.numDirectionalShadows = S),
										(R.numPointShadows = y),
										(R.numSpotShadows = V),
										(n.version = il++));
								},
								state: n,
							};
						}
						function al() {
							const t = new ol(),
								e = [],
								n = [];
							return {
								init: function () {
									(e.length = 0), (n.length = 0);
								},
								state: { lightsArray: e, shadowsArray: n, lights: t },
								setupLights: function (i) {
									t.setup(e, n, i);
								},
								pushLight: function (t) {
									e.push(t);
								},
								pushShadow: function (t) {
									n.push(t);
								},
							};
						}
						function sl() {
							let t = new WeakMap();
							function e(n) {
								const i = n.target;
								i.removeEventListener("dispose", e), t.delete(i);
							}
							return {
								get: function (n, i) {
									let r;
									return (
										!1 === t.has(n)
											? ((r = new al()),
											  t.set(n, new WeakMap()),
											  t.get(n).set(i, r),
											  n.addEventListener("dispose", e))
											: !1 === t.get(n).has(i)
											? ((r = new al()), t.get(n).set(i, r))
											: (r = t.get(n).get(i)),
										r
									);
								},
								dispose: function () {
									t = new WeakMap();
								},
							};
						}
						function cl(t) {
							ia.call(this),
								(this.type = "MeshDepthMaterial"),
								(this.depthPacking = 3200),
								(this.skinning = !1),
								(this.morphTargets = !1),
								(this.map = null),
								(this.alphaMap = null),
								(this.displacementMap = null),
								(this.displacementScale = 1),
								(this.displacementBias = 0),
								(this.wireframe = !1),
								(this.wireframeLinewidth = 1),
								(this.fog = !1),
								this.setValues(t);
						}
						function ll(t) {
							ia.call(this),
								(this.type = "MeshDistanceMaterial"),
								(this.referencePosition = new zr()),
								(this.nearDistance = 1),
								(this.farDistance = 1e3),
								(this.skinning = !1),
								(this.morphTargets = !1),
								(this.map = null),
								(this.alphaMap = null),
								(this.displacementMap = null),
								(this.displacementScale = 1),
								(this.displacementBias = 0),
								(this.fog = !1),
								this.setValues(t);
						}
						function hl(t, e, n) {
							let i = new ps();
							const r = new Rr(),
								o = new Rr(),
								a = new wr(),
								s = [],
								c = [],
								l = {},
								h = { 0: 1, 1: 0, 2: 2 },
								p = new ns({
									defines: { SAMPLE_RATE: 2 / 8, HALF_SAMPLE_RATE: 1 / 8 },
									uniforms: {
										shadow_pass: { value: null },
										resolution: { value: new Rr() },
										radius: { value: 4 },
									},
									vertexShader:
										"void main() {\n\tgl_Position = vec4( position, 1.0 );\n}",
									fragmentShader:
										"uniform sampler2D shadow_pass;\nuniform vec2 resolution;\nuniform float radius;\n#include <packing>\nvoid main() {\n  float mean = 0.0;\n  float squared_mean = 0.0;\n\tfloat depth = unpackRGBAToDepth( texture2D( shadow_pass, ( gl_FragCoord.xy  ) / resolution ) );\n  for ( float i = -1.0; i < 1.0 ; i += SAMPLE_RATE) {\n    #ifdef HORIZONAL_PASS\n      vec2 distribution = unpackRGBATo2Half( texture2D( shadow_pass, ( gl_FragCoord.xy + vec2( i, 0.0 ) * radius ) / resolution ) );\n      mean += distribution.x;\n      squared_mean += distribution.y * distribution.y + distribution.x * distribution.x;\n    #else\n      float depth = unpackRGBAToDepth( texture2D( shadow_pass, ( gl_FragCoord.xy + vec2( 0.0,  i )  * radius ) / resolution ) );\n      mean += depth;\n      squared_mean += depth * depth;\n    #endif\n  }\n  mean = mean * HALF_SAMPLE_RATE;\n  squared_mean = squared_mean * HALF_SAMPLE_RATE;\n  float std_dev = sqrt( squared_mean - mean * mean );\n  gl_FragColor = pack2HalfToRGBA( vec2( mean, std_dev ) );\n}",
								}),
								u = p.clone();
							u.defines.HORIZONAL_PASS = 1;
							const d = new Ua();
							d.setAttribute(
								"position",
								new sa(
									new Float32Array([-1, -1, 0.5, 3, -1, 0.5, -1, 3, 0.5]),
									3
								)
							);
							const m = new La(d, p),
								f = this;
							function g(n, i) {
								const r = e.update(m);
								(p.uniforms.shadow_pass.value = n.map.texture),
									(p.uniforms.resolution.value = n.mapSize),
									(p.uniforms.radius.value = n.radius),
									t.setRenderTarget(n.mapPass),
									t.clear(),
									t.renderBufferDirect(i, null, r, p, m, null),
									(u.uniforms.shadow_pass.value = n.mapPass.texture),
									(u.uniforms.resolution.value = n.mapSize),
									(u.uniforms.radius.value = n.radius),
									t.setRenderTarget(n.map),
									t.clear(),
									t.renderBufferDirect(i, null, r, u, m, null);
							}
							function S(t, e, n) {
								const i = (t << 0) | (e << 1) | (n << 2);
								let r = s[i];
								return (
									void 0 === r &&
										((r = new cl({
											depthPacking: 3201,
											morphTargets: t,
											skinning: e,
										})),
										(s[i] = r)),
									r
								);
							}
							function y(t, e, n) {
								const i = (t << 0) | (e << 1) | (n << 2);
								let r = c[i];
								return (
									void 0 === r &&
										((r = new ll({ morphTargets: t, skinning: e })),
										(c[i] = r)),
									r
								);
							}
							function V(e, n, i, r, o, a, s) {
								let c = null,
									p = S,
									u = e.customDepthMaterial;
								if (
									(!0 === r.isPointLight &&
										((p = y), (u = e.customDistanceMaterial)),
									void 0 === u)
								) {
									let t = !1;
									!0 === i.morphTargets &&
										(t =
											n.morphAttributes &&
											n.morphAttributes.position &&
											n.morphAttributes.position.length > 0);
									let r = !1;
									!0 === e.isSkinnedMesh &&
										(!0 === i.skinning
											? (r = !0)
											: console.warn(
													"THREE.WebGLShadowMap: THREE.SkinnedMesh with material.skinning set to false:",
													e
											  )),
										(c = p(t, r, !0 === e.isInstancedMesh));
								} else c = u;
								if (
									t.localClippingEnabled &&
									!0 === i.clipShadows &&
									0 !== i.clippingPlanes.length
								) {
									const t = c.uuid,
										e = i.uuid;
									let n = l[t];
									void 0 === n && ((n = {}), (l[t] = n));
									let r = n[e];
									void 0 === r && ((r = c.clone()), (n[e] = r)), (c = r);
								}
								return (
									(c.visible = i.visible),
									(c.wireframe = i.wireframe),
									(c.side =
										3 === s
											? null !== i.shadowSide
												? i.shadowSide
												: i.side
											: null !== i.shadowSide
											? i.shadowSide
											: h[i.side]),
									(c.clipShadows = i.clipShadows),
									(c.clippingPlanes = i.clippingPlanes),
									(c.clipIntersection = i.clipIntersection),
									(c.wireframeLinewidth = i.wireframeLinewidth),
									(c.linewidth = i.linewidth),
									!0 === r.isPointLight &&
										!0 === c.isMeshDistanceMaterial &&
										(c.referencePosition.setFromMatrixPosition(r.matrixWorld),
										(c.nearDistance = o),
										(c.farDistance = a)),
									c
								);
							}
							function q(n, r, o, a, s) {
								if (!1 === n.visible) return;
								if (
									n.layers.test(r.layers) &&
									(n.isMesh || n.isLine || n.isPoints) &&
									(n.castShadow || (n.receiveShadow && 3 === s)) &&
									(!n.frustumCulled || i.intersectsObject(n))
								) {
									n.modelViewMatrix.multiplyMatrices(
										o.matrixWorldInverse,
										n.matrixWorld
									);
									const i = e.update(n),
										r = n.material;
									if (Array.isArray(r)) {
										const e = i.groups;
										for (let c = 0, l = e.length; c < l; c++) {
											const l = e[c],
												h = r[l.materialIndex];
											if (h && h.visible) {
												const e = V(n, i, h, a, o.near, o.far, s);
												t.renderBufferDirect(o, null, i, e, n, l);
											}
										}
									} else if (r.visible) {
										const e = V(n, i, r, a, o.near, o.far, s);
										t.renderBufferDirect(o, null, i, e, n, null);
									}
								}
								const c = n.children;
								for (let t = 0, e = c.length; t < e; t++) q(c[t], r, o, a, s);
							}
							(this.enabled = !1),
								(this.autoUpdate = !0),
								(this.needsUpdate = !1),
								(this.type = 1),
								(this.render = function (e, s, c) {
									if (!1 === f.enabled) return;
									if (!1 === f.autoUpdate && !1 === f.needsUpdate) return;
									if (0 === e.length) return;
									const l = t.getRenderTarget(),
										h = t.getActiveCubeFace(),
										p = t.getActiveMipmapLevel(),
										u = t.state;
									u.setBlending(0),
										u.buffers.color.setClear(1, 1, 1, 1),
										u.buffers.depth.setTest(!0),
										u.setScissorTest(!1);
									for (let l = 0, h = e.length; l < h; l++) {
										const h = e[l],
											p = h.shadow;
										if (!1 === p.autoUpdate && !1 === p.needsUpdate) continue;
										if (void 0 === p) {
											console.warn(
												"THREE.WebGLShadowMap:",
												h,
												"has no shadow."
											);
											continue;
										}
										r.copy(p.mapSize);
										const d = p.getFrameExtents();
										if (
											(r.multiply(d),
											o.copy(p.mapSize),
											(r.x > n || r.y > n) &&
												(r.x > n &&
													((o.x = Math.floor(n / d.x)),
													(r.x = o.x * d.x),
													(p.mapSize.x = o.x)),
												r.y > n &&
													((o.y = Math.floor(n / d.y)),
													(r.y = o.y * d.y),
													(p.mapSize.y = o.y))),
											null === p.map &&
												!p.isPointLightShadow &&
												3 === this.type)
										) {
											const t = {
												minFilter: Bi,
												magFilter: Bi,
												format: tr,
												stencilBuffer: !1,
											};
											(p.map = new xr(r.x, r.y, t)),
												(p.map.texture.name = h.name + ".shadowMap"),
												(p.mapPass = new xr(r.x, r.y, t)),
												p.camera.updateProjectionMatrix();
										}
										if (null === p.map) {
											const t = {
												minFilter: Di,
												magFilter: Di,
												format: tr,
												stencilBuffer: !1,
											};
											(p.map = new xr(r.x, r.y, t)),
												(p.map.texture.name = h.name + ".shadowMap"),
												p.camera.updateProjectionMatrix();
										}
										t.setRenderTarget(p.map), t.clear();
										const m = p.getViewportCount();
										for (let t = 0; t < m; t++) {
											const e = p.getViewport(t);
											a.set(o.x * e.x, o.y * e.y, o.x * e.z, o.y * e.w),
												u.viewport(a),
												p.updateMatrices(h, t),
												(i = p.getFrustum()),
												q(s, c, p.camera, h, this.type);
										}
										p.isPointLightShadow || 3 !== this.type || g(p, c),
											(p.needsUpdate = !1);
									}
									(f.needsUpdate = !1), t.setRenderTarget(l, h, p);
								});
						}
						function pl(t, e, n) {
							const i = n.isWebGL2,
								r = new (function () {
									let e = !1;
									const n = new wr();
									let i = null;
									const r = new wr(0, 0, 0, 0);
									return {
										setMask: function (n) {
											i === n || e || (t.colorMask(n, n, n, n), (i = n));
										},
										setLocked: function (t) {
											e = t;
										},
										setClear: function (e, i, o, a, s) {
											!0 === s && ((e *= a), (i *= a), (o *= a)),
												n.set(e, i, o, a),
												!1 === r.equals(n) &&
													(t.clearColor(e, i, o, a), r.copy(n));
										},
										reset: function () {
											(e = !1), (i = null), r.set(-1, 0, 0, 0);
										},
									};
								})(),
								o = new (function () {
									let e = !1,
										n = null,
										i = null,
										r = null;
									return {
										setTest: function (t) {
											t ? z(2929) : W(2929);
										},
										setMask: function (i) {
											n === i || e || (t.depthMask(i), (n = i));
										},
										setFunc: function (e) {
											if (i !== e) {
												if (e)
													switch (e) {
														case 0:
															t.depthFunc(512);
															break;
														case 1:
															t.depthFunc(519);
															break;
														case 2:
															t.depthFunc(513);
															break;
														case 3:
															t.depthFunc(515);
															break;
														case 4:
															t.depthFunc(514);
															break;
														case 5:
															t.depthFunc(518);
															break;
														case 6:
															t.depthFunc(516);
															break;
														case 7:
															t.depthFunc(517);
															break;
														default:
															t.depthFunc(515);
													}
												else t.depthFunc(515);
												i = e;
											}
										},
										setLocked: function (t) {
											e = t;
										},
										setClear: function (e) {
											r !== e && (t.clearDepth(e), (r = e));
										},
										reset: function () {
											(e = !1), (n = null), (i = null), (r = null);
										},
									};
								})(),
								a = new (function () {
									let e = !1,
										n = null,
										i = null,
										r = null,
										o = null,
										a = null,
										s = null,
										c = null,
										l = null;
									return {
										setTest: function (t) {
											e || (t ? z(2960) : W(2960));
										},
										setMask: function (i) {
											n === i || e || (t.stencilMask(i), (n = i));
										},
										setFunc: function (e, n, a) {
											(i === e && r === n && o === a) ||
												(t.stencilFunc(e, n, a), (i = e), (r = n), (o = a));
										},
										setOp: function (e, n, i) {
											(a === e && s === n && c === i) ||
												(t.stencilOp(e, n, i), (a = e), (s = n), (c = i));
										},
										setLocked: function (t) {
											e = t;
										},
										setClear: function (e) {
											l !== e && (t.clearStencil(e), (l = e));
										},
										reset: function () {
											(e = !1),
												(n = null),
												(i = null),
												(r = null),
												(o = null),
												(a = null),
												(s = null),
												(c = null),
												(l = null);
										},
									};
								})();
							let s = {},
								c = null,
								l = null,
								h = null,
								p = null,
								u = null,
								d = null,
								m = null,
								f = null,
								g = null,
								S = !1,
								y = null,
								V = null,
								q = null,
								R = null,
								M = null;
							const I = t.getParameter(35661);
							let v = !1,
								k = 0;
							const U = t.getParameter(7938);
							-1 !== U.indexOf("WebGL")
								? ((k = parseFloat(/^WebGL\ ([0-9])/.exec(U)[1])), (v = k >= 1))
								: -1 !== U.indexOf("OpenGL ES") &&
								  ((k = parseFloat(/^OpenGL\ ES\ ([0-9])/.exec(U)[1])),
								  (v = k >= 2));
							let w = null,
								x = {};
							const O = new wr(),
								b = new wr();
							function K(e, n, i) {
								const r = new Uint8Array(4),
									o = t.createTexture();
								t.bindTexture(e, o),
									t.texParameteri(e, 10241, 9728),
									t.texParameteri(e, 10240, 9728);
								for (let e = 0; e < i; e++)
									t.texImage2D(n + e, 0, 6408, 1, 1, 0, 6408, 5121, r);
								return o;
							}
							const T = {};
							function z(e) {
								!0 !== s[e] && (t.enable(e), (s[e] = !0));
							}
							function W(e) {
								!1 !== s[e] && (t.disable(e), (s[e] = !1));
							}
							(T[3553] = K(3553, 3553, 1)),
								(T[34067] = K(34067, 34069, 6)),
								r.setClear(0, 0, 0, 1),
								o.setClear(1),
								a.setClear(0),
								z(2929),
								o.setFunc(3),
								Z(!1),
								H(1),
								z(2884),
								F(0);
							const E = { [Ci]: 32774, 101: 32778, 102: 32779 };
							if (i) (E[103] = 32775), (E[104] = 32776);
							else {
								const t = e.get("EXT_blend_minmax");
								null !== t && ((E[103] = t.MIN_EXT), (E[104] = t.MAX_EXT));
							}
							const C = {
								200: 0,
								201: 1,
								202: 768,
								204: 770,
								210: 776,
								208: 774,
								206: 772,
								203: 769,
								205: 771,
								209: 775,
								207: 773,
							};
							function F(e, n, i, r, o, a, s, c) {
								if (0 !== e) {
									if ((l || (z(3042), (l = !0)), 5 === e))
										(o = o || n),
											(a = a || i),
											(s = s || r),
											(n === p && o === m) ||
												(t.blendEquationSeparate(E[n], E[o]), (p = n), (m = o)),
											(i === u && r === d && a === f && s === g) ||
												(t.blendFuncSeparate(C[i], C[r], C[a], C[s]),
												(u = i),
												(d = r),
												(f = a),
												(g = s)),
											(h = e),
											(S = null);
									else if (e !== h || c !== S) {
										if (
											((p === Ci && m === Ci) ||
												(t.blendEquation(32774), (p = Ci), (m = Ci)),
											c)
										)
											switch (e) {
												case 1:
													t.blendFuncSeparate(1, 771, 1, 771);
													break;
												case 2:
													t.blendFunc(1, 1);
													break;
												case 3:
													t.blendFuncSeparate(0, 0, 769, 771);
													break;
												case 4:
													t.blendFuncSeparate(0, 768, 0, 770);
													break;
												default:
													console.error(
														"THREE.WebGLState: Invalid blending: ",
														e
													);
											}
										else
											switch (e) {
												case 1:
													t.blendFuncSeparate(770, 771, 1, 771);
													break;
												case 2:
													t.blendFunc(770, 1);
													break;
												case 3:
													t.blendFunc(0, 769);
													break;
												case 4:
													t.blendFunc(0, 768);
													break;
												default:
													console.error(
														"THREE.WebGLState: Invalid blending: ",
														e
													);
											}
										(u = null),
											(d = null),
											(f = null),
											(g = null),
											(h = e),
											(S = c);
									}
								} else l && (W(3042), (l = !1));
							}
							function Z(e) {
								y !== e && (e ? t.frontFace(2304) : t.frontFace(2305), (y = e));
							}
							function H(e) {
								0 !== e
									? (z(2884),
									  e !== V &&
											(1 === e
												? t.cullFace(1029)
												: 2 === e
												? t.cullFace(1028)
												: t.cullFace(1032)))
									: W(2884),
									(V = e);
							}
							function N(e, n, i) {
								e
									? (z(32823),
									  (R === n && M === i) ||
											(t.polygonOffset(n, i), (R = n), (M = i)))
									: W(32823);
							}
							function j(e) {
								void 0 === e && (e = 33984 + I - 1),
									w !== e && (t.activeTexture(e), (w = e));
							}
							return {
								buffers: { color: r, depth: o, stencil: a },
								enable: z,
								disable: W,
								useProgram: function (e) {
									return c !== e && (t.useProgram(e), (c = e), !0);
								},
								setBlending: F,
								setMaterial: function (t, e) {
									2 === t.side ? W(2884) : z(2884);
									let n = 1 === t.side;
									e && (n = !n),
										Z(n),
										1 === t.blending && !1 === t.transparent
											? F(0)
											: F(
													t.blending,
													t.blendEquation,
													t.blendSrc,
													t.blendDst,
													t.blendEquationAlpha,
													t.blendSrcAlpha,
													t.blendDstAlpha,
													t.premultipliedAlpha
											  ),
										o.setFunc(t.depthFunc),
										o.setTest(t.depthTest),
										o.setMask(t.depthWrite),
										r.setMask(t.colorWrite);
									const i = t.stencilWrite;
									a.setTest(i),
										i &&
											(a.setMask(t.stencilWriteMask),
											a.setFunc(t.stencilFunc, t.stencilRef, t.stencilFuncMask),
											a.setOp(t.stencilFail, t.stencilZFail, t.stencilZPass)),
										N(
											t.polygonOffset,
											t.polygonOffsetFactor,
											t.polygonOffsetUnits
										);
								},
								setFlipSided: Z,
								setCullFace: H,
								setLineWidth: function (e) {
									e !== q && (v && t.lineWidth(e), (q = e));
								},
								setPolygonOffset: N,
								setScissorTest: function (t) {
									t ? z(3089) : W(3089);
								},
								activeTexture: j,
								bindTexture: function (e, n) {
									null === w && j();
									let i = x[w];
									void 0 === i &&
										((i = { type: void 0, texture: void 0 }), (x[w] = i)),
										(i.type === e && i.texture === n) ||
											(t.bindTexture(e, n || T[e]),
											(i.type = e),
											(i.texture = n));
								},
								unbindTexture: function () {
									const e = x[w];
									void 0 !== e &&
										void 0 !== e.type &&
										(t.bindTexture(e.type, null),
										(e.type = void 0),
										(e.texture = void 0));
								},
								compressedTexImage2D: function () {
									try {
										t.compressedTexImage2D.apply(t, arguments);
									} catch (t) {
										console.error("THREE.WebGLState:", t);
									}
								},
								texImage2D: function () {
									try {
										t.texImage2D.apply(t, arguments);
									} catch (t) {
										console.error("THREE.WebGLState:", t);
									}
								},
								texImage3D: function () {
									try {
										t.texImage3D.apply(t, arguments);
									} catch (t) {
										console.error("THREE.WebGLState:", t);
									}
								},
								scissor: function (e) {
									!1 === O.equals(e) &&
										(t.scissor(e.x, e.y, e.z, e.w), O.copy(e));
								},
								viewport: function (e) {
									!1 === b.equals(e) &&
										(t.viewport(e.x, e.y, e.z, e.w), b.copy(e));
								},
								reset: function () {
									(s = {}),
										(w = null),
										(x = {}),
										(c = null),
										(h = null),
										(y = null),
										(V = null),
										r.reset(),
										o.reset(),
										a.reset();
								},
							};
						}
						function ul(t, e, n, i, r, o, a) {
							const s = r.isWebGL2,
								c = r.maxTextures,
								l = r.maxCubemapSize,
								h = r.maxTextureSize,
								p = r.maxSamples,
								u = new WeakMap();
							let d,
								m = !1;
							try {
								m =
									"undefined" != typeof OffscreenCanvas &&
									null !== new OffscreenCanvas(1, 1).getContext("2d");
							} catch (t) {}
							function f(t, e) {
								return m
									? new OffscreenCanvas(t, e)
									: document.createElementNS(
											"http://www.w3.org/1999/xhtml",
											"canvas"
									  );
							}
							function g(t, e, n, i) {
								let r = 1;
								if (
									((t.width > i || t.height > i) &&
										(r = i / Math.max(t.width, t.height)),
									r < 1 || !0 === e)
								) {
									if (
										("undefined" != typeof HTMLImageElement &&
											t instanceof HTMLImageElement) ||
										("undefined" != typeof HTMLCanvasElement &&
											t instanceof HTMLCanvasElement) ||
										("undefined" != typeof ImageBitmap &&
											t instanceof ImageBitmap)
									) {
										const i = e ? qr.floorPowerOfTwo : Math.floor,
											o = i(r * t.width),
											a = i(r * t.height);
										void 0 === d && (d = f(o, a));
										const s = n ? f(o, a) : d;
										return (
											(s.width = o),
											(s.height = a),
											s.getContext("2d").drawImage(t, 0, 0, o, a),
											console.warn(
												"THREE.WebGLRenderer: Texture has been resized from (" +
													t.width +
													"x" +
													t.height +
													") to (" +
													o +
													"x" +
													a +
													")."
											),
											s
										);
									}
									return (
										"data" in t &&
											console.warn(
												"THREE.WebGLRenderer: Image in DataTexture is too big (" +
													t.width +
													"x" +
													t.height +
													")."
											),
										t
									);
								}
								return t;
							}
							function S(t) {
								return qr.isPowerOfTwo(t.width) && qr.isPowerOfTwo(t.height);
							}
							function y(t, e) {
								return (
									t.generateMipmaps &&
									e &&
									t.minFilter !== Di &&
									t.minFilter !== Bi
								);
							}
							function V(e, n, r, o) {
								t.generateMipmap(e),
									(i.get(n).__maxMipLevel =
										Math.log(Math.max(r, o)) * Math.LOG2E);
							}
							function q(n, i, r) {
								if (!1 === s) return i;
								if (null !== n) {
									if (void 0 !== t[n]) return t[n];
									console.warn(
										"THREE.WebGLRenderer: Attempt to use non-existing WebGL internal format '" +
											n +
											"'"
									);
								}
								let o = i;
								return (
									6403 === i &&
										(5126 === r && (o = 33326),
										5131 === r && (o = 33325),
										5121 === r && (o = 33321)),
									6407 === i &&
										(5126 === r && (o = 34837),
										5131 === r && (o = 34843),
										5121 === r && (o = 32849)),
									6408 === i &&
										(5126 === r && (o = 34836),
										5131 === r && (o = 34842),
										5121 === r && (o = 32856)),
									(33325 !== o && 33326 !== o && 34842 !== o && 34836 !== o) ||
										e.get("EXT_color_buffer_float"),
									o
								);
							}
							function R(t) {
								return t === Di || t === Ai || t === Li ? 9728 : 9729;
							}
							function M(e) {
								const n = e.target;
								n.removeEventListener("dispose", M),
									(function (e) {
										const n = i.get(e);
										void 0 !== n.__webglInit &&
											(t.deleteTexture(n.__webglTexture), i.remove(e));
									})(n),
									n.isVideoTexture && u.delete(n),
									a.memory.textures--;
							}
							function I(e) {
								const n = e.target;
								n.removeEventListener("dispose", I),
									(function (e) {
										const n = i.get(e),
											r = i.get(e.texture);
										if (e) {
											if (
												(void 0 !== r.__webglTexture &&
													t.deleteTexture(r.__webglTexture),
												e.depthTexture && e.depthTexture.dispose(),
												e.isWebGLCubeRenderTarget)
											)
												for (let e = 0; e < 6; e++)
													t.deleteFramebuffer(n.__webglFramebuffer[e]),
														n.__webglDepthbuffer &&
															t.deleteRenderbuffer(n.__webglDepthbuffer[e]);
											else
												t.deleteFramebuffer(n.__webglFramebuffer),
													n.__webglDepthbuffer &&
														t.deleteRenderbuffer(n.__webglDepthbuffer),
													n.__webglMultisampledFramebuffer &&
														t.deleteFramebuffer(
															n.__webglMultisampledFramebuffer
														),
													n.__webglColorRenderbuffer &&
														t.deleteRenderbuffer(n.__webglColorRenderbuffer),
													n.__webglDepthRenderbuffer &&
														t.deleteRenderbuffer(n.__webglDepthRenderbuffer);
											i.remove(e.texture), i.remove(e);
										}
									})(n),
									a.memory.textures--;
							}
							let v = 0;
							function k(t, e) {
								const r = i.get(t);
								if (
									(t.isVideoTexture &&
										(function (t) {
											const e = a.render.frame;
											u.get(t) !== e && (u.set(t, e), t.update());
										})(t),
									t.version > 0 && r.__version !== t.version)
								) {
									const n = t.image;
									if (void 0 === n)
										console.warn(
											"THREE.WebGLRenderer: Texture marked for update but image is undefined"
										);
									else {
										if (!1 !== n.complete) return void T(r, t, e);
										console.warn(
											"THREE.WebGLRenderer: Texture marked for update but image is incomplete"
										);
									}
								}
								n.activeTexture(33984 + e),
									n.bindTexture(3553, r.__webglTexture);
							}
							function U(e, r) {
								if (6 !== e.image.length) return;
								const a = i.get(e);
								if (e.version > 0 && a.__version !== e.version) {
									K(a, e),
										n.activeTexture(33984 + r),
										n.bindTexture(34067, a.__webglTexture),
										t.pixelStorei(37440, e.flipY);
									const i =
											e &&
											(e.isCompressedTexture || e.image[0].isCompressedTexture),
										c = e.image[0] && e.image[0].isDataTexture,
										h = [];
									for (let t = 0; t < 6; t++)
										h[t] =
											i || c
												? c
													? e.image[t].image
													: e.image[t]
												: g(e.image[t], !1, !0, l);
									const p = h[0],
										u = S(p) || s,
										d = o.convert(e.format),
										m = o.convert(e.type),
										f = q(e.internalFormat, d, m);
									let R;
									if ((b(34067, e, u), i)) {
										for (let t = 0; t < 6; t++) {
											R = h[t].mipmaps;
											for (let i = 0; i < R.length; i++) {
												const r = R[i];
												e.format !== tr && e.format !== $i
													? null !== d
														? n.compressedTexImage2D(
																34069 + t,
																i,
																f,
																r.width,
																r.height,
																0,
																r.data
														  )
														: console.warn(
																"THREE.WebGLRenderer: Attempt to load unsupported compressed texture format in .setTextureCube()"
														  )
													: n.texImage2D(
															34069 + t,
															i,
															f,
															r.width,
															r.height,
															0,
															d,
															m,
															r.data
													  );
											}
										}
										a.__maxMipLevel = R.length - 1;
									} else {
										R = e.mipmaps;
										for (let t = 0; t < 6; t++)
											if (c) {
												n.texImage2D(
													34069 + t,
													0,
													f,
													h[t].width,
													h[t].height,
													0,
													d,
													m,
													h[t].data
												);
												for (let e = 0; e < R.length; e++) {
													const i = R[e].image[t].image;
													n.texImage2D(
														34069 + t,
														e + 1,
														f,
														i.width,
														i.height,
														0,
														d,
														m,
														i.data
													);
												}
											} else {
												n.texImage2D(34069 + t, 0, f, d, m, h[t]);
												for (let e = 0; e < R.length; e++) {
													const i = R[e];
													n.texImage2D(34069 + t, e + 1, f, d, m, i.image[t]);
												}
											}
										a.__maxMipLevel = R.length;
									}
									y(e, u) && V(34067, e, p.width, p.height),
										(a.__version = e.version),
										e.onUpdate && e.onUpdate(e);
								} else
									n.activeTexture(33984 + r),
										n.bindTexture(34067, a.__webglTexture);
							}
							function w(t, e) {
								n.activeTexture(33984 + e),
									n.bindTexture(34067, i.get(t).__webglTexture);
							}
							const x = { [Hi]: 10497, [Ni]: 33071, [ji]: 33648 },
								O = {
									[Di]: 9728,
									[Ai]: 9984,
									[Li]: 9986,
									[Bi]: 9729,
									1007: 9985,
									[Gi]: 9987,
								};
							function b(n, o, a) {
								a
									? (t.texParameteri(n, 10242, x[o.wrapS]),
									  t.texParameteri(n, 10243, x[o.wrapT]),
									  (32879 !== n && 35866 !== n) ||
											t.texParameteri(n, 32882, x[o.wrapR]),
									  t.texParameteri(n, 10240, O[o.magFilter]),
									  t.texParameteri(n, 10241, O[o.minFilter]))
									: (t.texParameteri(n, 10242, 33071),
									  t.texParameteri(n, 10243, 33071),
									  (32879 !== n && 35866 !== n) ||
											t.texParameteri(n, 32882, 33071),
									  (o.wrapS === Ni && o.wrapT === Ni) ||
											console.warn(
												"THREE.WebGLRenderer: Texture is not power of two. Texture.wrapS and Texture.wrapT should be set to THREE.ClampToEdgeWrapping."
											),
									  t.texParameteri(n, 10240, R(o.magFilter)),
									  t.texParameteri(n, 10241, R(o.minFilter)),
									  o.minFilter !== Di &&
											o.minFilter !== Bi &&
											console.warn(
												"THREE.WebGLRenderer: Texture is not power of two. Texture.minFilter should be set to THREE.NearestFilter or THREE.LinearFilter."
											));
								const c = e.get("EXT_texture_filter_anisotropic");
								if (c) {
									if (
										o.type === Ji &&
										null === e.get("OES_texture_float_linear")
									)
										return;
									if (
										o.type === Yi &&
										null === (s || e.get("OES_texture_half_float_linear"))
									)
										return;
									(o.anisotropy > 1 || i.get(o).__currentAnisotropy) &&
										(t.texParameterf(
											n,
											c.TEXTURE_MAX_ANISOTROPY_EXT,
											Math.min(o.anisotropy, r.getMaxAnisotropy())
										),
										(i.get(o).__currentAnisotropy = o.anisotropy));
								}
							}
							function K(e, n) {
								void 0 === e.__webglInit &&
									((e.__webglInit = !0),
									n.addEventListener("dispose", M),
									(e.__webglTexture = t.createTexture()),
									a.memory.textures++);
							}
							function T(e, i, r) {
								let a = 3553;
								i.isDataTexture2DArray && (a = 35866),
									i.isDataTexture3D && (a = 32879),
									K(e, i),
									n.activeTexture(33984 + r),
									n.bindTexture(a, e.__webglTexture),
									t.pixelStorei(37440, i.flipY),
									t.pixelStorei(37441, i.premultiplyAlpha),
									t.pixelStorei(3317, i.unpackAlignment);
								const c =
										(function (t) {
											return (
												!s &&
												(t.wrapS !== Ni ||
													t.wrapT !== Ni ||
													(t.minFilter !== Di && t.minFilter !== Bi))
											);
										})(i) && !1 === S(i.image),
									l = g(i.image, c, !1, h),
									p = S(l) || s,
									u = o.convert(i.format);
								let d,
									m = o.convert(i.type),
									f = q(i.internalFormat, u, m);
								b(a, i, p);
								const R = i.mipmaps;
								if (i.isDepthTexture)
									(f = 6402),
										s
											? (f =
													i.type === Ji
														? 36012
														: i.type === Pi
														? 33190
														: i.type === Xi
														? 35056
														: 33189)
											: i.type === Ji &&
											  console.error(
													"WebGLRenderer: Floating point depth texture requires WebGL2."
											  ),
										i.format === er &&
											6402 === f &&
											i.type !== _i &&
											i.type !== Pi &&
											(console.warn(
												"THREE.WebGLRenderer: Use UnsignedShortType or UnsignedIntType for DepthFormat DepthTexture."
											),
											(i.type = _i),
											(m = o.convert(i.type))),
										i.format === nr &&
											6402 === f &&
											((f = 34041),
											i.type !== Xi &&
												(console.warn(
													"THREE.WebGLRenderer: Use UnsignedInt248Type for DepthStencilFormat DepthTexture."
												),
												(i.type = Xi),
												(m = o.convert(i.type)))),
										n.texImage2D(3553, 0, f, l.width, l.height, 0, u, m, null);
								else if (i.isDataTexture)
									if (R.length > 0 && p) {
										for (let t = 0, e = R.length; t < e; t++)
											(d = R[t]),
												n.texImage2D(
													3553,
													t,
													f,
													d.width,
													d.height,
													0,
													u,
													m,
													d.data
												);
										(i.generateMipmaps = !1), (e.__maxMipLevel = R.length - 1);
									} else
										n.texImage2D(
											3553,
											0,
											f,
											l.width,
											l.height,
											0,
											u,
											m,
											l.data
										),
											(e.__maxMipLevel = 0);
								else if (i.isCompressedTexture) {
									for (let t = 0, e = R.length; t < e; t++)
										(d = R[t]),
											i.format !== tr && i.format !== $i
												? null !== u
													? n.compressedTexImage2D(
															3553,
															t,
															f,
															d.width,
															d.height,
															0,
															d.data
													  )
													: console.warn(
															"THREE.WebGLRenderer: Attempt to load unsupported compressed texture format in .uploadTexture()"
													  )
												: n.texImage2D(
														3553,
														t,
														f,
														d.width,
														d.height,
														0,
														u,
														m,
														d.data
												  );
									e.__maxMipLevel = R.length - 1;
								} else if (i.isDataTexture2DArray)
									n.texImage3D(
										35866,
										0,
										f,
										l.width,
										l.height,
										l.depth,
										0,
										u,
										m,
										l.data
									),
										(e.__maxMipLevel = 0);
								else if (i.isDataTexture3D)
									n.texImage3D(
										32879,
										0,
										f,
										l.width,
										l.height,
										l.depth,
										0,
										u,
										m,
										l.data
									),
										(e.__maxMipLevel = 0);
								else if (R.length > 0 && p) {
									for (let t = 0, e = R.length; t < e; t++)
										(d = R[t]), n.texImage2D(3553, t, f, u, m, d);
									(i.generateMipmaps = !1), (e.__maxMipLevel = R.length - 1);
								} else n.texImage2D(3553, 0, f, u, m, l), (e.__maxMipLevel = 0);
								y(i, p) && V(a, i, l.width, l.height),
									(e.__version = i.version),
									i.onUpdate && i.onUpdate(i);
							}
							function z(e, r, a, s) {
								const c = o.convert(r.texture.format),
									l = o.convert(r.texture.type),
									h = q(r.texture.internalFormat, c, l);
								n.texImage2D(s, 0, h, r.width, r.height, 0, c, l, null),
									t.bindFramebuffer(36160, e),
									t.framebufferTexture2D(
										36160,
										a,
										s,
										i.get(r.texture).__webglTexture,
										0
									),
									t.bindFramebuffer(36160, null);
							}
							function W(e, n, i) {
								if (
									(t.bindRenderbuffer(36161, e),
									n.depthBuffer && !n.stencilBuffer)
								) {
									let r = 33189;
									if (i) {
										const e = n.depthTexture;
										e &&
											e.isDepthTexture &&
											(e.type === Ji
												? (r = 36012)
												: e.type === Pi && (r = 33190));
										const i = E(n);
										t.renderbufferStorageMultisample(
											36161,
											i,
											r,
											n.width,
											n.height
										);
									} else t.renderbufferStorage(36161, r, n.width, n.height);
									t.framebufferRenderbuffer(36160, 36096, 36161, e);
								} else if (n.depthBuffer && n.stencilBuffer) {
									if (i) {
										const e = E(n);
										t.renderbufferStorageMultisample(
											36161,
											e,
											35056,
											n.width,
											n.height
										);
									} else t.renderbufferStorage(36161, 34041, n.width, n.height);
									t.framebufferRenderbuffer(36160, 33306, 36161, e);
								} else {
									const e = o.convert(n.texture.format),
										r = o.convert(n.texture.type),
										a = q(n.texture.internalFormat, e, r);
									if (i) {
										const e = E(n);
										t.renderbufferStorageMultisample(
											36161,
											e,
											a,
											n.width,
											n.height
										);
									} else t.renderbufferStorage(36161, a, n.width, n.height);
								}
								t.bindRenderbuffer(36161, null);
							}
							function E(t) {
								return s && t.isWebGLMultisampleRenderTarget
									? Math.min(p, t.samples)
									: 0;
							}
							let C = !1,
								F = !1;
							(this.allocateTextureUnit = function () {
								const t = v;
								return (
									t >= c &&
										console.warn(
											"THREE.WebGLTextures: Trying to use " +
												t +
												" texture units while this GPU supports only " +
												c
										),
									(v += 1),
									t
								);
							}),
								(this.resetTextureUnits = function () {
									v = 0;
								}),
								(this.setTexture2D = k),
								(this.setTexture2DArray = function (t, e) {
									const r = i.get(t);
									t.version > 0 && r.__version !== t.version
										? T(r, t, e)
										: (n.activeTexture(33984 + e),
										  n.bindTexture(35866, r.__webglTexture));
								}),
								(this.setTexture3D = function (t, e) {
									const r = i.get(t);
									t.version > 0 && r.__version !== t.version
										? T(r, t, e)
										: (n.activeTexture(33984 + e),
										  n.bindTexture(32879, r.__webglTexture));
								}),
								(this.setTextureCube = U),
								(this.setTextureCubeDynamic = w),
								(this.setupRenderTarget = function (e) {
									const r = i.get(e),
										c = i.get(e.texture);
									e.addEventListener("dispose", I),
										(c.__webglTexture = t.createTexture()),
										a.memory.textures++;
									const l = !0 === e.isWebGLCubeRenderTarget,
										h = !0 === e.isWebGLMultisampleRenderTarget,
										p = S(e) || s;
									if (
										(!s ||
											e.texture.format !== $i ||
											(e.texture.type !== Ji && e.texture.type !== Yi) ||
											((e.texture.format = tr),
											console.warn(
												"THREE.WebGLRenderer: Rendering to textures with RGB format is not supported. Using RGBA format instead."
											)),
										l)
									) {
										r.__webglFramebuffer = [];
										for (let e = 0; e < 6; e++)
											r.__webglFramebuffer[e] = t.createFramebuffer();
									} else if (
										((r.__webglFramebuffer = t.createFramebuffer()), h)
									)
										if (s) {
											(r.__webglMultisampledFramebuffer =
												t.createFramebuffer()),
												(r.__webglColorRenderbuffer = t.createRenderbuffer()),
												t.bindRenderbuffer(36161, r.__webglColorRenderbuffer);
											const n = o.convert(e.texture.format),
												i = o.convert(e.texture.type),
												a = q(e.texture.internalFormat, n, i),
												s = E(e);
											t.renderbufferStorageMultisample(
												36161,
												s,
												a,
												e.width,
												e.height
											),
												t.bindFramebuffer(
													36160,
													r.__webglMultisampledFramebuffer
												),
												t.framebufferRenderbuffer(
													36160,
													36064,
													36161,
													r.__webglColorRenderbuffer
												),
												t.bindRenderbuffer(36161, null),
												e.depthBuffer &&
													((r.__webglDepthRenderbuffer =
														t.createRenderbuffer()),
													W(r.__webglDepthRenderbuffer, e, !0)),
												t.bindFramebuffer(36160, null);
										} else
											console.warn(
												"THREE.WebGLRenderer: WebGLMultisampleRenderTarget can only be used with WebGL2."
											);
									if (l) {
										n.bindTexture(34067, c.__webglTexture),
											b(34067, e.texture, p);
										for (let t = 0; t < 6; t++)
											z(r.__webglFramebuffer[t], e, 36064, 34069 + t);
										y(e.texture, p) && V(34067, e.texture, e.width, e.height),
											n.bindTexture(34067, null);
									} else
										n.bindTexture(3553, c.__webglTexture),
											b(3553, e.texture, p),
											z(r.__webglFramebuffer, e, 36064, 3553),
											y(e.texture, p) && V(3553, e.texture, e.width, e.height),
											n.bindTexture(3553, null);
									e.depthBuffer &&
										(function (e) {
											const n = i.get(e),
												r = !0 === e.isWebGLCubeRenderTarget;
											if (e.depthTexture) {
												if (r)
													throw new Error(
														"target.depthTexture not supported in Cube render targets"
													);
												!(function (e, n) {
													if (n && n.isWebGLCubeRenderTarget)
														throw new Error(
															"Depth Texture with cube render targets is not supported"
														);
													if (
														(t.bindFramebuffer(36160, e),
														!n.depthTexture || !n.depthTexture.isDepthTexture)
													)
														throw new Error(
															"renderTarget.depthTexture must be an instance of THREE.DepthTexture"
														);
													(i.get(n.depthTexture).__webglTexture &&
														n.depthTexture.image.width === n.width &&
														n.depthTexture.image.height === n.height) ||
														((n.depthTexture.image.width = n.width),
														(n.depthTexture.image.height = n.height),
														(n.depthTexture.needsUpdate = !0)),
														k(n.depthTexture, 0);
													const r = i.get(n.depthTexture).__webglTexture;
													if (n.depthTexture.format === er)
														t.framebufferTexture2D(36160, 36096, 3553, r, 0);
													else {
														if (n.depthTexture.format !== nr)
															throw new Error("Unknown depthTexture format");
														t.framebufferTexture2D(36160, 33306, 3553, r, 0);
													}
												})(n.__webglFramebuffer, e);
											} else if (r) {
												n.__webglDepthbuffer = [];
												for (let i = 0; i < 6; i++)
													t.bindFramebuffer(36160, n.__webglFramebuffer[i]),
														(n.__webglDepthbuffer[i] = t.createRenderbuffer()),
														W(n.__webglDepthbuffer[i], e, !1);
											} else
												t.bindFramebuffer(36160, n.__webglFramebuffer),
													(n.__webglDepthbuffer = t.createRenderbuffer()),
													W(n.__webglDepthbuffer, e, !1);
											t.bindFramebuffer(36160, null);
										})(e);
								}),
								(this.updateRenderTargetMipmap = function (t) {
									const e = t.texture;
									if (y(e, S(t) || s)) {
										const r = t.isWebGLCubeRenderTarget ? 34067 : 3553,
											o = i.get(e).__webglTexture;
										n.bindTexture(r, o),
											V(r, e, t.width, t.height),
											n.bindTexture(r, null);
									}
								}),
								(this.updateMultisampleRenderTarget = function (e) {
									if (e.isWebGLMultisampleRenderTarget)
										if (s) {
											const n = i.get(e);
											t.bindFramebuffer(
												36008,
												n.__webglMultisampledFramebuffer
											),
												t.bindFramebuffer(36009, n.__webglFramebuffer);
											const r = e.width,
												o = e.height;
											let a = 16384;
											e.depthBuffer && (a |= 256),
												e.stencilBuffer && (a |= 1024),
												t.blitFramebuffer(0, 0, r, o, 0, 0, r, o, a, 9728),
												t.bindFramebuffer(
													36160,
													n.__webglMultisampledFramebuffer
												);
										} else
											console.warn(
												"THREE.WebGLRenderer: WebGLMultisampleRenderTarget can only be used with WebGL2."
											);
								}),
								(this.safeSetTexture2D = function (t, e) {
									t &&
										t.isWebGLRenderTarget &&
										(!1 === C &&
											(console.warn(
												"THREE.WebGLTextures.safeSetTexture2D: don't use render targets as textures. Use their .texture property instead."
											),
											(C = !0)),
										(t = t.texture)),
										k(t, e);
								}),
								(this.safeSetTextureCube = function (t, e) {
									t &&
										t.isWebGLCubeRenderTarget &&
										(!1 === F &&
											(console.warn(
												"THREE.WebGLTextures.safeSetTextureCube: don't use cube render targets as textures. Use their .texture property instead."
											),
											(F = !0)),
										(t = t.texture)),
										(t && t.isCubeTexture) ||
										(Array.isArray(t.image) && 6 === t.image.length)
											? U(t, e)
											: w(t, e);
								});
						}
						function dl(t, e, n) {
							const i = n.isWebGL2;
							return {
								convert: function (t) {
									let n;
									if (t === Qi) return 5121;
									if (1017 === t) return 32819;
									if (1018 === t) return 32820;
									if (1019 === t) return 33635;
									if (1010 === t) return 5120;
									if (1011 === t) return 5122;
									if (t === _i) return 5123;
									if (1013 === t) return 5124;
									if (t === Pi) return 5125;
									if (t === Ji) return 5126;
									if (t === Yi)
										return i
											? 5131
											: ((n = e.get("OES_texture_half_float")),
											  null !== n ? n.HALF_FLOAT_OES : null);
									if (1021 === t) return 6406;
									if (t === $i) return 6407;
									if (t === tr) return 6408;
									if (1024 === t) return 6409;
									if (1025 === t) return 6410;
									if (t === er) return 6402;
									if (t === nr) return 34041;
									if (1028 === t) return 6403;
									if (1029 === t) return 36244;
									if (1030 === t) return 33319;
									if (1031 === t) return 33320;
									if (1032 === t) return 36248;
									if (1033 === t) return 36249;
									if (
										33776 === t ||
										33777 === t ||
										33778 === t ||
										33779 === t
									) {
										if (
											((n = e.get("WEBGL_compressed_texture_s3tc")), null === n)
										)
											return null;
										if (33776 === t) return n.COMPRESSED_RGB_S3TC_DXT1_EXT;
										if (33777 === t) return n.COMPRESSED_RGBA_S3TC_DXT1_EXT;
										if (33778 === t) return n.COMPRESSED_RGBA_S3TC_DXT3_EXT;
										if (33779 === t) return n.COMPRESSED_RGBA_S3TC_DXT5_EXT;
									}
									if (
										35840 === t ||
										35841 === t ||
										35842 === t ||
										35843 === t
									) {
										if (
											((n = e.get("WEBGL_compressed_texture_pvrtc")),
											null === n)
										)
											return null;
										if (35840 === t) return n.COMPRESSED_RGB_PVRTC_4BPPV1_IMG;
										if (35841 === t) return n.COMPRESSED_RGB_PVRTC_2BPPV1_IMG;
										if (35842 === t) return n.COMPRESSED_RGBA_PVRTC_4BPPV1_IMG;
										if (35843 === t) return n.COMPRESSED_RGBA_PVRTC_2BPPV1_IMG;
									}
									if (36196 === t)
										return (
											(n = e.get("WEBGL_compressed_texture_etc1")),
											null !== n ? n.COMPRESSED_RGB_ETC1_WEBGL : null
										);
									if (
										(37492 === t || 37496 === t) &&
										((n = e.get("WEBGL_compressed_texture_etc")), null !== n)
									) {
										if (37492 === t) return n.COMPRESSED_RGB8_ETC2;
										if (37496 === t) return n.COMPRESSED_RGBA8_ETC2_EAC;
									}
									return 37808 === t ||
										37809 === t ||
										37810 === t ||
										37811 === t ||
										37812 === t ||
										37813 === t ||
										37814 === t ||
										37815 === t ||
										37816 === t ||
										37817 === t ||
										37818 === t ||
										37819 === t ||
										37820 === t ||
										37821 === t ||
										37840 === t ||
										37841 === t ||
										37842 === t ||
										37843 === t ||
										37844 === t ||
										37845 === t ||
										37846 === t ||
										37847 === t ||
										37848 === t ||
										37849 === t ||
										37850 === t ||
										37851 === t ||
										37852 === t ||
										37853 === t
										? ((n = e.get("WEBGL_compressed_texture_astc")),
										  null !== n ? t : null)
										: 36492 === t
										? ((n = e.get("EXT_texture_compression_bptc")),
										  null !== n ? t : null)
										: t === Xi
										? i
											? 34042
											: ((n = e.get("WEBGL_depth_texture")),
											  null !== n ? n.UNSIGNED_INT_24_8_WEBGL : null)
										: void 0;
								},
							};
						}
						function ml(t) {
							rs.call(this), (this.cameras = t || []);
						}
						function fl() {
							oo.call(this), (this.type = "Group");
						}
						function gl() {
							(this._targetRay = null),
								(this._grip = null),
								(this._hand = null);
						}
						function Sl(t, e) {
							const n = this;
							let i = null,
								r = 1,
								o = null,
								a = "local-floor",
								s = null;
							const c = [],
								l = new Map(),
								h = new rs();
							h.layers.enable(1), (h.viewport = new wr());
							const p = new rs();
							p.layers.enable(2), (p.viewport = new wr());
							const u = [h, p],
								d = new ml();
							d.layers.enable(1), d.layers.enable(2);
							let m = null,
								f = null;
							function g(t) {
								const e = l.get(t.inputSource);
								e && e.dispatchEvent({ type: t.type });
							}
							function S() {
								l.forEach(function (t, e) {
									t.disconnect(e);
								}),
									l.clear(),
									t.setFramebuffer(null),
									t.setRenderTarget(t.getRenderTarget()),
									v.stop(),
									(n.isPresenting = !1),
									n.dispatchEvent({ type: "sessionend" });
							}
							function y(t) {
								(o = t),
									v.setContext(i),
									v.start(),
									(n.isPresenting = !0),
									n.dispatchEvent({ type: "sessionstart" });
							}
							function V(t) {
								const e = i.inputSources;
								for (let t = 0; t < c.length; t++) l.set(e[t], c[t]);
								for (let e = 0; e < t.removed.length; e++) {
									const n = t.removed[e],
										i = l.get(n);
									i &&
										(i.dispatchEvent({ type: "disconnected", data: n }),
										l.delete(n));
								}
								for (let e = 0; e < t.added.length; e++) {
									const n = t.added[e],
										i = l.get(n);
									i && i.dispatchEvent({ type: "connected", data: n });
								}
							}
							(this.enabled = !1),
								(this.isPresenting = !1),
								(this.getController = function (t) {
									let e = c[t];
									return (
										void 0 === e && ((e = new gl()), (c[t] = e)),
										e.getTargetRaySpace()
									);
								}),
								(this.getControllerGrip = function (t) {
									let e = c[t];
									return (
										void 0 === e && ((e = new gl()), (c[t] = e)),
										e.getGripSpace()
									);
								}),
								(this.getHand = function (t) {
									let e = c[t];
									return (
										void 0 === e && ((e = new gl()), (c[t] = e)),
										e.getHandSpace()
									);
								}),
								(this.setFramebufferScaleFactor = function (t) {
									(r = t),
										!0 === n.isPresenting &&
											console.warn(
												"THREE.WebXRManager: Cannot change framebuffer scale while presenting."
											);
								}),
								(this.setReferenceSpaceType = function (t) {
									(a = t),
										!0 === n.isPresenting &&
											console.warn(
												"THREE.WebXRManager: Cannot change reference space type while presenting."
											);
								}),
								(this.getReferenceSpace = function () {
									return o;
								}),
								(this.getSession = function () {
									return i;
								}),
								(this.setSession = function (t) {
									if (((i = t), null !== i)) {
										i.addEventListener("select", g),
											i.addEventListener("selectstart", g),
											i.addEventListener("selectend", g),
											i.addEventListener("squeeze", g),
											i.addEventListener("squeezestart", g),
											i.addEventListener("squeezeend", g),
											i.addEventListener("end", S);
										const t = e.getContextAttributes();
										!0 !== t.xrCompatible && e.makeXRCompatible();
										const n = {
												antialias: t.antialias,
												alpha: t.alpha,
												depth: t.depth,
												stencil: t.stencil,
												framebufferScaleFactor: r,
											},
											o = new XRWebGLLayer(i, e, n);
										i.updateRenderState({ baseLayer: o }),
											i.requestReferenceSpace(a).then(y),
											i.addEventListener("inputsourceschange", V);
									}
								});
							const q = new zr(),
								R = new zr();
							function M(t, e) {
								null === e
									? t.matrixWorld.copy(t.matrix)
									: t.matrixWorld.multiplyMatrices(e.matrixWorld, t.matrix),
									t.matrixWorldInverse.getInverse(t.matrixWorld);
							}
							this.getCamera = function (t) {
								(d.near = p.near = h.near = t.near),
									(d.far = p.far = h.far = t.far),
									(m === d.near && f === d.far) ||
										(i.updateRenderState({
											depthNear: d.near,
											depthFar: d.far,
										}),
										(m = d.near),
										(f = d.far));
								const e = t.parent,
									n = d.cameras;
								M(d, e);
								for (let t = 0; t < n.length; t++) M(n[t], e);
								t.matrixWorld.copy(d.matrixWorld);
								const r = t.children;
								for (let t = 0, e = r.length; t < e; t++)
									r[t].updateMatrixWorld(!0);
								return (
									2 === n.length
										? (function (t, e, n) {
												q.setFromMatrixPosition(e.matrixWorld),
													R.setFromMatrixPosition(n.matrixWorld);
												const i = q.distanceTo(R),
													r = e.projectionMatrix.elements,
													o = n.projectionMatrix.elements,
													a = r[14] / (r[10] - 1),
													s = r[14] / (r[10] + 1),
													c = (r[9] + 1) / r[5],
													l = (r[9] - 1) / r[5],
													h = (r[8] - 1) / r[0],
													p = (o[8] + 1) / o[0],
													u = a * h,
													d = a * p,
													m = i / (-h + p),
													f = m * -h;
												e.matrixWorld.decompose(
													t.position,
													t.quaternion,
													t.scale
												),
													t.translateX(f),
													t.translateZ(m),
													t.matrixWorld.compose(
														t.position,
														t.quaternion,
														t.scale
													),
													t.matrixWorldInverse.getInverse(t.matrixWorld);
												const g = a + m,
													S = s + m,
													y = u - f,
													V = d + (i - f),
													M = ((c * s) / S) * g,
													I = ((l * s) / S) * g;
												t.projectionMatrix.makePerspective(y, V, M, I, g, S);
										  })(d, h, p)
										: d.projectionMatrix.copy(h.projectionMatrix),
									d
								);
							};
							let I = null;
							const v = new ds();
							v.setAnimationLoop(function (e, n) {
								if (((s = n.getViewerPose(o)), null !== s)) {
									const e = s.views,
										n = i.renderState.baseLayer;
									t.setFramebuffer(n.framebuffer);
									let r = !1;
									e.length !== d.cameras.length &&
										((d.cameras.length = 0), (r = !0));
									for (let t = 0; t < e.length; t++) {
										const i = e[t],
											o = n.getViewport(i),
											a = u[t];
										a.matrix.fromArray(i.transform.matrix),
											a.projectionMatrix.fromArray(i.projectionMatrix),
											a.viewport.set(o.x, o.y, o.width, o.height),
											0 === t && d.matrix.copy(a.matrix),
											!0 === r && d.cameras.push(a);
									}
								}
								const r = i.inputSources;
								for (let t = 0; t < c.length; t++) {
									const e = c[t],
										i = r[t];
									e.update(i, n, o);
								}
								I && I(e, n);
							}),
								(this.setAnimationLoop = function (t) {
									I = t;
								}),
								(this.dispose = function () {});
						}
						function yl(t) {
							function e(e, n, i) {
								(e.opacity.value = n.opacity),
									n.color && e.diffuse.value.copy(n.color),
									n.emissive &&
										e.emissive.value
											.copy(n.emissive)
											.multiplyScalar(n.emissiveIntensity),
									n.map && (e.map.value = n.map),
									n.alphaMap && (e.alphaMap.value = n.alphaMap),
									n.specularMap && (e.specularMap.value = n.specularMap);
								const r = n.envMap || i;
								if (r) {
									(e.envMap.value = r),
										(e.flipEnvMap.value = r.isCubeTexture ? -1 : 1),
										(e.reflectivity.value = n.reflectivity),
										(e.refractionRatio.value = n.refractionRatio);
									var o = t.get(r).__maxMipLevel;
									void 0 !== o && (e.maxMipLevel.value = o);
								}
								let a, s;
								n.lightMap &&
									((e.lightMap.value = n.lightMap),
									(e.lightMapIntensity.value = n.lightMapIntensity)),
									n.aoMap &&
										((e.aoMap.value = n.aoMap),
										(e.aoMapIntensity.value = n.aoMapIntensity)),
									n.map
										? (a = n.map)
										: n.specularMap
										? (a = n.specularMap)
										: n.displacementMap
										? (a = n.displacementMap)
										: n.normalMap
										? (a = n.normalMap)
										: n.bumpMap
										? (a = n.bumpMap)
										: n.roughnessMap
										? (a = n.roughnessMap)
										: n.metalnessMap
										? (a = n.metalnessMap)
										: n.alphaMap
										? (a = n.alphaMap)
										: n.emissiveMap && (a = n.emissiveMap),
									void 0 !== a &&
										(a.isWebGLRenderTarget && (a = a.texture),
										!0 === a.matrixAutoUpdate && a.updateMatrix(),
										e.uvTransform.value.copy(a.matrix)),
									n.aoMap ? (s = n.aoMap) : n.lightMap && (s = n.lightMap),
									void 0 !== s &&
										(s.isWebGLRenderTarget && (s = s.texture),
										!0 === s.matrixAutoUpdate && s.updateMatrix(),
										e.uv2Transform.value.copy(s.matrix));
							}
							function n(t, e, n) {
								(t.roughness.value = e.roughness),
									(t.metalness.value = e.metalness),
									e.roughnessMap && (t.roughnessMap.value = e.roughnessMap),
									e.metalnessMap && (t.metalnessMap.value = e.metalnessMap),
									e.emissiveMap && (t.emissiveMap.value = e.emissiveMap),
									e.bumpMap &&
										((t.bumpMap.value = e.bumpMap),
										(t.bumpScale.value = e.bumpScale),
										1 === e.side && (t.bumpScale.value *= -1)),
									e.normalMap &&
										((t.normalMap.value = e.normalMap),
										t.normalScale.value.copy(e.normalScale),
										1 === e.side && t.normalScale.value.negate()),
									e.displacementMap &&
										((t.displacementMap.value = e.displacementMap),
										(t.displacementScale.value = e.displacementScale),
										(t.displacementBias.value = e.displacementBias)),
									(e.envMap || n) &&
										(t.envMapIntensity.value = e.envMapIntensity);
							}
							return {
								refreshFogUniforms: function (t, e) {
									t.fogColor.value.copy(e.color),
										e.isFog
											? ((t.fogNear.value = e.near), (t.fogFar.value = e.far))
											: e.isFogExp2 && (t.fogDensity.value = e.density);
								},
								refreshMaterialUniforms: function (t, i, r, o, a) {
									i.isMeshBasicMaterial
										? e(t, i)
										: i.isMeshLambertMaterial
										? (e(t, i),
										  (function (t, e) {
												e.emissiveMap && (t.emissiveMap.value = e.emissiveMap);
										  })(t, i))
										: i.isMeshToonMaterial
										? (e(t, i),
										  (function (t, e) {
												e.gradientMap && (t.gradientMap.value = e.gradientMap),
													e.emissiveMap &&
														(t.emissiveMap.value = e.emissiveMap),
													e.bumpMap &&
														((t.bumpMap.value = e.bumpMap),
														(t.bumpScale.value = e.bumpScale),
														1 === e.side && (t.bumpScale.value *= -1)),
													e.normalMap &&
														((t.normalMap.value = e.normalMap),
														t.normalScale.value.copy(e.normalScale),
														1 === e.side && t.normalScale.value.negate()),
													e.displacementMap &&
														((t.displacementMap.value = e.displacementMap),
														(t.displacementScale.value = e.displacementScale),
														(t.displacementBias.value = e.displacementBias));
										  })(t, i))
										: i.isMeshPhongMaterial
										? (e(t, i),
										  (function (t, e) {
												t.specular.value.copy(e.specular),
													(t.shininess.value = Math.max(e.shininess, 1e-4)),
													e.emissiveMap &&
														(t.emissiveMap.value = e.emissiveMap),
													e.bumpMap &&
														((t.bumpMap.value = e.bumpMap),
														(t.bumpScale.value = e.bumpScale),
														1 === e.side && (t.bumpScale.value *= -1)),
													e.normalMap &&
														((t.normalMap.value = e.normalMap),
														t.normalScale.value.copy(e.normalScale),
														1 === e.side && t.normalScale.value.negate()),
													e.displacementMap &&
														((t.displacementMap.value = e.displacementMap),
														(t.displacementScale.value = e.displacementScale),
														(t.displacementBias.value = e.displacementBias));
										  })(t, i))
										: i.isMeshStandardMaterial
										? (e(t, i, r),
										  i.isMeshPhysicalMaterial
												? (function (t, e, i) {
														n(t, e, i),
															(t.reflectivity.value = e.reflectivity),
															(t.clearcoat.value = e.clearcoat),
															(t.clearcoatRoughness.value =
																e.clearcoatRoughness),
															e.sheen && t.sheen.value.copy(e.sheen),
															e.clearcoatMap &&
																(t.clearcoatMap.value = e.clearcoatMap),
															e.clearcoatRoughnessMap &&
																(t.clearcoatRoughnessMap.value =
																	e.clearcoatRoughnessMap),
															e.clearcoatNormalMap &&
																(t.clearcoatNormalScale.value.copy(
																	e.clearcoatNormalScale
																),
																(t.clearcoatNormalMap.value =
																	e.clearcoatNormalMap),
																1 === e.side &&
																	t.clearcoatNormalScale.value.negate()),
															(t.transmission.value = e.transmission),
															e.transmissionMap &&
																(t.transmissionMap.value = e.transmissionMap);
												  })(t, i, r)
												: n(t, i, r))
										: i.isMeshMatcapMaterial
										? (e(t, i),
										  (function (t, e) {
												e.matcap && (t.matcap.value = e.matcap),
													e.bumpMap &&
														((t.bumpMap.value = e.bumpMap),
														(t.bumpScale.value = e.bumpScale),
														1 === e.side && (t.bumpScale.value *= -1)),
													e.normalMap &&
														((t.normalMap.value = e.normalMap),
														t.normalScale.value.copy(e.normalScale),
														1 === e.side && t.normalScale.value.negate()),
													e.displacementMap &&
														((t.displacementMap.value = e.displacementMap),
														(t.displacementScale.value = e.displacementScale),
														(t.displacementBias.value = e.displacementBias));
										  })(t, i))
										: i.isMeshDepthMaterial
										? (e(t, i),
										  (function (t, e) {
												e.displacementMap &&
													((t.displacementMap.value = e.displacementMap),
													(t.displacementScale.value = e.displacementScale),
													(t.displacementBias.value = e.displacementBias));
										  })(t, i))
										: i.isMeshDistanceMaterial
										? (e(t, i),
										  (function (t, e) {
												e.displacementMap &&
													((t.displacementMap.value = e.displacementMap),
													(t.displacementScale.value = e.displacementScale),
													(t.displacementBias.value = e.displacementBias)),
													t.referencePosition.value.copy(e.referencePosition),
													(t.nearDistance.value = e.nearDistance),
													(t.farDistance.value = e.farDistance);
										  })(t, i))
										: i.isMeshNormalMaterial
										? (e(t, i),
										  (function (t, e) {
												e.bumpMap &&
													((t.bumpMap.value = e.bumpMap),
													(t.bumpScale.value = e.bumpScale),
													1 === e.side && (t.bumpScale.value *= -1)),
													e.normalMap &&
														((t.normalMap.value = e.normalMap),
														t.normalScale.value.copy(e.normalScale),
														1 === e.side && t.normalScale.value.negate()),
													e.displacementMap &&
														((t.displacementMap.value = e.displacementMap),
														(t.displacementScale.value = e.displacementScale),
														(t.displacementBias.value = e.displacementBias));
										  })(t, i))
										: i.isLineBasicMaterial
										? ((function (t, e) {
												t.diffuse.value.copy(e.color),
													(t.opacity.value = e.opacity);
										  })(t, i),
										  i.isLineDashedMaterial &&
												(function (t, e) {
													(t.dashSize.value = e.dashSize),
														(t.totalSize.value = e.dashSize + e.gapSize),
														(t.scale.value = e.scale);
												})(t, i))
										: i.isPointsMaterial
										? (function (t, e, n, i) {
												let r;
												t.diffuse.value.copy(e.color),
													(t.opacity.value = e.opacity),
													(t.size.value = e.size * n),
													(t.scale.value = 0.5 * i),
													e.map && (t.map.value = e.map),
													e.alphaMap && (t.alphaMap.value = e.alphaMap),
													e.map ? (r = e.map) : e.alphaMap && (r = e.alphaMap),
													void 0 !== r &&
														(!0 === r.matrixAutoUpdate && r.updateMatrix(),
														t.uvTransform.value.copy(r.matrix));
										  })(t, i, o, a)
										: i.isSpriteMaterial
										? (function (t, e) {
												let n;
												t.diffuse.value.copy(e.color),
													(t.opacity.value = e.opacity),
													(t.rotation.value = e.rotation),
													e.map && (t.map.value = e.map),
													e.alphaMap && (t.alphaMap.value = e.alphaMap),
													e.map ? (n = e.map) : e.alphaMap && (n = e.alphaMap),
													void 0 !== n &&
														(!0 === n.matrixAutoUpdate && n.updateMatrix(),
														t.uvTransform.value.copy(n.matrix));
										  })(t, i)
										: i.isShadowMaterial
										? (t.color.value.copy(i.color),
										  (t.opacity.value = i.opacity))
										: i.isShaderMaterial && (i.uniformsNeedUpdate = !1);
								},
							};
						}
						function Vl(t) {
							const e =
									void 0 !== (t = t || {}).canvas
										? t.canvas
										: document.createElementNS(
												"http://www.w3.org/1999/xhtml",
												"canvas"
										  ),
								n = void 0 !== t.context ? t.context : null,
								i = void 0 !== t.alpha && t.alpha,
								r = void 0 === t.depth || t.depth,
								o = void 0 === t.stencil || t.stencil,
								a = void 0 !== t.antialias && t.antialias,
								s = void 0 === t.premultipliedAlpha || t.premultipliedAlpha,
								c =
									void 0 !== t.preserveDrawingBuffer && t.preserveDrawingBuffer,
								l =
									void 0 !== t.powerPreference ? t.powerPreference : "default",
								h =
									void 0 !== t.failIfMajorPerformanceCaveat &&
									t.failIfMajorPerformanceCaveat;
							let p = null,
								u = null;
							(this.domElement = e),
								(this.debug = { checkShaderErrors: !0 }),
								(this.autoClear = !0),
								(this.autoClearColor = !0),
								(this.autoClearDepth = !0),
								(this.autoClearStencil = !0),
								(this.sortObjects = !0),
								(this.clippingPlanes = []),
								(this.localClippingEnabled = !1),
								(this.gammaFactor = 2),
								(this.outputEncoding = hr),
								(this.physicallyCorrectLights = !1),
								(this.toneMapping = 0),
								(this.toneMappingExposure = 1),
								(this.maxMorphTargets = 8),
								(this.maxMorphNormals = 4);
							const d = this;
							let m = !1,
								f = null,
								g = 0,
								S = 0,
								y = null,
								V = null,
								q = -1,
								R = null,
								M = null;
							const I = new wr(),
								v = new wr();
							let k = null,
								U = e.width,
								w = e.height,
								x = 1,
								O = null,
								b = null;
							const K = new wr(0, 0, U, w),
								T = new wr(0, 0, U, w);
							let z = !1;
							const W = new ps(),
								E = new Is();
							let C = !1,
								F = !1;
							const Z = new jr(),
								H = new zr(),
								N = {
									background: null,
									fog: null,
									environment: null,
									overrideMaterial: null,
									isScene: !0,
								};
							function j() {
								return null === y ? x : 1;
							}
							let D,
								A,
								L,
								B,
								G,
								Q,
								_,
								P,
								J,
								Y,
								X,
								$,
								tt,
								et,
								nt,
								it,
								rt,
								ot,
								at,
								st = n;
							function ct(t, n) {
								for (let i = 0; i < t.length; i++) {
									const r = t[i],
										o = e.getContext(r, n);
									if (null !== o) return o;
								}
								return null;
							}
							try {
								const t = {
									alpha: i,
									depth: r,
									stencil: o,
									antialias: a,
									premultipliedAlpha: s,
									preserveDrawingBuffer: c,
									powerPreference: l,
									failIfMajorPerformanceCaveat: h,
								};
								if (
									(e.addEventListener("webglcontextlost", ut, !1),
									e.addEventListener("webglcontextrestored", dt, !1),
									null === st)
								) {
									const e = ["webgl2", "webgl", "experimental-webgl"];
									if (
										(!0 === d.isWebGL1Renderer && e.shift(),
										(st = ct(e, t)),
										null === st)
									)
										throw ct(e)
											? new Error(
													"Error creating WebGL context with your selected attributes."
											  )
											: new Error("Error creating WebGL context.");
								}
								void 0 === st.getShaderPrecisionFormat &&
									(st.getShaderPrecisionFormat = function () {
										return { rangeMin: 1, rangeMax: 1, precision: 1 };
									});
							} catch (t) {
								throw (console.error("THREE.WebGLRenderer: " + t.message), t);
							}
							function lt() {
								(D = new vs(st)),
									(A = new Ms(st, D, t)),
									!1 === A.isWebGL2 &&
										(D.get("WEBGL_depth_texture"),
										D.get("OES_texture_float"),
										D.get("OES_texture_half_float"),
										D.get("OES_texture_half_float_linear"),
										D.get("OES_standard_derivatives"),
										D.get("OES_element_index_uint"),
										D.get("OES_vertex_array_object"),
										D.get("ANGLE_instanced_arrays")),
									D.get("OES_texture_float_linear"),
									(ot = new dl(st, D, A)),
									(L = new pl(st, D, A)),
									L.scissor(v.copy(T).multiplyScalar(x).floor()),
									L.viewport(I.copy(K).multiplyScalar(x).floor()),
									(B = new ws(st)),
									(G = new Yc()),
									(Q = new ul(st, D, L, G, A, ot, B)),
									(_ = new ms(st, A)),
									(at = new qs(st, D, _, A)),
									(P = new ks(st, _, B, at)),
									(J = new Ks(st, P, _, B)),
									(nt = new bs(st)),
									(Y = new Jc(d, D, A, at)),
									(X = new yl(G)),
									($ = new el(G)),
									(tt = new sl()),
									(et = new Vs(d, L, J, s)),
									(it = new Rs(st, D, B, A)),
									(rt = new Us(st, D, B, A)),
									(B.programs = Y.programs),
									(d.capabilities = A),
									(d.extensions = D),
									(d.properties = G),
									(d.renderLists = $),
									(d.state = L),
									(d.info = B);
							}
							lt();
							const ht = new Sl(d, st);
							this.xr = ht;
							const pt = new hl(d, J, A.maxTextureSize);
							function ut(t) {
								t.preventDefault(),
									console.log("THREE.WebGLRenderer: Context Lost."),
									(m = !0);
							}
							function dt() {
								console.log("THREE.WebGLRenderer: Context Restored."),
									(m = !1),
									lt();
							}
							function mt(t) {
								const e = t.target;
								e.removeEventListener("dispose", mt),
									(function (t) {
										ft(t), G.remove(t);
									})(e);
							}
							function ft(t) {
								const e = G.get(t).program;
								void 0 !== e && Y.releaseProgram(e);
							}
							(this.shadowMap = pt),
								(this.getContext = function () {
									return st;
								}),
								(this.getContextAttributes = function () {
									return st.getContextAttributes();
								}),
								(this.forceContextLoss = function () {
									const t = D.get("WEBGL_lose_context");
									t && t.loseContext();
								}),
								(this.forceContextRestore = function () {
									const t = D.get("WEBGL_lose_context");
									t && t.restoreContext();
								}),
								(this.getPixelRatio = function () {
									return x;
								}),
								(this.setPixelRatio = function (t) {
									void 0 !== t && ((x = t), this.setSize(U, w, !1));
								}),
								(this.getSize = function (t) {
									return (
										void 0 === t &&
											(console.warn(
												"WebGLRenderer: .getsize() now requires a Vector2 as an argument"
											),
											(t = new Rr())),
										t.set(U, w)
									);
								}),
								(this.setSize = function (t, n, i) {
									ht.isPresenting
										? console.warn(
												"THREE.WebGLRenderer: Can't change size while VR device is presenting."
										  )
										: ((U = t),
										  (w = n),
										  (e.width = Math.floor(t * x)),
										  (e.height = Math.floor(n * x)),
										  !1 !== i &&
												((e.style.width = t + "px"),
												(e.style.height = n + "px")),
										  this.setViewport(0, 0, t, n));
								}),
								(this.getDrawingBufferSize = function (t) {
									return (
										void 0 === t &&
											(console.warn(
												"WebGLRenderer: .getdrawingBufferSize() now requires a Vector2 as an argument"
											),
											(t = new Rr())),
										t.set(U * x, w * x).floor()
									);
								}),
								(this.setDrawingBufferSize = function (t, n, i) {
									(U = t),
										(w = n),
										(x = i),
										(e.width = Math.floor(t * i)),
										(e.height = Math.floor(n * i)),
										this.setViewport(0, 0, t, n);
								}),
								(this.getCurrentViewport = function (t) {
									return (
										void 0 === t &&
											(console.warn(
												"WebGLRenderer: .getCurrentViewport() now requires a Vector4 as an argument"
											),
											(t = new wr())),
										t.copy(I)
									);
								}),
								(this.getViewport = function (t) {
									return t.copy(K);
								}),
								(this.setViewport = function (t, e, n, i) {
									t.isVector4 ? K.set(t.x, t.y, t.z, t.w) : K.set(t, e, n, i),
										L.viewport(I.copy(K).multiplyScalar(x).floor());
								}),
								(this.getScissor = function (t) {
									return t.copy(T);
								}),
								(this.setScissor = function (t, e, n, i) {
									t.isVector4 ? T.set(t.x, t.y, t.z, t.w) : T.set(t, e, n, i),
										L.scissor(v.copy(T).multiplyScalar(x).floor());
								}),
								(this.getScissorTest = function () {
									return z;
								}),
								(this.setScissorTest = function (t) {
									L.setScissorTest((z = t));
								}),
								(this.setOpaqueSort = function (t) {
									O = t;
								}),
								(this.setTransparentSort = function (t) {
									b = t;
								}),
								(this.getClearColor = function () {
									return et.getClearColor();
								}),
								(this.setClearColor = function () {
									et.setClearColor.apply(et, arguments);
								}),
								(this.getClearAlpha = function () {
									return et.getClearAlpha();
								}),
								(this.setClearAlpha = function () {
									et.setClearAlpha.apply(et, arguments);
								}),
								(this.clear = function (t, e, n) {
									let i = 0;
									(void 0 === t || t) && (i |= 16384),
										(void 0 === e || e) && (i |= 256),
										(void 0 === n || n) && (i |= 1024),
										st.clear(i);
								}),
								(this.clearColor = function () {
									this.clear(!0, !1, !1);
								}),
								(this.clearDepth = function () {
									this.clear(!1, !0, !1);
								}),
								(this.clearStencil = function () {
									this.clear(!1, !1, !0);
								}),
								(this.dispose = function () {
									e.removeEventListener("webglcontextlost", ut, !1),
										e.removeEventListener("webglcontextrestored", dt, !1),
										$.dispose(),
										tt.dispose(),
										G.dispose(),
										J.dispose(),
										at.dispose(),
										ht.dispose(),
										St.stop();
								}),
								(this.renderBufferImmediate = function (t, e) {
									at.initAttributes();
									const n = G.get(t);
									t.hasPositions &&
										!n.position &&
										(n.position = st.createBuffer()),
										t.hasNormals && !n.normal && (n.normal = st.createBuffer()),
										t.hasUvs && !n.uv && (n.uv = st.createBuffer()),
										t.hasColors && !n.color && (n.color = st.createBuffer());
									const i = e.getAttributes();
									t.hasPositions &&
										(st.bindBuffer(34962, n.position),
										st.bufferData(34962, t.positionArray, 35048),
										at.enableAttribute(i.position),
										st.vertexAttribPointer(i.position, 3, 5126, !1, 0, 0)),
										t.hasNormals &&
											(st.bindBuffer(34962, n.normal),
											st.bufferData(34962, t.normalArray, 35048),
											at.enableAttribute(i.normal),
											st.vertexAttribPointer(i.normal, 3, 5126, !1, 0, 0)),
										t.hasUvs &&
											(st.bindBuffer(34962, n.uv),
											st.bufferData(34962, t.uvArray, 35048),
											at.enableAttribute(i.uv),
											st.vertexAttribPointer(i.uv, 2, 5126, !1, 0, 0)),
										t.hasColors &&
											(st.bindBuffer(34962, n.color),
											st.bufferData(34962, t.colorArray, 35048),
											at.enableAttribute(i.color),
											st.vertexAttribPointer(i.color, 3, 5126, !1, 0, 0)),
										at.disableUnusedAttributes(),
										st.drawArrays(4, 0, t.count),
										(t.count = 0);
								}),
								(this.renderBufferDirect = function (t, e, n, i, r, o) {
									null === e && (e = N);
									const a = r.isMesh && r.matrixWorld.determinant() < 0,
										s = Mt(t, e, i, r);
									L.setMaterial(i, a);
									let c = n.index;
									const l = n.attributes.position;
									if (null === c) {
										if (void 0 === l || 0 === l.count) return;
									} else if (0 === c.count) return;
									let h,
										p = 1;
									!0 === i.wireframe &&
										((c = P.getWireframeAttribute(n)), (p = 2)),
										(i.morphTargets || i.morphNormals) && nt.update(r, n, i, s),
										at.setup(r, i, s, n, c);
									let u = it;
									null !== c && ((h = _.get(c)), (u = rt), u.setIndex(h));
									const d = null !== c ? c.count : l.count,
										m = n.drawRange.start * p,
										f = n.drawRange.count * p,
										g = null !== o ? o.start * p : 0,
										S = null !== o ? o.count * p : 1 / 0,
										y = Math.max(m, g),
										V = Math.min(d, m + f, g + S) - 1,
										q = Math.max(0, V - y + 1);
									if (0 !== q) {
										if (r.isMesh)
											!0 === i.wireframe
												? (L.setLineWidth(i.wireframeLinewidth * j()),
												  u.setMode(1))
												: u.setMode(4);
										else if (r.isLine) {
											let t = i.linewidth;
											void 0 === t && (t = 1),
												L.setLineWidth(t * j()),
												r.isLineSegments
													? u.setMode(1)
													: r.isLineLoop
													? u.setMode(2)
													: u.setMode(3);
										} else
											r.isPoints ? u.setMode(0) : r.isSprite && u.setMode(4);
										if (r.isInstancedMesh) u.renderInstances(y, q, r.count);
										else if (n.isInstancedBufferGeometry) {
											const t = Math.min(n.instanceCount, n._maxInstanceCount);
											u.renderInstances(y, q, t);
										} else u.render(y, q);
									}
								}),
								(this.compile = function (t, e) {
									(u = tt.get(t, e)),
										u.init(),
										t.traverse(function (t) {
											t.isLight &&
												(u.pushLight(t), t.castShadow && u.pushShadow(t));
										}),
										u.setupLights(e);
									const n = new WeakMap();
									t.traverse(function (e) {
										let i = e.material;
										if (i)
											if (Array.isArray(i))
												for (let r = 0; r < i.length; r++) {
													let o = i[r];
													!1 === n.has(o) && (Rt(o, t, e), n.set(o));
												}
											else !1 === n.has(i) && (Rt(i, t, e), n.set(i));
									});
								});
							let gt = null;
							const St = new ds();
							function yt(t, e, n, i) {
								if (!1 === t.visible) return;
								if (t.layers.test(e.layers))
									if (t.isGroup) n = t.renderOrder;
									else if (t.isLOD) !0 === t.autoUpdate && t.update(e);
									else if (t.isLight)
										u.pushLight(t), t.castShadow && u.pushShadow(t);
									else if (t.isSprite) {
										if (!t.frustumCulled || W.intersectsSprite(t)) {
											i &&
												H.setFromMatrixPosition(t.matrixWorld).applyMatrix4(Z);
											const e = J.update(t),
												r = t.material;
											r.visible && p.push(t, e, r, n, H.z, null);
										}
									} else if (t.isImmediateRenderObject)
										i && H.setFromMatrixPosition(t.matrixWorld).applyMatrix4(Z),
											p.push(t, null, t.material, n, H.z, null);
									else if (
										(t.isMesh || t.isLine || t.isPoints) &&
										(t.isSkinnedMesh &&
											t.skeleton.frame !== B.render.frame &&
											(t.skeleton.update(),
											(t.skeleton.frame = B.render.frame)),
										!t.frustumCulled || W.intersectsObject(t))
									) {
										i && H.setFromMatrixPosition(t.matrixWorld).applyMatrix4(Z);
										const e = J.update(t),
											r = t.material;
										if (Array.isArray(r)) {
											const i = e.groups;
											for (let o = 0, a = i.length; o < a; o++) {
												const a = i[o],
													s = r[a.materialIndex];
												s && s.visible && p.push(t, e, s, n, H.z, a);
											}
										} else r.visible && p.push(t, e, r, n, H.z, null);
									}
								const r = t.children;
								for (let t = 0, o = r.length; t < o; t++) yt(r[t], e, n, i);
							}
							function Vt(t, e, n) {
								const i = !0 === e.isScene ? e.overrideMaterial : null;
								for (let r = 0, o = t.length; r < o; r++) {
									const o = t[r],
										a = o.object,
										s = o.geometry,
										c = null === i ? o.material : i,
										l = o.group;
									if (n.isArrayCamera) {
										M = n;
										const t = n.cameras;
										for (let n = 0, i = t.length; n < i; n++) {
											const i = t[n];
											a.layers.test(i.layers) &&
												(L.viewport(I.copy(i.viewport)),
												u.setupLights(i),
												qt(a, e, i, s, c, l));
										}
									} else (M = null), qt(a, e, n, s, c, l);
								}
							}
							function qt(t, e, n, i, r, o) {
								if (
									(t.onBeforeRender(d, e, n, i, r, o),
									(u = tt.get(e, M || n)),
									t.modelViewMatrix.multiplyMatrices(
										n.matrixWorldInverse,
										t.matrixWorld
									),
									t.normalMatrix.getNormalMatrix(t.modelViewMatrix),
									t.isImmediateRenderObject)
								) {
									const i = Mt(n, e, r, t);
									L.setMaterial(r),
										at.reset(),
										(function (t, e) {
											t.render(function (t) {
												d.renderBufferImmediate(t, e);
											});
										})(t, i);
								} else d.renderBufferDirect(n, e, i, r, t, o);
								t.onAfterRender(d, e, n, i, r, o), (u = tt.get(e, M || n));
							}
							function Rt(t, e, n) {
								!0 !== e.isScene && (e = N);
								const i = G.get(t),
									r = u.state.lights,
									o = u.state.shadowsArray,
									a = r.state.version,
									s = Y.getParameters(
										t,
										r.state,
										o,
										e,
										E.numPlanes,
										E.numIntersection,
										n
									),
									c = Y.getProgramCacheKey(s);
								let l = i.program,
									h = !0;
								if (void 0 === l) t.addEventListener("dispose", mt);
								else if (l.cacheKey !== c) ft(t);
								else if (i.lightsStateVersion !== a)
									(i.lightsStateVersion = a), (h = !1);
								else {
									if (void 0 !== s.shaderID) return;
									h = !1;
								}
								h &&
									((s.uniforms = Y.getUniforms(t, s)),
									t.onBeforeCompile(s, d),
									(l = Y.acquireProgram(s, c)),
									(i.program = l),
									(i.uniforms = s.uniforms),
									(i.outputEncoding = s.outputEncoding));
								const p = l.getAttributes();
								if (t.morphTargets) {
									t.numSupportedMorphTargets = 0;
									for (let e = 0; e < d.maxMorphTargets; e++)
										p["morphTarget" + e] >= 0 && t.numSupportedMorphTargets++;
								}
								if (t.morphNormals) {
									t.numSupportedMorphNormals = 0;
									for (let e = 0; e < d.maxMorphNormals; e++)
										p["morphNormal" + e] >= 0 && t.numSupportedMorphNormals++;
								}
								const m = i.uniforms;
								((t.isShaderMaterial || t.isRawShaderMaterial) &&
									!0 !== t.clipping) ||
									((i.numClippingPlanes = E.numPlanes),
									(i.numIntersection = E.numIntersection),
									(m.clippingPlanes = E.uniform)),
									(i.environment = t.isMeshStandardMaterial
										? e.environment
										: null),
									(i.fog = e.fog),
									(i.needsLights = (function (t) {
										return (
											t.isMeshLambertMaterial ||
											t.isMeshToonMaterial ||
											t.isMeshPhongMaterial ||
											t.isMeshStandardMaterial ||
											t.isShadowMaterial ||
											(t.isShaderMaterial && !0 === t.lights)
										);
									})(t)),
									(i.lightsStateVersion = a),
									i.needsLights &&
										((m.ambientLightColor.value = r.state.ambient),
										(m.lightProbe.value = r.state.probe),
										(m.directionalLights.value = r.state.directional),
										(m.directionalLightShadows.value =
											r.state.directionalShadow),
										(m.spotLights.value = r.state.spot),
										(m.spotLightShadows.value = r.state.spotShadow),
										(m.rectAreaLights.value = r.state.rectArea),
										(m.pointLights.value = r.state.point),
										(m.pointLightShadows.value = r.state.pointShadow),
										(m.hemisphereLights.value = r.state.hemi),
										(m.directionalShadowMap.value =
											r.state.directionalShadowMap),
										(m.directionalShadowMatrix.value =
											r.state.directionalShadowMatrix),
										(m.spotShadowMap.value = r.state.spotShadowMap),
										(m.spotShadowMatrix.value = r.state.spotShadowMatrix),
										(m.pointShadowMap.value = r.state.pointShadowMap),
										(m.pointShadowMatrix.value = r.state.pointShadowMatrix));
								const f = i.program.getUniforms(),
									g = Oc.seqWithValue(f.seq, m);
								i.uniformsList = g;
							}
							function Mt(t, e, n, i) {
								!0 !== e.isScene && (e = N), Q.resetTextureUnits();
								const r = e.fog,
									o = n.isMeshStandardMaterial ? e.environment : null,
									a = null === y ? d.outputEncoding : y.texture.encoding,
									s = G.get(n),
									c = u.state.lights;
								if (!0 === C && (!0 === F || t !== R)) {
									const e = t === R && n.id === q;
									E.setState(
										n.clippingPlanes,
										n.clipIntersection,
										n.clipShadows,
										t,
										s,
										e
									);
								}
								n.version === s.__version
									? void 0 === s.program ||
									  (n.fog && s.fog !== r) ||
									  s.environment !== o ||
									  (s.needsLights && s.lightsStateVersion !== c.state.version)
										? Rt(n, e, i)
										: void 0 === s.numClippingPlanes ||
										  (s.numClippingPlanes === E.numPlanes &&
												s.numIntersection === E.numIntersection)
										? s.outputEncoding !== a && Rt(n, e, i)
										: Rt(n, e, i)
									: (Rt(n, e, i), (s.__version = n.version));
								let l = !1,
									h = !1,
									p = !1;
								const m = s.program,
									f = m.getUniforms(),
									g = s.uniforms;
								if (
									(L.useProgram(m.program) && ((l = !0), (h = !0), (p = !0)),
									n.id !== q && ((q = n.id), (h = !0)),
									l || R !== t)
								) {
									if (
										(f.setValue(st, "projectionMatrix", t.projectionMatrix),
										A.logarithmicDepthBuffer &&
											f.setValue(
												st,
												"logDepthBufFC",
												2 / (Math.log(t.far + 1) / Math.LN2)
											),
										R !== t && ((R = t), (h = !0), (p = !0)),
										n.isShaderMaterial ||
											n.isMeshPhongMaterial ||
											n.isMeshToonMaterial ||
											n.isMeshStandardMaterial ||
											n.envMap)
									) {
										const e = f.map.cameraPosition;
										void 0 !== e &&
											e.setValue(st, H.setFromMatrixPosition(t.matrixWorld));
									}
									(n.isMeshPhongMaterial ||
										n.isMeshToonMaterial ||
										n.isMeshLambertMaterial ||
										n.isMeshBasicMaterial ||
										n.isMeshStandardMaterial ||
										n.isShaderMaterial) &&
										f.setValue(
											st,
											"isOrthographic",
											!0 === t.isOrthographicCamera
										),
										(n.isMeshPhongMaterial ||
											n.isMeshToonMaterial ||
											n.isMeshLambertMaterial ||
											n.isMeshBasicMaterial ||
											n.isMeshStandardMaterial ||
											n.isShaderMaterial ||
											n.isShadowMaterial ||
											n.skinning) &&
											f.setValue(st, "viewMatrix", t.matrixWorldInverse);
								}
								if (n.skinning) {
									f.setOptional(st, i, "bindMatrix"),
										f.setOptional(st, i, "bindMatrixInverse");
									const t = i.skeleton;
									if (t) {
										const e = t.bones;
										if (A.floatVertexTextures) {
											if (void 0 === t.boneTexture) {
												let n = Math.sqrt(4 * e.length);
												(n = qr.ceilPowerOfTwo(n)), (n = Math.max(n, 4));
												const i = new Float32Array(n * n * 4);
												i.set(t.boneMatrices);
												const r = new cs(i, n, n, tr, Ji);
												(t.boneMatrices = i),
													(t.boneTexture = r),
													(t.boneTextureSize = n);
											}
											f.setValue(st, "boneTexture", t.boneTexture, Q),
												f.setValue(st, "boneTextureSize", t.boneTextureSize);
										} else f.setOptional(st, t, "boneMatrices");
									}
								}
								var S, V;
								return (
									(h || s.receiveShadow !== i.receiveShadow) &&
										((s.receiveShadow = i.receiveShadow),
										f.setValue(st, "receiveShadow", i.receiveShadow)),
									h &&
										(f.setValue(
											st,
											"toneMappingExposure",
											d.toneMappingExposure
										),
										s.needsLights &&
											((V = p),
											((S = g).ambientLightColor.needsUpdate = V),
											(S.lightProbe.needsUpdate = V),
											(S.directionalLights.needsUpdate = V),
											(S.directionalLightShadows.needsUpdate = V),
											(S.pointLights.needsUpdate = V),
											(S.pointLightShadows.needsUpdate = V),
											(S.spotLights.needsUpdate = V),
											(S.spotLightShadows.needsUpdate = V),
											(S.rectAreaLights.needsUpdate = V),
											(S.hemisphereLights.needsUpdate = V)),
										r && n.fog && X.refreshFogUniforms(g, r),
										X.refreshMaterialUniforms(g, n, o, x, w),
										void 0 !== g.ltc_1 && (g.ltc_1.value = us.LTC_1),
										void 0 !== g.ltc_2 && (g.ltc_2.value = us.LTC_2),
										Oc.upload(st, s.uniformsList, g, Q)),
									n.isShaderMaterial &&
										!0 === n.uniformsNeedUpdate &&
										(Oc.upload(st, s.uniformsList, g, Q),
										(n.uniformsNeedUpdate = !1)),
									n.isSpriteMaterial && f.setValue(st, "center", i.center),
									f.setValue(st, "modelViewMatrix", i.modelViewMatrix),
									f.setValue(st, "normalMatrix", i.normalMatrix),
									f.setValue(st, "modelMatrix", i.matrixWorld),
									m
								);
							}
							St.setAnimationLoop(function (t) {
								ht.isPresenting || (gt && gt(t));
							}),
								"undefined" != typeof window && St.setContext(window),
								(this.setAnimationLoop = function (t) {
									(gt = t),
										ht.setAnimationLoop(t),
										null === t ? St.stop() : St.start();
								}),
								(this.render = function (t, e) {
									let n, i;
									if (
										(void 0 !== arguments[2] &&
											(console.warn(
												"THREE.WebGLRenderer.render(): the renderTarget argument has been removed. Use .setRenderTarget() instead."
											),
											(n = arguments[2])),
										void 0 !== arguments[3] &&
											(console.warn(
												"THREE.WebGLRenderer.render(): the forceClear argument has been removed. Use .clear() instead."
											),
											(i = arguments[3])),
										void 0 !== e && !0 !== e.isCamera)
									)
										return void console.error(
											"THREE.WebGLRenderer.render: camera is not an instance of THREE.Camera."
										);
									if (!0 === m) return;
									at.resetDefaultState(),
										(q = -1),
										(R = null),
										!0 === t.autoUpdate && t.updateMatrixWorld(),
										null === e.parent && e.updateMatrixWorld(),
										!0 === ht.enabled &&
											!0 === ht.isPresenting &&
											(e = ht.getCamera(e)),
										!0 === t.isScene && t.onBeforeRender(d, t, e, n || y),
										(u = tt.get(t, e)),
										u.init(),
										Z.multiplyMatrices(
											e.projectionMatrix,
											e.matrixWorldInverse
										),
										W.setFromProjectionMatrix(Z),
										(F = this.localClippingEnabled),
										(C = E.init(this.clippingPlanes, F, e)),
										(p = $.get(t, e)),
										p.init(),
										yt(t, e, 0, d.sortObjects),
										p.finish(),
										!0 === d.sortObjects && p.sort(O, b),
										!0 === C && E.beginShadows();
									const r = u.state.shadowsArray;
									pt.render(r, t, e),
										u.setupLights(e),
										!0 === C && E.endShadows(),
										!0 === this.info.autoReset && this.info.reset(),
										void 0 !== n && this.setRenderTarget(n),
										et.render(p, t, e, i);
									const o = p.opaque,
										a = p.transparent;
									o.length > 0 && Vt(o, t, e),
										a.length > 0 && Vt(a, t, e),
										!0 === t.isScene && t.onAfterRender(d, t, e),
										null !== y &&
											(Q.updateRenderTargetMipmap(y),
											Q.updateMultisampleRenderTarget(y)),
										L.buffers.depth.setTest(!0),
										L.buffers.depth.setMask(!0),
										L.buffers.color.setMask(!0),
										L.setPolygonOffset(!1),
										(p = null),
										(u = null);
								}),
								(this.setFramebuffer = function (t) {
									f !== t && null === y && st.bindFramebuffer(36160, t),
										(f = t);
								}),
								(this.getActiveCubeFace = function () {
									return g;
								}),
								(this.getActiveMipmapLevel = function () {
									return S;
								}),
								(this.getRenderTarget = function () {
									return y;
								}),
								(this.setRenderTarget = function (t, e, n) {
									(y = t),
										(g = e),
										(S = n),
										t &&
											void 0 === G.get(t).__webglFramebuffer &&
											Q.setupRenderTarget(t);
									let i = f,
										r = !1;
									if (t) {
										const n = G.get(t).__webglFramebuffer;
										t.isWebGLCubeRenderTarget
											? ((i = n[e || 0]), (r = !0))
											: (i = t.isWebGLMultisampleRenderTarget
													? G.get(t).__webglMultisampledFramebuffer
													: n),
											I.copy(t.viewport),
											v.copy(t.scissor),
											(k = t.scissorTest);
									} else
										I.copy(K).multiplyScalar(x).floor(),
											v.copy(T).multiplyScalar(x).floor(),
											(k = z);
									if (
										(V !== i && (st.bindFramebuffer(36160, i), (V = i)),
										L.viewport(I),
										L.scissor(v),
										L.setScissorTest(k),
										r)
									) {
										const i = G.get(t.texture);
										st.framebufferTexture2D(
											36160,
											36064,
											34069 + (e || 0),
											i.__webglTexture,
											n || 0
										);
									}
								}),
								(this.readRenderTargetPixels = function (t, e, n, i, r, o, a) {
									if (!t || !t.isWebGLRenderTarget)
										return void console.error(
											"THREE.WebGLRenderer.readRenderTargetPixels: renderTarget is not THREE.WebGLRenderTarget."
										);
									let s = G.get(t).__webglFramebuffer;
									if (
										(t.isWebGLCubeRenderTarget && void 0 !== a && (s = s[a]), s)
									) {
										let a = !1;
										s !== V && (st.bindFramebuffer(36160, s), (a = !0));
										try {
											const s = t.texture,
												c = s.format,
												l = s.type;
											if (c !== tr && ot.convert(c) !== st.getParameter(35739))
												return void console.error(
													"THREE.WebGLRenderer.readRenderTargetPixels: renderTarget is not in RGBA or implementation defined format."
												);
											if (
												!(
													l === Qi ||
													ot.convert(l) === st.getParameter(35738) ||
													(l === Ji &&
														(A.isWebGL2 ||
															D.get("OES_texture_float") ||
															D.get("WEBGL_color_buffer_float"))) ||
													(l === Yi &&
														(A.isWebGL2
															? D.get("EXT_color_buffer_float")
															: D.get("EXT_color_buffer_half_float")))
												)
											)
												return void console.error(
													"THREE.WebGLRenderer.readRenderTargetPixels: renderTarget is not in UnsignedByteType or implementation defined type."
												);
											36053 === st.checkFramebufferStatus(36160)
												? e >= 0 &&
												  e <= t.width - i &&
												  n >= 0 &&
												  n <= t.height - r &&
												  st.readPixels(
														e,
														n,
														i,
														r,
														ot.convert(c),
														ot.convert(l),
														o
												  )
												: console.error(
														"THREE.WebGLRenderer.readRenderTargetPixels: readPixels from renderTarget failed. Framebuffer not complete."
												  );
										} finally {
											a && st.bindFramebuffer(36160, V);
										}
									}
								}),
								(this.copyFramebufferToTexture = function (t, e, n) {
									void 0 === n && (n = 0);
									const i = Math.pow(2, -n),
										r = Math.floor(e.image.width * i),
										o = Math.floor(e.image.height * i),
										a = ot.convert(e.format);
									Q.setTexture2D(e, 0),
										st.copyTexImage2D(3553, n, a, t.x, t.y, r, o, 0),
										L.unbindTexture();
								}),
								(this.copyTextureToTexture = function (t, e, n, i) {
									void 0 === i && (i = 0);
									const r = e.image.width,
										o = e.image.height,
										a = ot.convert(n.format),
										s = ot.convert(n.type);
									Q.setTexture2D(n, 0),
										st.pixelStorei(37440, n.flipY),
										st.pixelStorei(37441, n.premultiplyAlpha),
										st.pixelStorei(3317, n.unpackAlignment),
										e.isDataTexture
											? st.texSubImage2D(
													3553,
													i,
													t.x,
													t.y,
													r,
													o,
													a,
													s,
													e.image.data
											  )
											: e.isCompressedTexture
											? st.compressedTexSubImage2D(
													3553,
													i,
													t.x,
													t.y,
													e.mipmaps[0].width,
													e.mipmaps[0].height,
													a,
													e.mipmaps[0].data
											  )
											: st.texSubImage2D(3553, i, t.x, t.y, a, s, e.image),
										0 === i && n.generateMipmaps && st.generateMipmap(3553),
										L.unbindTexture();
								}),
								(this.initTexture = function (t) {
									Q.setTexture2D(t, 0), L.unbindTexture();
								}),
								"undefined" != typeof __THREE_DEVTOOLS__ &&
									__THREE_DEVTOOLS__.dispatchEvent(
										new CustomEvent("observe", { detail: this })
									);
						}
						function ql(t) {
							Vl.call(this, t);
						}
						function Rl(t, e) {
							(this.name = ""),
								(this.color = new Yo(t)),
								(this.density = void 0 !== e ? e : 25e-5);
						}
						function Ml(t, e, n) {
							(this.name = ""),
								(this.color = new Yo(t)),
								(this.near = void 0 !== e ? e : 1),
								(this.far = void 0 !== n ? n : 1e3);
						}
						function Il(t, e) {
							(this.array = t),
								(this.stride = e),
								(this.count = void 0 !== t ? t.length / e : 0),
								(this.usage = fr),
								(this.updateRange = { offset: 0, count: -1 }),
								(this.version = 0),
								(this.uuid = qr.generateUUID());
						}
						(cl.prototype = Object.create(ia.prototype)),
							(cl.prototype.constructor = cl),
							(cl.prototype.isMeshDepthMaterial = !0),
							(cl.prototype.copy = function (t) {
								return (
									ia.prototype.copy.call(this, t),
									(this.depthPacking = t.depthPacking),
									(this.skinning = t.skinning),
									(this.morphTargets = t.morphTargets),
									(this.map = t.map),
									(this.alphaMap = t.alphaMap),
									(this.displacementMap = t.displacementMap),
									(this.displacementScale = t.displacementScale),
									(this.displacementBias = t.displacementBias),
									(this.wireframe = t.wireframe),
									(this.wireframeLinewidth = t.wireframeLinewidth),
									this
								);
							}),
							(ll.prototype = Object.create(ia.prototype)),
							(ll.prototype.constructor = ll),
							(ll.prototype.isMeshDistanceMaterial = !0),
							(ll.prototype.copy = function (t) {
								return (
									ia.prototype.copy.call(this, t),
									this.referencePosition.copy(t.referencePosition),
									(this.nearDistance = t.nearDistance),
									(this.farDistance = t.farDistance),
									(this.skinning = t.skinning),
									(this.morphTargets = t.morphTargets),
									(this.map = t.map),
									(this.alphaMap = t.alphaMap),
									(this.displacementMap = t.displacementMap),
									(this.displacementScale = t.displacementScale),
									(this.displacementBias = t.displacementBias),
									this
								);
							}),
							(ml.prototype = Object.assign(Object.create(rs.prototype), {
								constructor: ml,
								isArrayCamera: !0,
							})),
							(fl.prototype = Object.assign(Object.create(oo.prototype), {
								constructor: fl,
								isGroup: !0,
							})),
							Object.assign(gl.prototype, {
								constructor: gl,
								getHandSpace: function () {
									if (
										null === this._hand &&
										((this._hand = new fl()),
										(this._hand.matrixAutoUpdate = !1),
										(this._hand.visible = !1),
										(this._hand.joints = []),
										(this._hand.inputState = { pinching: !1 }),
										window.XRHand)
									)
										for (
											let t = 0;
											t <= window.XRHand.LITTLE_PHALANX_TIP;
											t++
										) {
											let t = new fl();
											(t.matrixAutoUpdate = !1),
												(t.visible = !1),
												this._hand.joints.push(t),
												this._hand.add(t);
										}
									return this._hand;
								},
								getTargetRaySpace: function () {
									return (
										null === this._targetRay &&
											((this._targetRay = new fl()),
											(this._targetRay.matrixAutoUpdate = !1),
											(this._targetRay.visible = !1)),
										this._targetRay
									);
								},
								getGripSpace: function () {
									return (
										null === this._grip &&
											((this._grip = new fl()),
											(this._grip.matrixAutoUpdate = !1),
											(this._grip.visible = !1)),
										this._grip
									);
								},
								dispatchEvent: function (t) {
									return (
										null !== this._targetRay &&
											this._targetRay.dispatchEvent(t),
										null !== this._grip && this._grip.dispatchEvent(t),
										null !== this._hand && this._hand.dispatchEvent(t),
										this
									);
								},
								disconnect: function (t) {
									return (
										this.dispatchEvent({ type: "disconnected", data: t }),
										null !== this._targetRay && (this._targetRay.visible = !1),
										null !== this._grip && (this._grip.visible = !1),
										null !== this._hand && (this._hand.visible = !1),
										this
									);
								},
								update: function (t, e, n) {
									let i = null,
										r = null,
										o = null;
									const a = this._targetRay,
										s = this._grip,
										c = this._hand;
									if (t)
										if (t.hand) {
											o = !0;
											for (
												let i = 0;
												i <= window.XRHand.LITTLE_PHALANX_TIP;
												i++
											)
												if (t.hand[i]) {
													let r = e.getJointPose(t.hand[i], n);
													const o = c.joints[i];
													null !== r &&
														(o.matrix.fromArray(r.transform.matrix),
														o.matrix.decompose(o.position, o.rotation, o.scale),
														(o.jointRadius = r.radius)),
														(o.visible = null !== r);
													const a = c.joints[window.XRHand.INDEX_PHALANX_TIP],
														s = c.joints[window.XRHand.THUMB_PHALANX_TIP],
														l = a.position.distanceTo(s.position),
														h = 0.02,
														p = 0.005;
													c.inputState.pinching && l > h + p
														? ((c.inputState.pinching = !1),
														  this.dispatchEvent({
																type: "pinchend",
																handedness: t.handedness,
																target: this,
														  }))
														: !c.inputState.pinching &&
														  l <= h - p &&
														  ((c.inputState.pinching = !0),
														  this.dispatchEvent({
																type: "pinchstart",
																handedness: t.handedness,
																target: this,
														  }));
												}
										} else
											null !== a &&
												((i = e.getPose(t.targetRaySpace, n)),
												null !== i &&
													(a.matrix.fromArray(i.transform.matrix),
													a.matrix.decompose(a.position, a.rotation, a.scale))),
												null !== s &&
													t.gripSpace &&
													((r = e.getPose(t.gripSpace, n)),
													null !== r &&
														(s.matrix.fromArray(r.transform.matrix),
														s.matrix.decompose(
															s.position,
															s.rotation,
															s.scale
														)));
									return (
										null !== a && (a.visible = null !== i),
										null !== s && (s.visible = null !== r),
										null !== c && (c.visible = null !== o),
										this
									);
								},
							}),
							Object.assign(Sl.prototype, Sr.prototype),
							(ql.prototype = Object.assign(Object.create(Vl.prototype), {
								constructor: ql,
								isWebGL1Renderer: !0,
							})),
							Object.assign(Rl.prototype, {
								isFogExp2: !0,
								clone: function () {
									return new Rl(this.color, this.density);
								},
								toJSON: function () {
									return {
										type: "FogExp2",
										color: this.color.getHex(),
										density: this.density,
									};
								},
							}),
							Object.assign(Ml.prototype, {
								isFog: !0,
								clone: function () {
									return new Ml(this.color, this.near, this.far);
								},
								toJSON: function () {
									return {
										type: "Fog",
										color: this.color.getHex(),
										near: this.near,
										far: this.far,
									};
								},
							}),
							Object.defineProperty(Il.prototype, "needsUpdate", {
								set: function (t) {
									!0 === t && this.version++;
								},
							}),
							Object.assign(Il.prototype, {
								isInterleavedBuffer: !0,
								onUploadCallback: function () {},
								setUsage: function (t) {
									return (this.usage = t), this;
								},
								copy: function (t) {
									return (
										(this.array = new t.array.constructor(t.array)),
										(this.count = t.count),
										(this.stride = t.stride),
										(this.usage = t.usage),
										this
									);
								},
								copyAt: function (t, e, n) {
									(t *= this.stride), (n *= e.stride);
									for (let i = 0, r = this.stride; i < r; i++)
										this.array[t + i] = e.array[n + i];
									return this;
								},
								set: function (t, e) {
									return void 0 === e && (e = 0), this.array.set(t, e), this;
								},
								clone: function (t) {
									void 0 === t.arrayBuffers && (t.arrayBuffers = {}),
										void 0 === this.array.buffer._uuid &&
											(this.array.buffer._uuid = qr.generateUUID()),
										void 0 === t.arrayBuffers[this.array.buffer._uuid] &&
											(t.arrayBuffers[this.array.buffer._uuid] =
												this.array.slice(0).buffer);
									const e = new Il(
										new this.array.constructor(
											t.arrayBuffers[this.array.buffer._uuid]
										),
										this.stride
									);
									return e.setUsage(this.usage), e;
								},
								onUpload: function (t) {
									return (this.onUploadCallback = t), this;
								},
								toJSON: function (t) {
									return (
										void 0 === t.arrayBuffers && (t.arrayBuffers = {}),
										void 0 === this.array.buffer._uuid &&
											(this.array.buffer._uuid = qr.generateUUID()),
										void 0 === t.arrayBuffers[this.array.buffer._uuid] &&
											(t.arrayBuffers[this.array.buffer._uuid] =
												Array.prototype.slice.call(
													new Uint32Array(this.array.buffer)
												)),
										{
											uuid: this.uuid,
											buffer: this.array.buffer._uuid,
											type: this.array.constructor.name,
											stride: this.stride,
										}
									);
								},
							});
						const vl = new zr();
						function kl(t, e, n, i) {
							(this.name = ""),
								(this.data = t),
								(this.itemSize = e),
								(this.offset = n),
								(this.normalized = !0 === i);
						}
						function Ul(t) {
							ia.call(this),
								(this.type = "SpriteMaterial"),
								(this.color = new Yo(16777215)),
								(this.map = null),
								(this.alphaMap = null),
								(this.rotation = 0),
								(this.sizeAttenuation = !0),
								(this.transparent = !0),
								this.setValues(t);
						}
						let wl;
						Object.defineProperties(kl.prototype, {
							count: {
								get: function () {
									return this.data.count;
								},
							},
							array: {
								get: function () {
									return this.data.array;
								},
							},
							needsUpdate: {
								set: function (t) {
									this.data.needsUpdate = t;
								},
							},
						}),
							Object.assign(kl.prototype, {
								isInterleavedBufferAttribute: !0,
								applyMatrix4: function (t) {
									for (let e = 0, n = this.data.count; e < n; e++)
										(vl.x = this.getX(e)),
											(vl.y = this.getY(e)),
											(vl.z = this.getZ(e)),
											vl.applyMatrix4(t),
											this.setXYZ(e, vl.x, vl.y, vl.z);
									return this;
								},
								setX: function (t, e) {
									return (
										(this.data.array[t * this.data.stride + this.offset] = e),
										this
									);
								},
								setY: function (t, e) {
									return (
										(this.data.array[t * this.data.stride + this.offset + 1] =
											e),
										this
									);
								},
								setZ: function (t, e) {
									return (
										(this.data.array[t * this.data.stride + this.offset + 2] =
											e),
										this
									);
								},
								setW: function (t, e) {
									return (
										(this.data.array[t * this.data.stride + this.offset + 3] =
											e),
										this
									);
								},
								getX: function (t) {
									return this.data.array[t * this.data.stride + this.offset];
								},
								getY: function (t) {
									return this.data.array[
										t * this.data.stride + this.offset + 1
									];
								},
								getZ: function (t) {
									return this.data.array[
										t * this.data.stride + this.offset + 2
									];
								},
								getW: function (t) {
									return this.data.array[
										t * this.data.stride + this.offset + 3
									];
								},
								setXY: function (t, e, n) {
									return (
										(t = t * this.data.stride + this.offset),
										(this.data.array[t + 0] = e),
										(this.data.array[t + 1] = n),
										this
									);
								},
								setXYZ: function (t, e, n, i) {
									return (
										(t = t * this.data.stride + this.offset),
										(this.data.array[t + 0] = e),
										(this.data.array[t + 1] = n),
										(this.data.array[t + 2] = i),
										this
									);
								},
								setXYZW: function (t, e, n, i, r) {
									return (
										(t = t * this.data.stride + this.offset),
										(this.data.array[t + 0] = e),
										(this.data.array[t + 1] = n),
										(this.data.array[t + 2] = i),
										(this.data.array[t + 3] = r),
										this
									);
								},
								clone: function (t) {
									if (void 0 === t) {
										console.log(
											"THREE.InterleavedBufferAttribute.clone(): Cloning an interlaved buffer attribute will deinterleave buffer data."
										);
										const t = [];
										for (let e = 0; e < this.count; e++) {
											const n = e * this.data.stride + this.offset;
											for (let e = 0; e < this.itemSize; e++)
												t.push(this.data.array[n + e]);
										}
										return new sa(
											new this.array.constructor(t),
											this.itemSize,
											this.normalized
										);
									}
									return (
										void 0 === t.interleavedBuffers &&
											(t.interleavedBuffers = {}),
										void 0 === t.interleavedBuffers[this.data.uuid] &&
											(t.interleavedBuffers[this.data.uuid] =
												this.data.clone(t)),
										new kl(
											t.interleavedBuffers[this.data.uuid],
											this.itemSize,
											this.offset,
											this.normalized
										)
									);
								},
								toJSON: function (t) {
									if (void 0 === t) {
										console.log(
											"THREE.InterleavedBufferAttribute.toJSON(): Serializing an interlaved buffer attribute will deinterleave buffer data."
										);
										const t = [];
										for (let e = 0; e < this.count; e++) {
											const n = e * this.data.stride + this.offset;
											for (let e = 0; e < this.itemSize; e++)
												t.push(this.data.array[n + e]);
										}
										return {
											itemSize: this.itemSize,
											type: this.array.constructor.name,
											array: t,
											normalized: this.normalized,
										};
									}
									return (
										void 0 === t.interleavedBuffers &&
											(t.interleavedBuffers = {}),
										void 0 === t.interleavedBuffers[this.data.uuid] &&
											(t.interleavedBuffers[this.data.uuid] =
												this.data.toJSON(t)),
										{
											isInterleavedBufferAttribute: !0,
											itemSize: this.itemSize,
											data: this.data.uuid,
											offset: this.offset,
											normalized: this.normalized,
										}
									);
								},
							}),
							(Ul.prototype = Object.create(ia.prototype)),
							(Ul.prototype.constructor = Ul),
							(Ul.prototype.isSpriteMaterial = !0),
							(Ul.prototype.copy = function (t) {
								return (
									ia.prototype.copy.call(this, t),
									this.color.copy(t.color),
									(this.map = t.map),
									(this.alphaMap = t.alphaMap),
									(this.rotation = t.rotation),
									(this.sizeAttenuation = t.sizeAttenuation),
									this
								);
							});
						const xl = new zr(),
							Ol = new zr(),
							bl = new zr(),
							Kl = new Rr(),
							Tl = new Rr(),
							zl = new jr(),
							Wl = new zr(),
							El = new zr(),
							Cl = new zr(),
							Fl = new Rr(),
							Zl = new Rr(),
							Hl = new Rr();
						function Nl(t) {
							if ((oo.call(this), (this.type = "Sprite"), void 0 === wl)) {
								wl = new Ua();
								const t = new Il(
									new Float32Array([
										-0.5, -0.5, 0, 0, 0, 0.5, -0.5, 0, 1, 0, 0.5, 0.5, 0, 1, 1,
										-0.5, 0.5, 0, 0, 1,
									]),
									5
								);
								wl.setIndex([0, 1, 2, 0, 2, 3]),
									wl.setAttribute("position", new kl(t, 3, 0, !1)),
									wl.setAttribute("uv", new kl(t, 2, 3, !1));
							}
							(this.geometry = wl),
								(this.material = void 0 !== t ? t : new Ul()),
								(this.center = new Rr(0.5, 0.5));
						}
						function jl(t, e, n, i, r, o) {
							Kl.subVectors(t, n).addScalar(0.5).multiply(i),
								void 0 !== r
									? ((Tl.x = o * Kl.x - r * Kl.y), (Tl.y = r * Kl.x + o * Kl.y))
									: Tl.copy(Kl),
								t.copy(e),
								(t.x += Tl.x),
								(t.y += Tl.y),
								t.applyMatrix4(zl);
						}
						Nl.prototype = Object.assign(Object.create(oo.prototype), {
							constructor: Nl,
							isSprite: !0,
							raycast: function (t, e) {
								null === t.camera &&
									console.error(
										'THREE.Sprite: "Raycaster.camera" needs to be set in order to raycast against sprites.'
									),
									Ol.setFromMatrixScale(this.matrixWorld),
									zl.copy(t.camera.matrixWorld),
									this.modelViewMatrix.multiplyMatrices(
										t.camera.matrixWorldInverse,
										this.matrixWorld
									),
									bl.setFromMatrixPosition(this.modelViewMatrix),
									t.camera.isPerspectiveCamera &&
										!1 === this.material.sizeAttenuation &&
										Ol.multiplyScalar(-bl.z);
								const n = this.material.rotation;
								let i, r;
								0 !== n && ((r = Math.cos(n)), (i = Math.sin(n)));
								const o = this.center;
								jl(Wl.set(-0.5, -0.5, 0), bl, o, Ol, i, r),
									jl(El.set(0.5, -0.5, 0), bl, o, Ol, i, r),
									jl(Cl.set(0.5, 0.5, 0), bl, o, Ol, i, r),
									Fl.set(0, 0),
									Zl.set(1, 0),
									Hl.set(1, 1);
								let a = t.ray.intersectTriangle(Wl, El, Cl, !1, xl);
								if (
									null === a &&
									(jl(El.set(-0.5, 0.5, 0), bl, o, Ol, i, r),
									Zl.set(0, 1),
									(a = t.ray.intersectTriangle(Wl, Cl, El, !1, xl)),
									null === a)
								)
									return;
								const s = t.ray.origin.distanceTo(xl);
								s < t.near ||
									s > t.far ||
									e.push({
										distance: s,
										point: xl.clone(),
										uv: Qo.getUV(xl, Wl, El, Cl, Fl, Zl, Hl, new Rr()),
										face: null,
										object: this,
									});
							},
							copy: function (t) {
								return (
									oo.prototype.copy.call(this, t),
									void 0 !== t.center && this.center.copy(t.center),
									(this.material = t.material),
									this
								);
							},
						});
						const Dl = new zr(),
							Al = new zr();
						function Ll() {
							oo.call(this),
								(this._currentLevel = 0),
								(this.type = "LOD"),
								Object.defineProperties(this, {
									levels: { enumerable: !0, value: [] },
								}),
								(this.autoUpdate = !0);
						}
						function Bl(t, e) {
							t &&
								t.isGeometry &&
								console.error(
									"THREE.SkinnedMesh no longer supports THREE.Geometry. Use THREE.BufferGeometry instead."
								),
								La.call(this, t, e),
								(this.type = "SkinnedMesh"),
								(this.bindMode = "attached"),
								(this.bindMatrix = new jr()),
								(this.bindMatrixInverse = new jr());
						}
						(Ll.prototype = Object.assign(Object.create(oo.prototype), {
							constructor: Ll,
							isLOD: !0,
							copy: function (t) {
								oo.prototype.copy.call(this, t, !1);
								const e = t.levels;
								for (let t = 0, n = e.length; t < n; t++) {
									const n = e[t];
									this.addLevel(n.object.clone(), n.distance);
								}
								return (this.autoUpdate = t.autoUpdate), this;
							},
							addLevel: function (t, e) {
								void 0 === e && (e = 0), (e = Math.abs(e));
								const n = this.levels;
								let i;
								for (i = 0; i < n.length && !(e < n[i].distance); i++);
								return (
									n.splice(i, 0, { distance: e, object: t }), this.add(t), this
								);
							},
							getCurrentLevel: function () {
								return this._currentLevel;
							},
							getObjectForDistance: function (t) {
								const e = this.levels;
								if (e.length > 0) {
									let n, i;
									for (n = 1, i = e.length; n < i && !(t < e[n].distance); n++);
									return e[n - 1].object;
								}
								return null;
							},
							raycast: function (t, e) {
								if (this.levels.length > 0) {
									Dl.setFromMatrixPosition(this.matrixWorld);
									const n = t.ray.origin.distanceTo(Dl);
									this.getObjectForDistance(n).raycast(t, e);
								}
							},
							update: function (t) {
								const e = this.levels;
								if (e.length > 1) {
									Dl.setFromMatrixPosition(t.matrixWorld),
										Al.setFromMatrixPosition(this.matrixWorld);
									const n = Dl.distanceTo(Al) / t.zoom;
									let i, r;
									for (
										e[0].object.visible = !0, i = 1, r = e.length;
										i < r && n >= e[i].distance;
										i++
									)
										(e[i - 1].object.visible = !1), (e[i].object.visible = !0);
									for (this._currentLevel = i - 1; i < r; i++)
										e[i].object.visible = !1;
								}
							},
							toJSON: function (t) {
								const e = oo.prototype.toJSON.call(this, t);
								!1 === this.autoUpdate && (e.object.autoUpdate = !1),
									(e.object.levels = []);
								const n = this.levels;
								for (let t = 0, i = n.length; t < i; t++) {
									const i = n[t];
									e.object.levels.push({
										object: i.object.uuid,
										distance: i.distance,
									});
								}
								return e;
							},
						})),
							(Bl.prototype = Object.assign(Object.create(La.prototype), {
								constructor: Bl,
								isSkinnedMesh: !0,
								copy: function (t) {
									return (
										La.prototype.copy.call(this, t),
										(this.bindMode = t.bindMode),
										this.bindMatrix.copy(t.bindMatrix),
										this.bindMatrixInverse.copy(t.bindMatrixInverse),
										(this.skeleton = t.skeleton),
										this
									);
								},
								bind: function (t, e) {
									(this.skeleton = t),
										void 0 === e &&
											(this.updateMatrixWorld(!0),
											this.skeleton.calculateInverses(),
											(e = this.matrixWorld)),
										this.bindMatrix.copy(e),
										this.bindMatrixInverse.getInverse(e);
								},
								pose: function () {
									this.skeleton.pose();
								},
								normalizeSkinWeights: function () {
									const t = new wr(),
										e = this.geometry.attributes.skinWeight;
									for (let n = 0, i = e.count; n < i; n++) {
										(t.x = e.getX(n)),
											(t.y = e.getY(n)),
											(t.z = e.getZ(n)),
											(t.w = e.getW(n));
										const i = 1 / t.manhattanLength();
										i !== 1 / 0 ? t.multiplyScalar(i) : t.set(1, 0, 0, 0),
											e.setXYZW(n, t.x, t.y, t.z, t.w);
									}
								},
								updateMatrixWorld: function (t) {
									La.prototype.updateMatrixWorld.call(this, t),
										"attached" === this.bindMode
											? this.bindMatrixInverse.getInverse(this.matrixWorld)
											: "detached" === this.bindMode
											? this.bindMatrixInverse.getInverse(this.bindMatrix)
											: console.warn(
													"THREE.SkinnedMesh: Unrecognized bindMode: " +
														this.bindMode
											  );
								},
								boneTransform: (function () {
									const t = new zr(),
										e = new wr(),
										n = new wr(),
										i = new zr(),
										r = new jr();
									return function (o, a) {
										const s = this.skeleton,
											c = this.geometry;
										e.fromBufferAttribute(c.attributes.skinIndex, o),
											n.fromBufferAttribute(c.attributes.skinWeight, o),
											t
												.fromBufferAttribute(c.attributes.position, o)
												.applyMatrix4(this.bindMatrix),
											a.set(0, 0, 0);
										for (let o = 0; o < 4; o++) {
											const c = n.getComponent(o);
											if (0 !== c) {
												const n = e.getComponent(o);
												r.multiplyMatrices(
													s.bones[n].matrixWorld,
													s.boneInverses[n]
												),
													a.addScaledVector(i.copy(t).applyMatrix4(r), c);
											}
										}
										return a.applyMatrix4(this.bindMatrixInverse);
									};
								})(),
							}));
						const Gl = new jr(),
							Ql = new jr();
						function _l(t, e) {
							if (
								((t = t || []),
								(this.bones = t.slice(0)),
								(this.boneMatrices = new Float32Array(16 * this.bones.length)),
								(this.frame = -1),
								void 0 === e)
							)
								this.calculateInverses();
							else if (this.bones.length === e.length)
								this.boneInverses = e.slice(0);
							else {
								console.warn(
									"THREE.Skeleton boneInverses is the wrong length."
								),
									(this.boneInverses = []);
								for (let t = 0, e = this.bones.length; t < e; t++)
									this.boneInverses.push(new jr());
							}
						}
						function Pl() {
							oo.call(this), (this.type = "Bone");
						}
						Object.assign(_l.prototype, {
							calculateInverses: function () {
								this.boneInverses = [];
								for (let t = 0, e = this.bones.length; t < e; t++) {
									const e = new jr();
									this.bones[t] && e.getInverse(this.bones[t].matrixWorld),
										this.boneInverses.push(e);
								}
							},
							pose: function () {
								for (let t = 0, e = this.bones.length; t < e; t++) {
									const e = this.bones[t];
									e && e.matrixWorld.getInverse(this.boneInverses[t]);
								}
								for (let t = 0, e = this.bones.length; t < e; t++) {
									const e = this.bones[t];
									e &&
										(e.parent && e.parent.isBone
											? (e.matrix.getInverse(e.parent.matrixWorld),
											  e.matrix.multiply(e.matrixWorld))
											: e.matrix.copy(e.matrixWorld),
										e.matrix.decompose(e.position, e.quaternion, e.scale));
								}
							},
							update: function () {
								const t = this.bones,
									e = this.boneInverses,
									n = this.boneMatrices,
									i = this.boneTexture;
								for (let i = 0, r = t.length; i < r; i++) {
									const r = t[i] ? t[i].matrixWorld : Ql;
									Gl.multiplyMatrices(r, e[i]), Gl.toArray(n, 16 * i);
								}
								void 0 !== i && (i.needsUpdate = !0);
							},
							clone: function () {
								return new _l(this.bones, this.boneInverses);
							},
							getBoneByName: function (t) {
								for (let e = 0, n = this.bones.length; e < n; e++) {
									const n = this.bones[e];
									if (n.name === t) return n;
								}
							},
							dispose: function () {
								this.boneTexture &&
									(this.boneTexture.dispose(), (this.boneTexture = void 0));
							},
						}),
							(Pl.prototype = Object.assign(Object.create(oo.prototype), {
								constructor: Pl,
								isBone: !0,
							}));
						const Jl = new jr(),
							Yl = new jr(),
							Xl = [],
							$l = new La();
						function th(t, e, n) {
							La.call(this, t, e),
								(this.instanceMatrix = new sa(new Float32Array(16 * n), 16)),
								(this.count = n),
								(this.frustumCulled = !1);
						}
						function eh(t) {
							ia.call(this),
								(this.type = "LineBasicMaterial"),
								(this.color = new Yo(16777215)),
								(this.linewidth = 1),
								(this.linecap = "round"),
								(this.linejoin = "round"),
								(this.morphTargets = !1),
								this.setValues(t);
						}
						(th.prototype = Object.assign(Object.create(La.prototype), {
							constructor: th,
							isInstancedMesh: !0,
							copy: function (t) {
								return (
									La.prototype.copy.call(this, t),
									this.instanceMatrix.copy(t.instanceMatrix),
									(this.count = t.count),
									this
								);
							},
							getMatrixAt: function (t, e) {
								e.fromArray(this.instanceMatrix.array, 16 * t);
							},
							raycast: function (t, e) {
								const n = this.matrixWorld,
									i = this.count;
								if (
									(($l.geometry = this.geometry),
									($l.material = this.material),
									void 0 !== $l.material)
								)
									for (let r = 0; r < i; r++) {
										this.getMatrixAt(r, Jl),
											Yl.multiplyMatrices(n, Jl),
											($l.matrixWorld = Yl),
											$l.raycast(t, Xl);
										for (let t = 0, n = Xl.length; t < n; t++) {
											const n = Xl[t];
											(n.instanceId = r), (n.object = this), e.push(n);
										}
										Xl.length = 0;
									}
							},
							setMatrixAt: function (t, e) {
								e.toArray(this.instanceMatrix.array, 16 * t);
							},
							updateMorphTargets: function () {},
						})),
							(eh.prototype = Object.create(ia.prototype)),
							(eh.prototype.constructor = eh),
							(eh.prototype.isLineBasicMaterial = !0),
							(eh.prototype.copy = function (t) {
								return (
									ia.prototype.copy.call(this, t),
									this.color.copy(t.color),
									(this.linewidth = t.linewidth),
									(this.linecap = t.linecap),
									(this.linejoin = t.linejoin),
									(this.morphTargets = t.morphTargets),
									this
								);
							});
						const nh = new zr(),
							ih = new zr(),
							rh = new jr(),
							oh = new To(),
							ah = new vo();
						function sh(t, e, n) {
							1 === n &&
								console.error(
									"THREE.Line: parameter THREE.LinePieces no longer supported. Use THREE.LineSegments instead."
								),
								oo.call(this),
								(this.type = "Line"),
								(this.geometry = void 0 !== t ? t : new Ua()),
								(this.material = void 0 !== e ? e : new eh()),
								this.updateMorphTargets();
						}
						sh.prototype = Object.assign(Object.create(oo.prototype), {
							constructor: sh,
							isLine: !0,
							copy: function (t) {
								return (
									oo.prototype.copy.call(this, t),
									(this.material = t.material),
									(this.geometry = t.geometry),
									this
								);
							},
							computeLineDistances: function () {
								const t = this.geometry;
								if (t.isBufferGeometry)
									if (null === t.index) {
										const e = t.attributes.position,
											n = [0];
										for (let t = 1, i = e.count; t < i; t++)
											nh.fromBufferAttribute(e, t - 1),
												ih.fromBufferAttribute(e, t),
												(n[t] = n[t - 1]),
												(n[t] += nh.distanceTo(ih));
										t.setAttribute("lineDistance", new fa(n, 1));
									} else
										console.warn(
											"THREE.Line.computeLineDistances(): Computation only possible with non-indexed BufferGeometry."
										);
								else if (t.isGeometry) {
									const e = t.vertices,
										n = t.lineDistances;
									n[0] = 0;
									for (let t = 1, i = e.length; t < i; t++)
										(n[t] = n[t - 1]), (n[t] += e[t - 1].distanceTo(e[t]));
								}
								return this;
							},
							raycast: function (t, e) {
								const n = this.geometry,
									i = this.matrixWorld,
									r = t.params.Line.threshold;
								if (
									(null === n.boundingSphere && n.computeBoundingSphere(),
									ah.copy(n.boundingSphere),
									ah.applyMatrix4(i),
									(ah.radius += r),
									!1 === t.ray.intersectsSphere(ah))
								)
									return;
								rh.getInverse(i), oh.copy(t.ray).applyMatrix4(rh);
								const o =
										r / ((this.scale.x + this.scale.y + this.scale.z) / 3),
									a = o * o,
									s = new zr(),
									c = new zr(),
									l = new zr(),
									h = new zr(),
									p = this && this.isLineSegments ? 2 : 1;
								if (n.isBufferGeometry) {
									const i = n.index,
										r = n.attributes.position.array;
									if (null !== i) {
										const n = i.array;
										for (let i = 0, o = n.length - 1; i < o; i += p) {
											const o = n[i],
												p = n[i + 1];
											if (
												(s.fromArray(r, 3 * o),
												c.fromArray(r, 3 * p),
												oh.distanceSqToSegment(s, c, h, l) > a)
											)
												continue;
											h.applyMatrix4(this.matrixWorld);
											const u = t.ray.origin.distanceTo(h);
											u < t.near ||
												u > t.far ||
												e.push({
													distance: u,
													point: l.clone().applyMatrix4(this.matrixWorld),
													index: i,
													face: null,
													faceIndex: null,
													object: this,
												});
										}
									} else
										for (let n = 0, i = r.length / 3 - 1; n < i; n += p) {
											if (
												(s.fromArray(r, 3 * n),
												c.fromArray(r, 3 * n + 3),
												oh.distanceSqToSegment(s, c, h, l) > a)
											)
												continue;
											h.applyMatrix4(this.matrixWorld);
											const i = t.ray.origin.distanceTo(h);
											i < t.near ||
												i > t.far ||
												e.push({
													distance: i,
													point: l.clone().applyMatrix4(this.matrixWorld),
													index: n,
													face: null,
													faceIndex: null,
													object: this,
												});
										}
								} else if (n.isGeometry) {
									const i = n.vertices,
										r = i.length;
									for (let n = 0; n < r - 1; n += p) {
										if (oh.distanceSqToSegment(i[n], i[n + 1], h, l) > a)
											continue;
										h.applyMatrix4(this.matrixWorld);
										const r = t.ray.origin.distanceTo(h);
										r < t.near ||
											r > t.far ||
											e.push({
												distance: r,
												point: l.clone().applyMatrix4(this.matrixWorld),
												index: n,
												face: null,
												faceIndex: null,
												object: this,
											});
									}
								}
							},
							updateMorphTargets: function () {
								const t = this.geometry;
								if (t.isBufferGeometry) {
									const e = t.morphAttributes,
										n = Object.keys(e);
									if (n.length > 0) {
										const t = e[n[0]];
										if (void 0 !== t) {
											(this.morphTargetInfluences = []),
												(this.morphTargetDictionary = {});
											for (let e = 0, n = t.length; e < n; e++) {
												const n = t[e].name || String(e);
												this.morphTargetInfluences.push(0),
													(this.morphTargetDictionary[n] = e);
											}
										}
									}
								} else {
									const e = t.morphTargets;
									void 0 !== e &&
										e.length > 0 &&
										console.error(
											"THREE.Line.updateMorphTargets() does not support THREE.Geometry. Use THREE.BufferGeometry instead."
										);
								}
							},
						});
						const ch = new zr(),
							lh = new zr();
						function hh(t, e) {
							sh.call(this, t, e), (this.type = "LineSegments");
						}
						function ph(t, e) {
							sh.call(this, t, e), (this.type = "LineLoop");
						}
						function uh(t) {
							ia.call(this),
								(this.type = "PointsMaterial"),
								(this.color = new Yo(16777215)),
								(this.map = null),
								(this.alphaMap = null),
								(this.size = 1),
								(this.sizeAttenuation = !0),
								(this.morphTargets = !1),
								this.setValues(t);
						}
						(hh.prototype = Object.assign(Object.create(sh.prototype), {
							constructor: hh,
							isLineSegments: !0,
							computeLineDistances: function () {
								const t = this.geometry;
								if (t.isBufferGeometry)
									if (null === t.index) {
										const e = t.attributes.position,
											n = [];
										for (let t = 0, i = e.count; t < i; t += 2)
											ch.fromBufferAttribute(e, t),
												lh.fromBufferAttribute(e, t + 1),
												(n[t] = 0 === t ? 0 : n[t - 1]),
												(n[t + 1] = n[t] + ch.distanceTo(lh));
										t.setAttribute("lineDistance", new fa(n, 1));
									} else
										console.warn(
											"THREE.LineSegments.computeLineDistances(): Computation only possible with non-indexed BufferGeometry."
										);
								else if (t.isGeometry) {
									const e = t.vertices,
										n = t.lineDistances;
									for (let t = 0, i = e.length; t < i; t += 2)
										ch.copy(e[t]),
											lh.copy(e[t + 1]),
											(n[t] = 0 === t ? 0 : n[t - 1]),
											(n[t + 1] = n[t] + ch.distanceTo(lh));
								}
								return this;
							},
						})),
							(ph.prototype = Object.assign(Object.create(sh.prototype), {
								constructor: ph,
								isLineLoop: !0,
							})),
							(uh.prototype = Object.create(ia.prototype)),
							(uh.prototype.constructor = uh),
							(uh.prototype.isPointsMaterial = !0),
							(uh.prototype.copy = function (t) {
								return (
									ia.prototype.copy.call(this, t),
									this.color.copy(t.color),
									(this.map = t.map),
									(this.alphaMap = t.alphaMap),
									(this.size = t.size),
									(this.sizeAttenuation = t.sizeAttenuation),
									(this.morphTargets = t.morphTargets),
									this
								);
							});
						const dh = new jr(),
							mh = new To(),
							fh = new vo(),
							gh = new zr();
						function Sh(t, e) {
							oo.call(this),
								(this.type = "Points"),
								(this.geometry = void 0 !== t ? t : new Ua()),
								(this.material = void 0 !== e ? e : new uh()),
								this.updateMorphTargets();
						}
						function yh(t, e, n, i, r, o, a) {
							const s = mh.distanceSqToPoint(t);
							if (s < n) {
								const n = new zr();
								mh.closestPointToPoint(t, n), n.applyMatrix4(i);
								const c = r.ray.origin.distanceTo(n);
								if (c < r.near || c > r.far) return;
								o.push({
									distance: c,
									distanceToRay: Math.sqrt(s),
									point: n,
									index: e,
									face: null,
									object: a,
								});
							}
						}
						function Vh(t, e, n, i, r, o, a, s, c) {
							Ur.call(this, t, e, n, i, r, o, a, s, c),
								(this.format = void 0 !== a ? a : $i),
								(this.minFilter = void 0 !== o ? o : Bi),
								(this.magFilter = void 0 !== r ? r : Bi),
								(this.generateMipmaps = !1);
							const l = this;
							"requestVideoFrameCallback" in t &&
								t.requestVideoFrameCallback(function e() {
									(l.needsUpdate = !0), t.requestVideoFrameCallback(e);
								});
						}
						function qh(t, e, n, i, r, o, a, s, c, l, h, p) {
							Ur.call(this, null, o, a, s, c, l, i, r, h, p),
								(this.image = { width: e, height: n }),
								(this.mipmaps = t),
								(this.flipY = !1),
								(this.generateMipmaps = !1);
						}
						function Rh(t, e, n, i, r, o, a, s, c) {
							Ur.call(this, t, e, n, i, r, o, a, s, c), (this.needsUpdate = !0);
						}
						function Mh(t, e, n, i, r, o, a, s, c, l) {
							if ((l = void 0 !== l ? l : er) !== er && l !== nr)
								throw new Error(
									"DepthTexture format must be either THREE.DepthFormat or THREE.DepthStencilFormat"
								);
							void 0 === n && l === er && (n = _i),
								void 0 === n && l === nr && (n = Xi),
								Ur.call(this, null, i, r, o, a, s, l, n, c),
								(this.image = { width: t, height: e }),
								(this.magFilter = void 0 !== a ? a : Di),
								(this.minFilter = void 0 !== s ? s : Di),
								(this.flipY = !1),
								(this.generateMipmaps = !1);
						}
						function Ih(t) {
							Ua.call(this), (this.type = "WireframeGeometry");
							const e = [],
								n = [0, 0],
								i = {},
								r = ["a", "b", "c"];
							if (t && t.isGeometry) {
								const o = t.faces;
								for (let t = 0, e = o.length; t < e; t++) {
									const e = o[t];
									for (let t = 0; t < 3; t++) {
										const o = e[r[t]],
											a = e[r[(t + 1) % 3]];
										(n[0] = Math.min(o, a)), (n[1] = Math.max(o, a));
										const s = n[0] + "," + n[1];
										void 0 === i[s] && (i[s] = { index1: n[0], index2: n[1] });
									}
								}
								for (const n in i) {
									const r = i[n];
									let o = t.vertices[r.index1];
									e.push(o.x, o.y, o.z),
										(o = t.vertices[r.index2]),
										e.push(o.x, o.y, o.z);
								}
							} else if (t && t.isBufferGeometry) {
								let r = new zr();
								if (null !== t.index) {
									const o = t.attributes.position,
										a = t.index;
									let s = t.groups;
									0 === s.length &&
										(s = [{ start: 0, count: a.count, materialIndex: 0 }]);
									for (let t = 0, e = s.length; t < e; ++t) {
										const e = s[t],
											r = e.start;
										for (let t = r, o = r + e.count; t < o; t += 3)
											for (let e = 0; e < 3; e++) {
												const r = a.getX(t + e),
													o = a.getX(t + ((e + 1) % 3));
												(n[0] = Math.min(r, o)), (n[1] = Math.max(r, o));
												const s = n[0] + "," + n[1];
												void 0 === i[s] &&
													(i[s] = { index1: n[0], index2: n[1] });
											}
									}
									for (const t in i) {
										const n = i[t];
										r.fromBufferAttribute(o, n.index1),
											e.push(r.x, r.y, r.z),
											r.fromBufferAttribute(o, n.index2),
											e.push(r.x, r.y, r.z);
									}
								} else {
									const n = t.attributes.position;
									for (let t = 0, i = n.count / 3; t < i; t++)
										for (let i = 0; i < 3; i++) {
											const o = 3 * t + i;
											r.fromBufferAttribute(n, o), e.push(r.x, r.y, r.z);
											const a = 3 * t + ((i + 1) % 3);
											r.fromBufferAttribute(n, a), e.push(r.x, r.y, r.z);
										}
								}
							}
							this.setAttribute("position", new fa(e, 3));
						}
						function vh(t, e, n) {
							Ya.call(this),
								(this.type = "ParametricGeometry"),
								(this.parameters = { func: t, slices: e, stacks: n }),
								this.fromBufferGeometry(new kh(t, e, n)),
								this.mergeVertices();
						}
						function kh(t, e, n) {
							Ua.call(this),
								(this.type = "ParametricBufferGeometry"),
								(this.parameters = { func: t, slices: e, stacks: n });
							const i = [],
								r = [],
								o = [],
								a = [],
								s = 1e-5,
								c = new zr(),
								l = new zr(),
								h = new zr(),
								p = new zr(),
								u = new zr();
							t.length < 3 &&
								console.error(
									"THREE.ParametricGeometry: Function must now modify a Vector3 as third parameter."
								);
							const d = e + 1;
							for (let i = 0; i <= n; i++) {
								const d = i / n;
								for (let n = 0; n <= e; n++) {
									const i = n / e;
									t(i, d, l),
										r.push(l.x, l.y, l.z),
										i - s >= 0
											? (t(i - s, d, h), p.subVectors(l, h))
											: (t(i + s, d, h), p.subVectors(h, l)),
										d - s >= 0
											? (t(i, d - s, h), u.subVectors(l, h))
											: (t(i, d + s, h), u.subVectors(h, l)),
										c.crossVectors(p, u).normalize(),
										o.push(c.x, c.y, c.z),
										a.push(i, d);
								}
							}
							for (let t = 0; t < n; t++)
								for (let n = 0; n < e; n++) {
									const e = t * d + n,
										r = t * d + n + 1,
										o = (t + 1) * d + n + 1,
										a = (t + 1) * d + n;
									i.push(e, r, a), i.push(r, o, a);
								}
							this.setIndex(i),
								this.setAttribute("position", new fa(r, 3)),
								this.setAttribute("normal", new fa(o, 3)),
								this.setAttribute("uv", new fa(a, 2));
						}
						function Uh(t, e, n, i) {
							Ya.call(this),
								(this.type = "PolyhedronGeometry"),
								(this.parameters = {
									vertices: t,
									indices: e,
									radius: n,
									detail: i,
								}),
								this.fromBufferGeometry(new wh(t, e, n, i)),
								this.mergeVertices();
						}
						function wh(t, e, n, i) {
							Ua.call(this),
								(this.type = "PolyhedronBufferGeometry"),
								(this.parameters = {
									vertices: t,
									indices: e,
									radius: n,
									detail: i,
								}),
								(n = n || 1);
							const r = [],
								o = [];
							function a(t, e, n, i) {
								const r = Math.pow(2, i),
									o = [];
								for (let i = 0; i <= r; i++) {
									o[i] = [];
									const a = t.clone().lerp(n, i / r),
										s = e.clone().lerp(n, i / r),
										c = r - i;
									for (let t = 0; t <= c; t++)
										o[i][t] = 0 === t && i === r ? a : a.clone().lerp(s, t / c);
								}
								for (let t = 0; t < r; t++)
									for (let e = 0; e < 2 * (r - t) - 1; e++) {
										const n = Math.floor(e / 2);
										e % 2 == 0
											? (s(o[t][n + 1]), s(o[t + 1][n]), s(o[t][n]))
											: (s(o[t][n + 1]), s(o[t + 1][n + 1]), s(o[t + 1][n]));
									}
							}
							function s(t) {
								r.push(t.x, t.y, t.z);
							}
							function c(e, n) {
								const i = 3 * e;
								(n.x = t[i + 0]), (n.y = t[i + 1]), (n.z = t[i + 2]);
							}
							function l(t, e, n, i) {
								i < 0 && 1 === t.x && (o[e] = t.x - 1),
									0 === n.x && 0 === n.z && (o[e] = i / 2 / Math.PI + 0.5);
							}
							function h(t) {
								return Math.atan2(t.z, -t.x);
							}
							!(function (t) {
								const n = new zr(),
									i = new zr(),
									r = new zr();
								for (let o = 0; o < e.length; o += 3)
									c(e[o + 0], n), c(e[o + 1], i), c(e[o + 2], r), a(n, i, r, t);
							})((i = i || 0)),
								(function (t) {
									const e = new zr();
									for (let n = 0; n < r.length; n += 3)
										(e.x = r[n + 0]),
											(e.y = r[n + 1]),
											(e.z = r[n + 2]),
											e.normalize().multiplyScalar(t),
											(r[n + 0] = e.x),
											(r[n + 1] = e.y),
											(r[n + 2] = e.z);
								})(n),
								(function () {
									const t = new zr();
									for (let n = 0; n < r.length; n += 3) {
										(t.x = r[n + 0]), (t.y = r[n + 1]), (t.z = r[n + 2]);
										const i = h(t) / 2 / Math.PI + 0.5,
											a =
												((e = t),
												Math.atan2(-e.y, Math.sqrt(e.x * e.x + e.z * e.z)) /
													Math.PI +
													0.5);
										o.push(i, 1 - a);
									}
									var e;
									(function () {
										const t = new zr(),
											e = new zr(),
											n = new zr(),
											i = new zr(),
											a = new Rr(),
											s = new Rr(),
											c = new Rr();
										for (let p = 0, u = 0; p < r.length; p += 9, u += 6) {
											t.set(r[p + 0], r[p + 1], r[p + 2]),
												e.set(r[p + 3], r[p + 4], r[p + 5]),
												n.set(r[p + 6], r[p + 7], r[p + 8]),
												a.set(o[u + 0], o[u + 1]),
												s.set(o[u + 2], o[u + 3]),
												c.set(o[u + 4], o[u + 5]),
												i.copy(t).add(e).add(n).divideScalar(3);
											const d = h(i);
											l(a, u + 0, t, d), l(s, u + 2, e, d), l(c, u + 4, n, d);
										}
									})(),
										(function () {
											for (let t = 0; t < o.length; t += 6) {
												const e = o[t + 0],
													n = o[t + 2],
													i = o[t + 4],
													r = Math.max(e, n, i),
													a = Math.min(e, n, i);
												r > 0.9 &&
													a < 0.1 &&
													(e < 0.2 && (o[t + 0] += 1),
													n < 0.2 && (o[t + 2] += 1),
													i < 0.2 && (o[t + 4] += 1));
											}
										})();
								})(),
								this.setAttribute("position", new fa(r, 3)),
								this.setAttribute("normal", new fa(r.slice(), 3)),
								this.setAttribute("uv", new fa(o, 2)),
								0 === i ? this.computeVertexNormals() : this.normalizeNormals();
						}
						function xh(t, e) {
							Ya.call(this),
								(this.type = "TetrahedronGeometry"),
								(this.parameters = { radius: t, detail: e }),
								this.fromBufferGeometry(new Oh(t, e)),
								this.mergeVertices();
						}
						function Oh(t, e) {
							wh.call(
								this,
								[1, 1, 1, -1, -1, 1, -1, 1, -1, 1, -1, -1],
								[2, 1, 0, 0, 3, 2, 1, 3, 0, 2, 3, 1],
								t,
								e
							),
								(this.type = "TetrahedronBufferGeometry"),
								(this.parameters = { radius: t, detail: e });
						}
						function bh(t, e) {
							Ya.call(this),
								(this.type = "OctahedronGeometry"),
								(this.parameters = { radius: t, detail: e }),
								this.fromBufferGeometry(new Kh(t, e)),
								this.mergeVertices();
						}
						function Kh(t, e) {
							wh.call(
								this,
								[1, 0, 0, -1, 0, 0, 0, 1, 0, 0, -1, 0, 0, 0, 1, 0, 0, -1],
								[
									0, 2, 4, 0, 4, 3, 0, 3, 5, 0, 5, 2, 1, 2, 5, 1, 5, 3, 1, 3, 4,
									1, 4, 2,
								],
								t,
								e
							),
								(this.type = "OctahedronBufferGeometry"),
								(this.parameters = { radius: t, detail: e });
						}
						function Th(t, e) {
							Ya.call(this),
								(this.type = "IcosahedronGeometry"),
								(this.parameters = { radius: t, detail: e }),
								this.fromBufferGeometry(new zh(t, e)),
								this.mergeVertices();
						}
						function zh(t, e) {
							const n = (1 + Math.sqrt(5)) / 2,
								i = [
									-1,
									n,
									0,
									1,
									n,
									0,
									-1,
									-n,
									0,
									1,
									-n,
									0,
									0,
									-1,
									n,
									0,
									1,
									n,
									0,
									-1,
									-n,
									0,
									1,
									-n,
									n,
									0,
									-1,
									n,
									0,
									1,
									-n,
									0,
									-1,
									-n,
									0,
									1,
								];
							wh.call(
								this,
								i,
								[
									0, 11, 5, 0, 5, 1, 0, 1, 7, 0, 7, 10, 0, 10, 11, 1, 5, 9, 5,
									11, 4, 11, 10, 2, 10, 7, 6, 7, 1, 8, 3, 9, 4, 3, 4, 2, 3, 2,
									6, 3, 6, 8, 3, 8, 9, 4, 9, 5, 2, 4, 11, 6, 2, 10, 8, 6, 7, 9,
									8, 1,
								],
								t,
								e
							),
								(this.type = "IcosahedronBufferGeometry"),
								(this.parameters = { radius: t, detail: e });
						}
						function Wh(t, e) {
							Ya.call(this),
								(this.type = "DodecahedronGeometry"),
								(this.parameters = { radius: t, detail: e }),
								this.fromBufferGeometry(new Eh(t, e)),
								this.mergeVertices();
						}
						function Eh(t, e) {
							const n = (1 + Math.sqrt(5)) / 2,
								i = 1 / n,
								r = [
									-1,
									-1,
									-1,
									-1,
									-1,
									1,
									-1,
									1,
									-1,
									-1,
									1,
									1,
									1,
									-1,
									-1,
									1,
									-1,
									1,
									1,
									1,
									-1,
									1,
									1,
									1,
									0,
									-i,
									-n,
									0,
									-i,
									n,
									0,
									i,
									-n,
									0,
									i,
									n,
									-i,
									-n,
									0,
									-i,
									n,
									0,
									i,
									-n,
									0,
									i,
									n,
									0,
									-n,
									0,
									-i,
									n,
									0,
									-i,
									-n,
									0,
									i,
									n,
									0,
									i,
								];
							wh.call(
								this,
								r,
								[
									3, 11, 7, 3, 7, 15, 3, 15, 13, 7, 19, 17, 7, 17, 6, 7, 6, 15,
									17, 4, 8, 17, 8, 10, 17, 10, 6, 8, 0, 16, 8, 16, 2, 8, 2, 10,
									0, 12, 1, 0, 1, 18, 0, 18, 16, 6, 10, 2, 6, 2, 13, 6, 13, 15,
									2, 16, 18, 2, 18, 3, 2, 3, 13, 18, 1, 9, 18, 9, 11, 18, 11, 3,
									4, 14, 12, 4, 12, 0, 4, 0, 8, 11, 9, 5, 11, 5, 19, 11, 19, 7,
									19, 5, 14, 19, 14, 4, 19, 4, 17, 1, 12, 14, 1, 14, 5, 1, 5, 9,
								],
								t,
								e
							),
								(this.type = "DodecahedronBufferGeometry"),
								(this.parameters = { radius: t, detail: e });
						}
						function Ch(t, e, n, i, r, o) {
							Ya.call(this),
								(this.type = "TubeGeometry"),
								(this.parameters = {
									path: t,
									tubularSegments: e,
									radius: n,
									radialSegments: i,
									closed: r,
								}),
								void 0 !== o &&
									console.warn("THREE.TubeGeometry: taper has been removed.");
							const a = new Fh(t, e, n, i, r);
							(this.tangents = a.tangents),
								(this.normals = a.normals),
								(this.binormals = a.binormals),
								this.fromBufferGeometry(a),
								this.mergeVertices();
						}
						function Fh(t, e, n, i, r) {
							Ua.call(this),
								(this.type = "TubeBufferGeometry"),
								(this.parameters = {
									path: t,
									tubularSegments: e,
									radius: n,
									radialSegments: i,
									closed: r,
								}),
								(e = e || 64),
								(n = n || 1),
								(i = i || 8),
								(r = r || !1);
							const o = t.computeFrenetFrames(e, r);
							(this.tangents = o.tangents),
								(this.normals = o.normals),
								(this.binormals = o.binormals);
							const a = new zr(),
								s = new zr(),
								c = new Rr();
							let l = new zr();
							const h = [],
								p = [],
								u = [],
								d = [];
							function m(r) {
								l = t.getPointAt(r / e, l);
								const c = o.normals[r],
									u = o.binormals[r];
								for (let t = 0; t <= i; t++) {
									const e = (t / i) * Math.PI * 2,
										r = Math.sin(e),
										o = -Math.cos(e);
									(s.x = o * c.x + r * u.x),
										(s.y = o * c.y + r * u.y),
										(s.z = o * c.z + r * u.z),
										s.normalize(),
										p.push(s.x, s.y, s.z),
										(a.x = l.x + n * s.x),
										(a.y = l.y + n * s.y),
										(a.z = l.z + n * s.z),
										h.push(a.x, a.y, a.z);
								}
							}
							!(function () {
								for (let t = 0; t < e; t++) m(t);
								m(!1 === r ? e : 0),
									(function () {
										for (let t = 0; t <= e; t++)
											for (let n = 0; n <= i; n++)
												(c.x = t / e), (c.y = n / i), u.push(c.x, c.y);
									})(),
									(function () {
										for (let t = 1; t <= e; t++)
											for (let e = 1; e <= i; e++) {
												const n = (i + 1) * (t - 1) + (e - 1),
													r = (i + 1) * t + (e - 1),
													o = (i + 1) * t + e,
													a = (i + 1) * (t - 1) + e;
												d.push(n, r, a), d.push(r, o, a);
											}
									})();
							})(),
								this.setIndex(d),
								this.setAttribute("position", new fa(h, 3)),
								this.setAttribute("normal", new fa(p, 3)),
								this.setAttribute("uv", new fa(u, 2));
						}
						function Zh(t, e, n, i, r, o, a) {
							Ya.call(this),
								(this.type = "TorusKnotGeometry"),
								(this.parameters = {
									radius: t,
									tube: e,
									tubularSegments: n,
									radialSegments: i,
									p: r,
									q: o,
								}),
								void 0 !== a &&
									console.warn(
										"THREE.TorusKnotGeometry: heightScale has been deprecated. Use .scale( x, y, z ) instead."
									),
								this.fromBufferGeometry(new Hh(t, e, n, i, r, o)),
								this.mergeVertices();
						}
						function Hh(t, e, n, i, r, o) {
							Ua.call(this),
								(this.type = "TorusKnotBufferGeometry"),
								(this.parameters = {
									radius: t,
									tube: e,
									tubularSegments: n,
									radialSegments: i,
									p: r,
									q: o,
								}),
								(t = t || 1),
								(e = e || 0.4),
								(n = Math.floor(n) || 64),
								(i = Math.floor(i) || 8),
								(r = r || 2),
								(o = o || 3);
							const a = [],
								s = [],
								c = [],
								l = [],
								h = new zr(),
								p = new zr(),
								u = new zr(),
								d = new zr(),
								m = new zr(),
								f = new zr(),
								g = new zr();
							for (let a = 0; a <= n; ++a) {
								const y = (a / n) * r * Math.PI * 2;
								S(y, r, o, t, u),
									S(y + 0.01, r, o, t, d),
									f.subVectors(d, u),
									g.addVectors(d, u),
									m.crossVectors(f, g),
									g.crossVectors(m, f),
									m.normalize(),
									g.normalize();
								for (let t = 0; t <= i; ++t) {
									const r = (t / i) * Math.PI * 2,
										o = -e * Math.cos(r),
										d = e * Math.sin(r);
									(h.x = u.x + (o * g.x + d * m.x)),
										(h.y = u.y + (o * g.y + d * m.y)),
										(h.z = u.z + (o * g.z + d * m.z)),
										s.push(h.x, h.y, h.z),
										p.subVectors(h, u).normalize(),
										c.push(p.x, p.y, p.z),
										l.push(a / n),
										l.push(t / i);
								}
							}
							for (let t = 1; t <= n; t++)
								for (let e = 1; e <= i; e++) {
									const n = (i + 1) * (t - 1) + (e - 1),
										r = (i + 1) * t + (e - 1),
										o = (i + 1) * t + e,
										s = (i + 1) * (t - 1) + e;
									a.push(n, r, s), a.push(r, o, s);
								}
							function S(t, e, n, i, r) {
								const o = Math.cos(t),
									a = Math.sin(t),
									s = (n / e) * t,
									c = Math.cos(s);
								(r.x = i * (2 + c) * 0.5 * o),
									(r.y = i * (2 + c) * a * 0.5),
									(r.z = i * Math.sin(s) * 0.5);
							}
							this.setIndex(a),
								this.setAttribute("position", new fa(s, 3)),
								this.setAttribute("normal", new fa(c, 3)),
								this.setAttribute("uv", new fa(l, 2));
						}
						function Nh(t, e, n, i, r) {
							Ya.call(this),
								(this.type = "TorusGeometry"),
								(this.parameters = {
									radius: t,
									tube: e,
									radialSegments: n,
									tubularSegments: i,
									arc: r,
								}),
								this.fromBufferGeometry(new jh(t, e, n, i, r)),
								this.mergeVertices();
						}
						function jh(t, e, n, i, r) {
							Ua.call(this),
								(this.type = "TorusBufferGeometry"),
								(this.parameters = {
									radius: t,
									tube: e,
									radialSegments: n,
									tubularSegments: i,
									arc: r,
								}),
								(t = t || 1),
								(e = e || 0.4),
								(n = Math.floor(n) || 8),
								(i = Math.floor(i) || 6),
								(r = r || 2 * Math.PI);
							const o = [],
								a = [],
								s = [],
								c = [],
								l = new zr(),
								h = new zr(),
								p = new zr();
							for (let o = 0; o <= n; o++)
								for (let u = 0; u <= i; u++) {
									const d = (u / i) * r,
										m = (o / n) * Math.PI * 2;
									(h.x = (t + e * Math.cos(m)) * Math.cos(d)),
										(h.y = (t + e * Math.cos(m)) * Math.sin(d)),
										(h.z = e * Math.sin(m)),
										a.push(h.x, h.y, h.z),
										(l.x = t * Math.cos(d)),
										(l.y = t * Math.sin(d)),
										p.subVectors(h, l).normalize(),
										s.push(p.x, p.y, p.z),
										c.push(u / i),
										c.push(o / n);
								}
							for (let t = 1; t <= n; t++)
								for (let e = 1; e <= i; e++) {
									const n = (i + 1) * t + e - 1,
										r = (i + 1) * (t - 1) + e - 1,
										a = (i + 1) * (t - 1) + e,
										s = (i + 1) * t + e;
									o.push(n, r, s), o.push(r, a, s);
								}
							this.setIndex(o),
								this.setAttribute("position", new fa(a, 3)),
								this.setAttribute("normal", new fa(s, 3)),
								this.setAttribute("uv", new fa(c, 2));
						}
						(Sh.prototype = Object.assign(Object.create(oo.prototype), {
							constructor: Sh,
							isPoints: !0,
							copy: function (t) {
								return (
									oo.prototype.copy.call(this, t),
									(this.material = t.material),
									(this.geometry = t.geometry),
									this
								);
							},
							raycast: function (t, e) {
								const n = this.geometry,
									i = this.matrixWorld,
									r = t.params.Points.threshold;
								if (
									(null === n.boundingSphere && n.computeBoundingSphere(),
									fh.copy(n.boundingSphere),
									fh.applyMatrix4(i),
									(fh.radius += r),
									!1 === t.ray.intersectsSphere(fh))
								)
									return;
								dh.getInverse(i), mh.copy(t.ray).applyMatrix4(dh);
								const o =
										r / ((this.scale.x + this.scale.y + this.scale.z) / 3),
									a = o * o;
								if (n.isBufferGeometry) {
									const r = n.index,
										o = n.attributes.position.array;
									if (null !== r) {
										const n = r.array;
										for (let r = 0, s = n.length; r < s; r++) {
											const s = n[r];
											gh.fromArray(o, 3 * s), yh(gh, s, a, i, t, e, this);
										}
									} else
										for (let n = 0, r = o.length / 3; n < r; n++)
											gh.fromArray(o, 3 * n), yh(gh, n, a, i, t, e, this);
								} else {
									const r = n.vertices;
									for (let n = 0, o = r.length; n < o; n++)
										yh(r[n], n, a, i, t, e, this);
								}
							},
							updateMorphTargets: function () {
								const t = this.geometry;
								if (t.isBufferGeometry) {
									const e = t.morphAttributes,
										n = Object.keys(e);
									if (n.length > 0) {
										const t = e[n[0]];
										if (void 0 !== t) {
											(this.morphTargetInfluences = []),
												(this.morphTargetDictionary = {});
											for (let e = 0, n = t.length; e < n; e++) {
												const n = t[e].name || String(e);
												this.morphTargetInfluences.push(0),
													(this.morphTargetDictionary[n] = e);
											}
										}
									}
								} else {
									const e = t.morphTargets;
									void 0 !== e &&
										e.length > 0 &&
										console.error(
											"THREE.Points.updateMorphTargets() does not support THREE.Geometry. Use THREE.BufferGeometry instead."
										);
								}
							},
						})),
							(Vh.prototype = Object.assign(Object.create(Ur.prototype), {
								constructor: Vh,
								isVideoTexture: !0,
								update: function () {
									const t = this.image;
									!1 == "requestVideoFrameCallback" in t &&
										t.readyState >= t.HAVE_CURRENT_DATA &&
										(this.needsUpdate = !0);
								},
							})),
							(qh.prototype = Object.create(Ur.prototype)),
							(qh.prototype.constructor = qh),
							(qh.prototype.isCompressedTexture = !0),
							(Rh.prototype = Object.create(Ur.prototype)),
							(Rh.prototype.constructor = Rh),
							(Rh.prototype.isCanvasTexture = !0),
							(Mh.prototype = Object.create(Ur.prototype)),
							(Mh.prototype.constructor = Mh),
							(Mh.prototype.isDepthTexture = !0),
							(Ih.prototype = Object.create(Ua.prototype)),
							(Ih.prototype.constructor = Ih),
							(vh.prototype = Object.create(Ya.prototype)),
							(vh.prototype.constructor = vh),
							(kh.prototype = Object.create(Ua.prototype)),
							(kh.prototype.constructor = kh),
							(Uh.prototype = Object.create(Ya.prototype)),
							(Uh.prototype.constructor = Uh),
							(wh.prototype = Object.create(Ua.prototype)),
							(wh.prototype.constructor = wh),
							(xh.prototype = Object.create(Ya.prototype)),
							(xh.prototype.constructor = xh),
							(Oh.prototype = Object.create(wh.prototype)),
							(Oh.prototype.constructor = Oh),
							(bh.prototype = Object.create(Ya.prototype)),
							(bh.prototype.constructor = bh),
							(Kh.prototype = Object.create(wh.prototype)),
							(Kh.prototype.constructor = Kh),
							(Th.prototype = Object.create(Ya.prototype)),
							(Th.prototype.constructor = Th),
							(zh.prototype = Object.create(wh.prototype)),
							(zh.prototype.constructor = zh),
							(Wh.prototype = Object.create(Ya.prototype)),
							(Wh.prototype.constructor = Wh),
							(Eh.prototype = Object.create(wh.prototype)),
							(Eh.prototype.constructor = Eh),
							(Ch.prototype = Object.create(Ya.prototype)),
							(Ch.prototype.constructor = Ch),
							(Fh.prototype = Object.create(Ua.prototype)),
							(Fh.prototype.constructor = Fh),
							(Fh.prototype.toJSON = function () {
								const t = Ua.prototype.toJSON.call(this);
								return (t.path = this.parameters.path.toJSON()), t;
							}),
							(Zh.prototype = Object.create(Ya.prototype)),
							(Zh.prototype.constructor = Zh),
							(Hh.prototype = Object.create(Ua.prototype)),
							(Hh.prototype.constructor = Hh),
							(Nh.prototype = Object.create(Ya.prototype)),
							(Nh.prototype.constructor = Nh),
							(jh.prototype = Object.create(Ua.prototype)),
							(jh.prototype.constructor = jh);
						function Dh(t, e, n, i, r) {
							let o, a;
							if (
								r ===
								(function (t, e, n, i) {
									let r = 0;
									for (let o = e, a = n - i; o < n; o += i)
										(r += (t[a] - t[o]) * (t[o + 1] + t[a + 1])), (a = o);
									return r;
								})(t, e, n, i) >
									0
							)
								for (o = e; o < n; o += i) a = lp(o, t[o], t[o + 1], a);
							else for (o = n - i; o >= e; o -= i) a = lp(o, t[o], t[o + 1], a);
							return a && ip(a, a.next) && (hp(a), (a = a.next)), a;
						}
						function Ah(t, e) {
							if (!t) return t;
							e || (e = t);
							let n,
								i = t;
							do {
								if (
									((n = !1),
									i.steiner || (!ip(i, i.next) && 0 !== np(i.prev, i, i.next)))
								)
									i = i.next;
								else {
									if ((hp(i), (i = e = i.prev), i === i.next)) break;
									n = !0;
								}
							} while (n || i !== e);
							return e;
						}
						function Lh(t, e, n, i, r, o, a) {
							if (!t) return;
							!a &&
								o &&
								(function (t, e, n, i) {
									let r = t;
									do {
										null === r.z && (r.z = Xh(r.x, r.y, e, n, i)),
											(r.prevZ = r.prev),
											(r.nextZ = r.next),
											(r = r.next);
									} while (r !== t);
									(r.prevZ.nextZ = null),
										(r.prevZ = null),
										(function (t) {
											let e,
												n,
												i,
												r,
												o,
												a,
												s,
												c,
												l = 1;
											do {
												for (n = t, t = null, o = null, a = 0; n; ) {
													for (
														a++, i = n, s = 0, e = 0;
														e < l && (s++, (i = i.nextZ), i);
														e++
													);
													for (c = l; s > 0 || (c > 0 && i); )
														0 !== s && (0 === c || !i || n.z <= i.z)
															? ((r = n), (n = n.nextZ), s--)
															: ((r = i), (i = i.nextZ), c--),
															o ? (o.nextZ = r) : (t = r),
															(r.prevZ = o),
															(o = r);
													n = i;
												}
												(o.nextZ = null), (l *= 2);
											} while (a > 1);
										})(r);
								})(t, i, r, o);
							let s,
								c,
								l = t;
							for (; t.prev !== t.next; )
								if (((s = t.prev), (c = t.next), o ? Gh(t, i, r, o) : Bh(t)))
									e.push(s.i / n),
										e.push(t.i / n),
										e.push(c.i / n),
										hp(t),
										(t = c.next),
										(l = c.next);
								else if ((t = c) === l) {
									a
										? 1 === a
											? Lh((t = Qh(Ah(t), e, n)), e, n, i, r, o, 2)
											: 2 === a && _h(t, e, n, i, r, o)
										: Lh(Ah(t), e, n, i, r, o, 1);
									break;
								}
						}
						function Bh(t) {
							let e = t.prev,
								n = t,
								i = t.next;
							if (np(e, n, i) >= 0) return !1;
							let r = t.next.next;
							for (; r !== t.prev; ) {
								if (
									tp(e.x, e.y, n.x, n.y, i.x, i.y, r.x, r.y) &&
									np(r.prev, r, r.next) >= 0
								)
									return !1;
								r = r.next;
							}
							return !0;
						}
						function Gh(t, e, n, i) {
							let r = t.prev,
								o = t,
								a = t.next;
							if (np(r, o, a) >= 0) return !1;
							let s =
									r.x < o.x ? (r.x < a.x ? r.x : a.x) : o.x < a.x ? o.x : a.x,
								c = r.y < o.y ? (r.y < a.y ? r.y : a.y) : o.y < a.y ? o.y : a.y,
								l = r.x > o.x ? (r.x > a.x ? r.x : a.x) : o.x > a.x ? o.x : a.x,
								h = r.y > o.y ? (r.y > a.y ? r.y : a.y) : o.y > a.y ? o.y : a.y,
								p = Xh(s, c, e, n, i),
								u = Xh(l, h, e, n, i),
								d = t.prevZ,
								m = t.nextZ;
							for (; d && d.z >= p && m && m.z <= u; ) {
								if (
									d !== t.prev &&
									d !== t.next &&
									tp(r.x, r.y, o.x, o.y, a.x, a.y, d.x, d.y) &&
									np(d.prev, d, d.next) >= 0
								)
									return !1;
								if (
									((d = d.prevZ),
									m !== t.prev &&
										m !== t.next &&
										tp(r.x, r.y, o.x, o.y, a.x, a.y, m.x, m.y) &&
										np(m.prev, m, m.next) >= 0)
								)
									return !1;
								m = m.nextZ;
							}
							for (; d && d.z >= p; ) {
								if (
									d !== t.prev &&
									d !== t.next &&
									tp(r.x, r.y, o.x, o.y, a.x, a.y, d.x, d.y) &&
									np(d.prev, d, d.next) >= 0
								)
									return !1;
								d = d.prevZ;
							}
							for (; m && m.z <= u; ) {
								if (
									m !== t.prev &&
									m !== t.next &&
									tp(r.x, r.y, o.x, o.y, a.x, a.y, m.x, m.y) &&
									np(m.prev, m, m.next) >= 0
								)
									return !1;
								m = m.nextZ;
							}
							return !0;
						}
						function Qh(t, e, n) {
							let i = t;
							do {
								let r = i.prev,
									o = i.next.next;
								!ip(r, o) &&
									rp(r, i, i.next, o) &&
									sp(r, o) &&
									sp(o, r) &&
									(e.push(r.i / n),
									e.push(i.i / n),
									e.push(o.i / n),
									hp(i),
									hp(i.next),
									(i = t = o)),
									(i = i.next);
							} while (i !== t);
							return Ah(i);
						}
						function _h(t, e, n, i, r, o) {
							let a = t;
							do {
								let t = a.next.next;
								for (; t !== a.prev; ) {
									if (a.i !== t.i && ep(a, t)) {
										let s = cp(a, t);
										return (
											(a = Ah(a, a.next)),
											(s = Ah(s, s.next)),
											Lh(a, e, n, i, r, o),
											void Lh(s, e, n, i, r, o)
										);
									}
									t = t.next;
								}
								a = a.next;
							} while (a !== t);
						}
						function Ph(t, e) {
							return t.x - e.x;
						}
						function Jh(t, e) {
							if (
								(e = (function (t, e) {
									let n,
										i = e,
										r = t.x,
										o = t.y,
										a = -1 / 0;
									do {
										if (o <= i.y && o >= i.next.y && i.next.y !== i.y) {
											let t =
												i.x + ((o - i.y) * (i.next.x - i.x)) / (i.next.y - i.y);
											if (t <= r && t > a) {
												if (((a = t), t === r)) {
													if (o === i.y) return i;
													if (o === i.next.y) return i.next;
												}
												n = i.x < i.next.x ? i : i.next;
											}
										}
										i = i.next;
									} while (i !== e);
									if (!n) return null;
									if (r === a) return n;
									let s,
										c = n,
										l = n.x,
										h = n.y,
										p = 1 / 0;
									i = n;
									do {
										r >= i.x &&
											i.x >= l &&
											r !== i.x &&
											tp(o < h ? r : a, o, l, h, o < h ? a : r, o, i.x, i.y) &&
											((s = Math.abs(o - i.y) / (r - i.x)),
											sp(i, t) &&
												(s < p ||
													(s === p &&
														(i.x > n.x || (i.x === n.x && Yh(n, i))))) &&
												((n = i), (p = s))),
											(i = i.next);
									} while (i !== c);
									return n;
								})(t, e))
							) {
								const n = cp(e, t);
								Ah(e, e.next), Ah(n, n.next);
							}
						}
						function Yh(t, e) {
							return np(t.prev, t, e.prev) < 0 && np(e.next, t, t.next) < 0;
						}
						function Xh(t, e, n, i, r) {
							return (
								(t =
									1431655765 &
									((t =
										858993459 &
										((t =
											252645135 &
											((t = 16711935 & ((t = 32767 * (t - n) * r) | (t << 8))) |
												(t << 4))) |
											(t << 2))) |
										(t << 1))) |
								((e =
									1431655765 &
									((e =
										858993459 &
										((e =
											252645135 &
											((e = 16711935 & ((e = 32767 * (e - i) * r) | (e << 8))) |
												(e << 4))) |
											(e << 2))) |
										(e << 1))) <<
									1)
							);
						}
						function $h(t) {
							let e = t,
								n = t;
							do {
								(e.x < n.x || (e.x === n.x && e.y < n.y)) && (n = e),
									(e = e.next);
							} while (e !== t);
							return n;
						}
						function tp(t, e, n, i, r, o, a, s) {
							return (
								(r - a) * (e - s) - (t - a) * (o - s) >= 0 &&
								(t - a) * (i - s) - (n - a) * (e - s) >= 0 &&
								(n - a) * (o - s) - (r - a) * (i - s) >= 0
							);
						}
						function ep(t, e) {
							return (
								t.next.i !== e.i &&
								t.prev.i !== e.i &&
								!(function (t, e) {
									let n = t;
									do {
										if (
											n.i !== t.i &&
											n.next.i !== t.i &&
											n.i !== e.i &&
											n.next.i !== e.i &&
											rp(n, n.next, t, e)
										)
											return !0;
										n = n.next;
									} while (n !== t);
									return !1;
								})(t, e) &&
								((sp(t, e) &&
									sp(e, t) &&
									(function (t, e) {
										let n = t,
											i = !1,
											r = (t.x + e.x) / 2,
											o = (t.y + e.y) / 2;
										do {
											n.y > o != n.next.y > o &&
												n.next.y !== n.y &&
												r <
													((n.next.x - n.x) * (o - n.y)) / (n.next.y - n.y) +
														n.x &&
												(i = !i),
												(n = n.next);
										} while (n !== t);
										return i;
									})(t, e) &&
									(np(t.prev, t, e.prev) || np(t, e.prev, e))) ||
									(ip(t, e) &&
										np(t.prev, t, t.next) > 0 &&
										np(e.prev, e, e.next) > 0))
							);
						}
						function np(t, e, n) {
							return (e.y - t.y) * (n.x - e.x) - (e.x - t.x) * (n.y - e.y);
						}
						function ip(t, e) {
							return t.x === e.x && t.y === e.y;
						}
						function rp(t, e, n, i) {
							const r = ap(np(t, e, n)),
								o = ap(np(t, e, i)),
								a = ap(np(n, i, t)),
								s = ap(np(n, i, e));
							return (
								(r !== o && a !== s) ||
								!(0 !== r || !op(t, n, e)) ||
								!(0 !== o || !op(t, i, e)) ||
								!(0 !== a || !op(n, t, i)) ||
								!(0 !== s || !op(n, e, i))
							);
						}
						function op(t, e, n) {
							return (
								e.x <= Math.max(t.x, n.x) &&
								e.x >= Math.min(t.x, n.x) &&
								e.y <= Math.max(t.y, n.y) &&
								e.y >= Math.min(t.y, n.y)
							);
						}
						function ap(t) {
							return t > 0 ? 1 : t < 0 ? -1 : 0;
						}
						function sp(t, e) {
							return np(t.prev, t, t.next) < 0
								? np(t, e, t.next) >= 0 && np(t, t.prev, e) >= 0
								: np(t, e, t.prev) < 0 || np(t, t.next, e) < 0;
						}
						function cp(t, e) {
							let n = new pp(t.i, t.x, t.y),
								i = new pp(e.i, e.x, e.y),
								r = t.next,
								o = e.prev;
							return (
								(t.next = e),
								(e.prev = t),
								(n.next = r),
								(r.prev = n),
								(i.next = n),
								(n.prev = i),
								(o.next = i),
								(i.prev = o),
								i
							);
						}
						function lp(t, e, n, i) {
							const r = new pp(t, e, n);
							return (
								i
									? ((r.next = i.next),
									  (r.prev = i),
									  (i.next.prev = r),
									  (i.next = r))
									: ((r.prev = r), (r.next = r)),
								r
							);
						}
						function hp(t) {
							(t.next.prev = t.prev),
								(t.prev.next = t.next),
								t.prevZ && (t.prevZ.nextZ = t.nextZ),
								t.nextZ && (t.nextZ.prevZ = t.prevZ);
						}
						function pp(t, e, n) {
							(this.i = t),
								(this.x = e),
								(this.y = n),
								(this.prev = null),
								(this.next = null),
								(this.z = null),
								(this.prevZ = null),
								(this.nextZ = null),
								(this.steiner = !1);
						}
						const up = {
							area: function (t) {
								const e = t.length;
								let n = 0;
								for (let i = e - 1, r = 0; r < e; i = r++)
									n += t[i].x * t[r].y - t[r].x * t[i].y;
								return 0.5 * n;
							},
							isClockWise: function (t) {
								return up.area(t) < 0;
							},
							triangulateShape: function (t, e) {
								const n = [],
									i = [],
									r = [];
								dp(t), mp(n, t);
								let o = t.length;
								e.forEach(dp);
								for (let t = 0; t < e.length; t++)
									i.push(o), (o += e[t].length), mp(n, e[t]);
								const a = (function (t, e, n) {
									n = n || 2;
									let i,
										r,
										o,
										a,
										s,
										c,
										l,
										h = e && e.length,
										p = h ? e[0] * n : t.length,
										u = Dh(t, 0, p, n, !0),
										d = [];
									if (!u || u.next === u.prev) return d;
									if (
										(h &&
											(u = (function (t, e, n, i) {
												let r,
													o,
													a,
													s,
													c,
													l = [];
												for (r = 0, o = e.length; r < o; r++)
													(a = e[r] * i),
														(s = r < o - 1 ? e[r + 1] * i : t.length),
														(c = Dh(t, a, s, i, !1)),
														c === c.next && (c.steiner = !0),
														l.push($h(c));
												for (l.sort(Ph), r = 0; r < l.length; r++)
													Jh(l[r], n), (n = Ah(n, n.next));
												return n;
											})(t, e, u, n)),
										t.length > 80 * n)
									) {
										(i = o = t[0]), (r = a = t[1]);
										for (let e = n; e < p; e += n)
											(s = t[e]),
												(c = t[e + 1]),
												s < i && (i = s),
												c < r && (r = c),
												s > o && (o = s),
												c > a && (a = c);
										(l = Math.max(o - i, a - r)), (l = 0 !== l ? 1 / l : 0);
									}
									return Lh(u, d, n, i, r, l), d;
								})(n, i);
								for (let t = 0; t < a.length; t += 3) r.push(a.slice(t, t + 3));
								return r;
							},
						};
						function dp(t) {
							const e = t.length;
							e > 2 && t[e - 1].equals(t[0]) && t.pop();
						}
						function mp(t, e) {
							for (let n = 0; n < e.length; n++) t.push(e[n].x), t.push(e[n].y);
						}
						function fp(t, e) {
							Ya.call(this),
								(this.type = "ExtrudeGeometry"),
								(this.parameters = { shapes: t, options: e }),
								this.fromBufferGeometry(new gp(t, e)),
								this.mergeVertices();
						}
						function gp(t, e) {
							Ua.call(this),
								(this.type = "ExtrudeBufferGeometry"),
								(this.parameters = { shapes: t, options: e }),
								(t = Array.isArray(t) ? t : [t]);
							const n = this,
								i = [],
								r = [];
							for (let e = 0, n = t.length; e < n; e++) o(t[e]);
							function o(t) {
								const o = [],
									a = void 0 !== e.curveSegments ? e.curveSegments : 12,
									s = void 0 !== e.steps ? e.steps : 1;
								let c = void 0 !== e.depth ? e.depth : 100,
									l = void 0 === e.bevelEnabled || e.bevelEnabled,
									h = void 0 !== e.bevelThickness ? e.bevelThickness : 6,
									p = void 0 !== e.bevelSize ? e.bevelSize : h - 2,
									u = void 0 !== e.bevelOffset ? e.bevelOffset : 0,
									d = void 0 !== e.bevelSegments ? e.bevelSegments : 3;
								const m = e.extrudePath,
									f = void 0 !== e.UVGenerator ? e.UVGenerator : Sp;
								void 0 !== e.amount &&
									(console.warn(
										"THREE.ExtrudeBufferGeometry: amount has been renamed to depth."
									),
									(c = e.amount));
								let g,
									S,
									y,
									V,
									q,
									R = !1;
								m &&
									((g = m.getSpacedPoints(s)),
									(R = !0),
									(l = !1),
									(S = m.computeFrenetFrames(s, !1)),
									(y = new zr()),
									(V = new zr()),
									(q = new zr())),
									l || ((d = 0), (h = 0), (p = 0), (u = 0));
								const M = t.extractPoints(a);
								let I = M.shape;
								const v = M.holes;
								if (!up.isClockWise(I)) {
									I = I.reverse();
									for (let t = 0, e = v.length; t < e; t++) {
										const e = v[t];
										up.isClockWise(e) && (v[t] = e.reverse());
									}
								}
								const k = up.triangulateShape(I, v),
									U = I;
								for (let t = 0, e = v.length; t < e; t++) {
									const e = v[t];
									I = I.concat(e);
								}
								function w(t, e, n) {
									return (
										e ||
											console.error(
												"THREE.ExtrudeGeometry: vec does not exist"
											),
										e.clone().multiplyScalar(n).add(t)
									);
								}
								const x = I.length,
									O = k.length;
								function b(t, e, n) {
									let i, r, o;
									const a = t.x - e.x,
										s = t.y - e.y,
										c = n.x - t.x,
										l = n.y - t.y,
										h = a * a + s * s,
										p = a * l - s * c;
									if (Math.abs(p) > Number.EPSILON) {
										const p = Math.sqrt(h),
											u = Math.sqrt(c * c + l * l),
											d = e.x - s / p,
											m = e.y + a / p,
											f =
												((n.x - l / u - d) * l - (n.y + c / u - m) * c) /
												(a * l - s * c);
										(i = d + a * f - t.x), (r = m + s * f - t.y);
										const g = i * i + r * r;
										if (g <= 2) return new Rr(i, r);
										o = Math.sqrt(g / 2);
									} else {
										let t = !1;
										a > Number.EPSILON
											? c > Number.EPSILON && (t = !0)
											: a < -Number.EPSILON
											? c < -Number.EPSILON && (t = !0)
											: Math.sign(s) === Math.sign(l) && (t = !0),
											t
												? ((i = -s), (r = a), (o = Math.sqrt(h)))
												: ((i = a), (r = s), (o = Math.sqrt(h / 2)));
									}
									return new Rr(i / o, r / o);
								}
								const K = [];
								for (
									let t = 0, e = U.length, n = e - 1, i = t + 1;
									t < e;
									t++, n++, i++
								)
									n === e && (n = 0),
										i === e && (i = 0),
										(K[t] = b(U[t], U[n], U[i]));
								const T = [];
								let z,
									W = K.concat();
								for (let t = 0, e = v.length; t < e; t++) {
									const e = v[t];
									z = [];
									for (
										let t = 0, n = e.length, i = n - 1, r = t + 1;
										t < n;
										t++, i++, r++
									)
										i === n && (i = 0),
											r === n && (r = 0),
											(z[t] = b(e[t], e[i], e[r]));
									T.push(z), (W = W.concat(z));
								}
								for (let t = 0; t < d; t++) {
									const e = t / d,
										n = h * Math.cos((e * Math.PI) / 2),
										i = p * Math.sin((e * Math.PI) / 2) + u;
									for (let t = 0, e = U.length; t < e; t++) {
										const e = w(U[t], K[t], i);
										F(e.x, e.y, -n);
									}
									for (let t = 0, e = v.length; t < e; t++) {
										const e = v[t];
										z = T[t];
										for (let t = 0, r = e.length; t < r; t++) {
											const r = w(e[t], z[t], i);
											F(r.x, r.y, -n);
										}
									}
								}
								const E = p + u;
								for (let t = 0; t < x; t++) {
									const e = l ? w(I[t], W[t], E) : I[t];
									R
										? (V.copy(S.normals[0]).multiplyScalar(e.x),
										  y.copy(S.binormals[0]).multiplyScalar(e.y),
										  q.copy(g[0]).add(V).add(y),
										  F(q.x, q.y, q.z))
										: F(e.x, e.y, 0);
								}
								for (let t = 1; t <= s; t++)
									for (let e = 0; e < x; e++) {
										const n = l ? w(I[e], W[e], E) : I[e];
										R
											? (V.copy(S.normals[t]).multiplyScalar(n.x),
											  y.copy(S.binormals[t]).multiplyScalar(n.y),
											  q.copy(g[t]).add(V).add(y),
											  F(q.x, q.y, q.z))
											: F(n.x, n.y, (c / s) * t);
									}
								for (let t = d - 1; t >= 0; t--) {
									const e = t / d,
										n = h * Math.cos((e * Math.PI) / 2),
										i = p * Math.sin((e * Math.PI) / 2) + u;
									for (let t = 0, e = U.length; t < e; t++) {
										const e = w(U[t], K[t], i);
										F(e.x, e.y, c + n);
									}
									for (let t = 0, e = v.length; t < e; t++) {
										const e = v[t];
										z = T[t];
										for (let t = 0, r = e.length; t < r; t++) {
											const r = w(e[t], z[t], i);
											R
												? F(r.x, r.y + g[s - 1].y, g[s - 1].x + n)
												: F(r.x, r.y, c + n);
										}
									}
								}
								function C(t, e) {
									let n = t.length;
									for (; --n >= 0; ) {
										const i = n;
										let r = n - 1;
										r < 0 && (r = t.length - 1);
										for (let t = 0, n = s + 2 * d; t < n; t++) {
											const n = x * t,
												o = x * (t + 1);
											H(e + i + n, e + r + n, e + r + o, e + i + o);
										}
									}
								}
								function F(t, e, n) {
									o.push(t), o.push(e), o.push(n);
								}
								function Z(t, e, r) {
									N(t), N(e), N(r);
									const o = i.length / 3,
										a = f.generateTopUV(n, i, o - 3, o - 2, o - 1);
									j(a[0]), j(a[1]), j(a[2]);
								}
								function H(t, e, r, o) {
									N(t), N(e), N(o), N(e), N(r), N(o);
									const a = i.length / 3,
										s = f.generateSideWallUV(n, i, a - 6, a - 3, a - 2, a - 1);
									j(s[0]), j(s[1]), j(s[3]), j(s[1]), j(s[2]), j(s[3]);
								}
								function N(t) {
									i.push(o[3 * t + 0]),
										i.push(o[3 * t + 1]),
										i.push(o[3 * t + 2]);
								}
								function j(t) {
									r.push(t.x), r.push(t.y);
								}
								!(function () {
									const t = i.length / 3;
									if (l) {
										let t = 0,
											e = x * t;
										for (let t = 0; t < O; t++) {
											const n = k[t];
											Z(n[2] + e, n[1] + e, n[0] + e);
										}
										(t = s + 2 * d), (e = x * t);
										for (let t = 0; t < O; t++) {
											const n = k[t];
											Z(n[0] + e, n[1] + e, n[2] + e);
										}
									} else {
										for (let t = 0; t < O; t++) {
											const e = k[t];
											Z(e[2], e[1], e[0]);
										}
										for (let t = 0; t < O; t++) {
											const e = k[t];
											Z(e[0] + x * s, e[1] + x * s, e[2] + x * s);
										}
									}
									n.addGroup(t, i.length / 3 - t, 0);
								})(),
									(function () {
										const t = i.length / 3;
										let e = 0;
										C(U, e), (e += U.length);
										for (let t = 0, n = v.length; t < n; t++) {
											const n = v[t];
											C(n, e), (e += n.length);
										}
										n.addGroup(t, i.length / 3 - t, 1);
									})();
							}
							this.setAttribute("position", new fa(i, 3)),
								this.setAttribute("uv", new fa(r, 2)),
								this.computeVertexNormals();
						}
						(fp.prototype = Object.create(Ya.prototype)),
							(fp.prototype.constructor = fp),
							(fp.prototype.toJSON = function () {
								const t = Ya.prototype.toJSON.call(this);
								return yp(this.parameters.shapes, this.parameters.options, t);
							}),
							(gp.prototype = Object.create(Ua.prototype)),
							(gp.prototype.constructor = gp),
							(gp.prototype.toJSON = function () {
								const t = Ua.prototype.toJSON.call(this);
								return yp(this.parameters.shapes, this.parameters.options, t);
							});
						const Sp = {
							generateTopUV: function (t, e, n, i, r) {
								const o = e[3 * n],
									a = e[3 * n + 1],
									s = e[3 * i],
									c = e[3 * i + 1],
									l = e[3 * r],
									h = e[3 * r + 1];
								return [new Rr(o, a), new Rr(s, c), new Rr(l, h)];
							},
							generateSideWallUV: function (t, e, n, i, r, o) {
								const a = e[3 * n],
									s = e[3 * n + 1],
									c = e[3 * n + 2],
									l = e[3 * i],
									h = e[3 * i + 1],
									p = e[3 * i + 2],
									u = e[3 * r],
									d = e[3 * r + 1],
									m = e[3 * r + 2],
									f = e[3 * o],
									g = e[3 * o + 1],
									S = e[3 * o + 2];
								return Math.abs(s - h) < 0.01
									? [
											new Rr(a, 1 - c),
											new Rr(l, 1 - p),
											new Rr(u, 1 - m),
											new Rr(f, 1 - S),
									  ]
									: [
											new Rr(s, 1 - c),
											new Rr(h, 1 - p),
											new Rr(d, 1 - m),
											new Rr(g, 1 - S),
									  ];
							},
						};
						function yp(t, e, n) {
							if (((n.shapes = []), Array.isArray(t)))
								for (let e = 0, i = t.length; e < i; e++) {
									const i = t[e];
									n.shapes.push(i.uuid);
								}
							else n.shapes.push(t.uuid);
							return (
								void 0 !== e.extrudePath &&
									(n.options.extrudePath = e.extrudePath.toJSON()),
								n
							);
						}
						function Vp(t, e) {
							Ya.call(this),
								(this.type = "TextGeometry"),
								(this.parameters = { text: t, parameters: e }),
								this.fromBufferGeometry(new qp(t, e)),
								this.mergeVertices();
						}
						function qp(t, e) {
							const n = (e = e || {}).font;
							if (!n || !n.isFont)
								return (
									console.error(
										"THREE.TextGeometry: font parameter is not an instance of THREE.Font."
									),
									new Ya()
								);
							const i = n.generateShapes(t, e.size);
							(e.depth = void 0 !== e.height ? e.height : 50),
								void 0 === e.bevelThickness && (e.bevelThickness = 10),
								void 0 === e.bevelSize && (e.bevelSize = 8),
								void 0 === e.bevelEnabled && (e.bevelEnabled = !1),
								gp.call(this, i, e),
								(this.type = "TextBufferGeometry");
						}
						function Rp(t, e, n, i, r, o, a) {
							Ya.call(this),
								(this.type = "SphereGeometry"),
								(this.parameters = {
									radius: t,
									widthSegments: e,
									heightSegments: n,
									phiStart: i,
									phiLength: r,
									thetaStart: o,
									thetaLength: a,
								}),
								this.fromBufferGeometry(new Mp(t, e, n, i, r, o, a)),
								this.mergeVertices();
						}
						function Mp(t, e, n, i, r, o, a) {
							Ua.call(this),
								(this.type = "SphereBufferGeometry"),
								(this.parameters = {
									radius: t,
									widthSegments: e,
									heightSegments: n,
									phiStart: i,
									phiLength: r,
									thetaStart: o,
									thetaLength: a,
								}),
								(t = t || 1),
								(e = Math.max(3, Math.floor(e) || 8)),
								(n = Math.max(2, Math.floor(n) || 6)),
								(i = void 0 !== i ? i : 0),
								(r = void 0 !== r ? r : 2 * Math.PI),
								(o = void 0 !== o ? o : 0),
								(a = void 0 !== a ? a : Math.PI);
							const s = Math.min(o + a, Math.PI);
							let c = 0;
							const l = [],
								h = new zr(),
								p = new zr(),
								u = [],
								d = [],
								m = [],
								f = [];
							for (let u = 0; u <= n; u++) {
								const g = [],
									S = u / n;
								let y = 0;
								0 == u && 0 == o
									? (y = 0.5 / e)
									: u == n && s == Math.PI && (y = -0.5 / e);
								for (let n = 0; n <= e; n++) {
									const s = n / e;
									(h.x = -t * Math.cos(i + s * r) * Math.sin(o + S * a)),
										(h.y = t * Math.cos(o + S * a)),
										(h.z = t * Math.sin(i + s * r) * Math.sin(o + S * a)),
										d.push(h.x, h.y, h.z),
										p.copy(h).normalize(),
										m.push(p.x, p.y, p.z),
										f.push(s + y, 1 - S),
										g.push(c++);
								}
								l.push(g);
							}
							for (let t = 0; t < n; t++)
								for (let i = 0; i < e; i++) {
									const e = l[t][i + 1],
										r = l[t][i],
										a = l[t + 1][i],
										c = l[t + 1][i + 1];
									(0 !== t || o > 0) && u.push(e, r, c),
										(t !== n - 1 || s < Math.PI) && u.push(r, a, c);
								}
							this.setIndex(u),
								this.setAttribute("position", new fa(d, 3)),
								this.setAttribute("normal", new fa(m, 3)),
								this.setAttribute("uv", new fa(f, 2));
						}
						function Ip(t, e, n, i, r, o) {
							Ya.call(this),
								(this.type = "RingGeometry"),
								(this.parameters = {
									innerRadius: t,
									outerRadius: e,
									thetaSegments: n,
									phiSegments: i,
									thetaStart: r,
									thetaLength: o,
								}),
								this.fromBufferGeometry(new vp(t, e, n, i, r, o)),
								this.mergeVertices();
						}
						function vp(t, e, n, i, r, o) {
							Ua.call(this),
								(this.type = "RingBufferGeometry"),
								(this.parameters = {
									innerRadius: t,
									outerRadius: e,
									thetaSegments: n,
									phiSegments: i,
									thetaStart: r,
									thetaLength: o,
								}),
								(t = t || 0.5),
								(e = e || 1),
								(r = void 0 !== r ? r : 0),
								(o = void 0 !== o ? o : 2 * Math.PI),
								(n = void 0 !== n ? Math.max(3, n) : 8);
							const a = [],
								s = [],
								c = [],
								l = [];
							let h = t;
							const p = (e - t) / (i = void 0 !== i ? Math.max(1, i) : 1),
								u = new zr(),
								d = new Rr();
							for (let t = 0; t <= i; t++) {
								for (let t = 0; t <= n; t++) {
									const i = r + (t / n) * o;
									(u.x = h * Math.cos(i)),
										(u.y = h * Math.sin(i)),
										s.push(u.x, u.y, u.z),
										c.push(0, 0, 1),
										(d.x = (u.x / e + 1) / 2),
										(d.y = (u.y / e + 1) / 2),
										l.push(d.x, d.y);
								}
								h += p;
							}
							for (let t = 0; t < i; t++) {
								const e = t * (n + 1);
								for (let t = 0; t < n; t++) {
									const i = t + e,
										r = i,
										o = i + n + 1,
										s = i + n + 2,
										c = i + 1;
									a.push(r, o, c), a.push(o, s, c);
								}
							}
							this.setIndex(a),
								this.setAttribute("position", new fa(s, 3)),
								this.setAttribute("normal", new fa(c, 3)),
								this.setAttribute("uv", new fa(l, 2));
						}
						function kp(t, e, n, i) {
							Ya.call(this),
								(this.type = "LatheGeometry"),
								(this.parameters = {
									points: t,
									segments: e,
									phiStart: n,
									phiLength: i,
								}),
								this.fromBufferGeometry(new Up(t, e, n, i)),
								this.mergeVertices();
						}
						function Up(t, e, n, i) {
							Ua.call(this),
								(this.type = "LatheBufferGeometry"),
								(this.parameters = {
									points: t,
									segments: e,
									phiStart: n,
									phiLength: i,
								}),
								(e = Math.floor(e) || 12),
								(n = n || 0),
								(i = i || 2 * Math.PI),
								(i = qr.clamp(i, 0, 2 * Math.PI));
							const r = [],
								o = [],
								a = [],
								s = 1 / e,
								c = new zr(),
								l = new Rr();
							for (let r = 0; r <= e; r++) {
								const h = n + r * s * i,
									p = Math.sin(h),
									u = Math.cos(h);
								for (let n = 0; n <= t.length - 1; n++)
									(c.x = t[n].x * p),
										(c.y = t[n].y),
										(c.z = t[n].x * u),
										o.push(c.x, c.y, c.z),
										(l.x = r / e),
										(l.y = n / (t.length - 1)),
										a.push(l.x, l.y);
							}
							for (let n = 0; n < e; n++)
								for (let e = 0; e < t.length - 1; e++) {
									const i = e + n * t.length,
										o = i,
										a = i + t.length,
										s = i + t.length + 1,
										c = i + 1;
									r.push(o, a, c), r.push(a, s, c);
								}
							if (
								(this.setIndex(r),
								this.setAttribute("position", new fa(o, 3)),
								this.setAttribute("uv", new fa(a, 2)),
								this.computeVertexNormals(),
								i === 2 * Math.PI)
							) {
								const n = this.attributes.normal.array,
									i = new zr(),
									r = new zr(),
									o = new zr(),
									a = e * t.length * 3;
								for (let e = 0, s = 0; e < t.length; e++, s += 3)
									(i.x = n[s + 0]),
										(i.y = n[s + 1]),
										(i.z = n[s + 2]),
										(r.x = n[a + s + 0]),
										(r.y = n[a + s + 1]),
										(r.z = n[a + s + 2]),
										o.addVectors(i, r).normalize(),
										(n[s + 0] = n[a + s + 0] = o.x),
										(n[s + 1] = n[a + s + 1] = o.y),
										(n[s + 2] = n[a + s + 2] = o.z);
							}
						}
						function wp(t, e) {
							Ya.call(this),
								(this.type = "ShapeGeometry"),
								"object" == typeof e &&
									(console.warn(
										"THREE.ShapeGeometry: Options parameter has been removed."
									),
									(e = e.curveSegments)),
								(this.parameters = { shapes: t, curveSegments: e }),
								this.fromBufferGeometry(new xp(t, e)),
								this.mergeVertices();
						}
						function xp(t, e) {
							Ua.call(this),
								(this.type = "ShapeBufferGeometry"),
								(this.parameters = { shapes: t, curveSegments: e }),
								(e = e || 12);
							const n = [],
								i = [],
								r = [],
								o = [];
							let a = 0,
								s = 0;
							if (!1 === Array.isArray(t)) c(t);
							else
								for (let e = 0; e < t.length; e++)
									c(t[e]), this.addGroup(a, s, e), (a += s), (s = 0);
							function c(t) {
								const a = i.length / 3,
									c = t.extractPoints(e);
								let l = c.shape;
								const h = c.holes;
								!1 === up.isClockWise(l) && (l = l.reverse());
								for (let t = 0, e = h.length; t < e; t++) {
									const e = h[t];
									!0 === up.isClockWise(e) && (h[t] = e.reverse());
								}
								const p = up.triangulateShape(l, h);
								for (let t = 0, e = h.length; t < e; t++) {
									const e = h[t];
									l = l.concat(e);
								}
								for (let t = 0, e = l.length; t < e; t++) {
									const e = l[t];
									i.push(e.x, e.y, 0), r.push(0, 0, 1), o.push(e.x, e.y);
								}
								for (let t = 0, e = p.length; t < e; t++) {
									const e = p[t],
										i = e[0] + a,
										r = e[1] + a,
										o = e[2] + a;
									n.push(i, r, o), (s += 3);
								}
							}
							this.setIndex(n),
								this.setAttribute("position", new fa(i, 3)),
								this.setAttribute("normal", new fa(r, 3)),
								this.setAttribute("uv", new fa(o, 2));
						}
						function Op(t, e) {
							if (((e.shapes = []), Array.isArray(t)))
								for (let n = 0, i = t.length; n < i; n++) {
									const i = t[n];
									e.shapes.push(i.uuid);
								}
							else e.shapes.push(t.uuid);
							return e;
						}
						function bp(t, e) {
							Ua.call(this),
								(this.type = "EdgesGeometry"),
								(this.parameters = { thresholdAngle: e }),
								(e = void 0 !== e ? e : 1);
							const n = [],
								i = Math.cos(qr.DEG2RAD * e),
								r = [0, 0],
								o = {};
							let a, s, c;
							const l = ["a", "b", "c"];
							let h;
							t.isBufferGeometry
								? ((h = new Ya()), h.fromBufferGeometry(t))
								: (h = t.clone()),
								h.mergeVertices(),
								h.computeFaceNormals();
							const p = h.vertices,
								u = h.faces;
							for (let t = 0, e = u.length; t < e; t++) {
								const e = u[t];
								for (let n = 0; n < 3; n++)
									(a = e[l[n]]),
										(s = e[l[(n + 1) % 3]]),
										(r[0] = Math.min(a, s)),
										(r[1] = Math.max(a, s)),
										(c = r[0] + "," + r[1]),
										void 0 === o[c]
											? (o[c] = {
													index1: r[0],
													index2: r[1],
													face1: t,
													face2: void 0,
											  })
											: (o[c].face2 = t);
							}
							for (c in o) {
								const t = o[c];
								if (
									void 0 === t.face2 ||
									u[t.face1].normal.dot(u[t.face2].normal) <= i
								) {
									let e = p[t.index1];
									n.push(e.x, e.y, e.z),
										(e = p[t.index2]),
										n.push(e.x, e.y, e.z);
								}
							}
							this.setAttribute("position", new fa(n, 3));
						}
						function Kp(t, e, n, i, r, o, a, s) {
							Ya.call(this),
								(this.type = "CylinderGeometry"),
								(this.parameters = {
									radiusTop: t,
									radiusBottom: e,
									height: n,
									radialSegments: i,
									heightSegments: r,
									openEnded: o,
									thetaStart: a,
									thetaLength: s,
								}),
								this.fromBufferGeometry(new Tp(t, e, n, i, r, o, a, s)),
								this.mergeVertices();
						}
						function Tp(t, e, n, i, r, o, a, s) {
							Ua.call(this),
								(this.type = "CylinderBufferGeometry"),
								(this.parameters = {
									radiusTop: t,
									radiusBottom: e,
									height: n,
									radialSegments: i,
									heightSegments: r,
									openEnded: o,
									thetaStart: a,
									thetaLength: s,
								});
							const c = this;
							(t = void 0 !== t ? t : 1),
								(e = void 0 !== e ? e : 1),
								(n = n || 1),
								(i = Math.floor(i) || 8),
								(r = Math.floor(r) || 1),
								(o = void 0 !== o && o),
								(a = void 0 !== a ? a : 0),
								(s = void 0 !== s ? s : 2 * Math.PI);
							const l = [],
								h = [],
								p = [],
								u = [];
							let d = 0;
							const m = [],
								f = n / 2;
							let g = 0;
							function S(n) {
								let r, o;
								const m = new Rr(),
									S = new zr();
								let y = 0;
								const V = !0 === n ? t : e,
									q = !0 === n ? 1 : -1;
								r = d;
								for (let t = 1; t <= i; t++)
									h.push(0, f * q, 0), p.push(0, q, 0), u.push(0.5, 0.5), d++;
								o = d;
								for (let t = 0; t <= i; t++) {
									const e = (t / i) * s + a,
										n = Math.cos(e),
										r = Math.sin(e);
									(S.x = V * r),
										(S.y = f * q),
										(S.z = V * n),
										h.push(S.x, S.y, S.z),
										p.push(0, q, 0),
										(m.x = 0.5 * n + 0.5),
										(m.y = 0.5 * r * q + 0.5),
										u.push(m.x, m.y),
										d++;
								}
								for (let t = 0; t < i; t++) {
									const e = r + t,
										i = o + t;
									!0 === n ? l.push(i, i + 1, e) : l.push(i + 1, i, e),
										(y += 3);
								}
								c.addGroup(g, y, !0 === n ? 1 : 2), (g += y);
							}
							!(function () {
								const o = new zr(),
									S = new zr();
								let y = 0;
								const V = (e - t) / n;
								for (let c = 0; c <= r; c++) {
									const l = [],
										g = c / r,
										y = g * (e - t) + t;
									for (let t = 0; t <= i; t++) {
										const e = t / i,
											r = e * s + a,
											c = Math.sin(r),
											m = Math.cos(r);
										(S.x = y * c),
											(S.y = -g * n + f),
											(S.z = y * m),
											h.push(S.x, S.y, S.z),
											o.set(c, V, m).normalize(),
											p.push(o.x, o.y, o.z),
											u.push(e, 1 - g),
											l.push(d++);
									}
									m.push(l);
								}
								for (let t = 0; t < i; t++)
									for (let e = 0; e < r; e++) {
										const n = m[e][t],
											i = m[e + 1][t],
											r = m[e + 1][t + 1],
											o = m[e][t + 1];
										l.push(n, i, o), l.push(i, r, o), (y += 6);
									}
								c.addGroup(g, y, 0), (g += y);
							})(),
								!1 === o && (t > 0 && S(!0), e > 0 && S(!1)),
								this.setIndex(l),
								this.setAttribute("position", new fa(h, 3)),
								this.setAttribute("normal", new fa(p, 3)),
								this.setAttribute("uv", new fa(u, 2));
						}
						function zp(t, e, n, i, r, o, a) {
							Kp.call(this, 0, t, e, n, i, r, o, a),
								(this.type = "ConeGeometry"),
								(this.parameters = {
									radius: t,
									height: e,
									radialSegments: n,
									heightSegments: i,
									openEnded: r,
									thetaStart: o,
									thetaLength: a,
								});
						}
						function Wp(t, e, n, i, r, o, a) {
							Tp.call(this, 0, t, e, n, i, r, o, a),
								(this.type = "ConeBufferGeometry"),
								(this.parameters = {
									radius: t,
									height: e,
									radialSegments: n,
									heightSegments: i,
									openEnded: r,
									thetaStart: o,
									thetaLength: a,
								});
						}
						function Ep(t, e, n, i) {
							Ya.call(this),
								(this.type = "CircleGeometry"),
								(this.parameters = {
									radius: t,
									segments: e,
									thetaStart: n,
									thetaLength: i,
								}),
								this.fromBufferGeometry(new Cp(t, e, n, i)),
								this.mergeVertices();
						}
						function Cp(t, e, n, i) {
							Ua.call(this),
								(this.type = "CircleBufferGeometry"),
								(this.parameters = {
									radius: t,
									segments: e,
									thetaStart: n,
									thetaLength: i,
								}),
								(t = t || 1),
								(e = void 0 !== e ? Math.max(3, e) : 8),
								(n = void 0 !== n ? n : 0),
								(i = void 0 !== i ? i : 2 * Math.PI);
							const r = [],
								o = [],
								a = [],
								s = [],
								c = new zr(),
								l = new Rr();
							o.push(0, 0, 0), a.push(0, 0, 1), s.push(0.5, 0.5);
							for (let r = 0, h = 3; r <= e; r++, h += 3) {
								const p = n + (r / e) * i;
								(c.x = t * Math.cos(p)),
									(c.y = t * Math.sin(p)),
									o.push(c.x, c.y, c.z),
									a.push(0, 0, 1),
									(l.x = (o[h] / t + 1) / 2),
									(l.y = (o[h + 1] / t + 1) / 2),
									s.push(l.x, l.y);
							}
							for (let t = 1; t <= e; t++) r.push(t, t + 1, 0);
							this.setIndex(r),
								this.setAttribute("position", new fa(o, 3)),
								this.setAttribute("normal", new fa(a, 3)),
								this.setAttribute("uv", new fa(s, 2));
						}
						(Vp.prototype = Object.create(Ya.prototype)),
							(Vp.prototype.constructor = Vp),
							(qp.prototype = Object.create(gp.prototype)),
							(qp.prototype.constructor = qp),
							(Rp.prototype = Object.create(Ya.prototype)),
							(Rp.prototype.constructor = Rp),
							(Mp.prototype = Object.create(Ua.prototype)),
							(Mp.prototype.constructor = Mp),
							(Ip.prototype = Object.create(Ya.prototype)),
							(Ip.prototype.constructor = Ip),
							(vp.prototype = Object.create(Ua.prototype)),
							(vp.prototype.constructor = vp),
							(kp.prototype = Object.create(Ya.prototype)),
							(kp.prototype.constructor = kp),
							(Up.prototype = Object.create(Ua.prototype)),
							(Up.prototype.constructor = Up),
							(wp.prototype = Object.create(Ya.prototype)),
							(wp.prototype.constructor = wp),
							(wp.prototype.toJSON = function () {
								const t = Ya.prototype.toJSON.call(this);
								return Op(this.parameters.shapes, t);
							}),
							(xp.prototype = Object.create(Ua.prototype)),
							(xp.prototype.constructor = xp),
							(xp.prototype.toJSON = function () {
								const t = Ua.prototype.toJSON.call(this);
								return Op(this.parameters.shapes, t);
							}),
							(bp.prototype = Object.create(Ua.prototype)),
							(bp.prototype.constructor = bp),
							(Kp.prototype = Object.create(Ya.prototype)),
							(Kp.prototype.constructor = Kp),
							(Tp.prototype = Object.create(Ua.prototype)),
							(Tp.prototype.constructor = Tp),
							(zp.prototype = Object.create(Kp.prototype)),
							(zp.prototype.constructor = zp),
							(Wp.prototype = Object.create(Tp.prototype)),
							(Wp.prototype.constructor = Wp),
							(Ep.prototype = Object.create(Ya.prototype)),
							(Ep.prototype.constructor = Ep),
							(Cp.prototype = Object.create(Ua.prototype)),
							(Cp.prototype.constructor = Cp);
						var Fp = Object.freeze({
							__proto__: null,
							WireframeGeometry: Ih,
							ParametricGeometry: vh,
							ParametricBufferGeometry: kh,
							TetrahedronGeometry: xh,
							TetrahedronBufferGeometry: Oh,
							OctahedronGeometry: bh,
							OctahedronBufferGeometry: Kh,
							IcosahedronGeometry: Th,
							IcosahedronBufferGeometry: zh,
							DodecahedronGeometry: Wh,
							DodecahedronBufferGeometry: Eh,
							PolyhedronGeometry: Uh,
							PolyhedronBufferGeometry: wh,
							TubeGeometry: Ch,
							TubeBufferGeometry: Fh,
							TorusKnotGeometry: Zh,
							TorusKnotBufferGeometry: Hh,
							TorusGeometry: Nh,
							TorusBufferGeometry: jh,
							TextGeometry: Vp,
							TextBufferGeometry: qp,
							SphereGeometry: Rp,
							SphereBufferGeometry: Mp,
							RingGeometry: Ip,
							RingBufferGeometry: vp,
							PlaneGeometry: fs,
							PlaneBufferGeometry: gs,
							LatheGeometry: kp,
							LatheBufferGeometry: Up,
							ShapeGeometry: wp,
							ShapeBufferGeometry: xp,
							ExtrudeGeometry: fp,
							ExtrudeBufferGeometry: gp,
							EdgesGeometry: bp,
							ConeGeometry: zp,
							ConeBufferGeometry: Wp,
							CylinderGeometry: Kp,
							CylinderBufferGeometry: Tp,
							CircleGeometry: Ep,
							CircleBufferGeometry: Cp,
							BoxGeometry: class extends Ya {
								constructor(t, e, n, i, r, o) {
									super(),
										(this.type = "BoxGeometry"),
										(this.parameters = {
											width: t,
											height: e,
											depth: n,
											widthSegments: i,
											heightSegments: r,
											depthSegments: o,
										}),
										this.fromBufferGeometry(new Xa(t, e, n, i, r, o)),
										this.mergeVertices();
								}
							},
							BoxBufferGeometry: Xa,
						});
						function Zp(t) {
							ia.call(this),
								(this.type = "ShadowMaterial"),
								(this.color = new Yo(0)),
								(this.transparent = !0),
								this.setValues(t);
						}
						function Hp(t) {
							ns.call(this, t), (this.type = "RawShaderMaterial");
						}
						function Np(t) {
							ia.call(this),
								(this.defines = { STANDARD: "" }),
								(this.type = "MeshStandardMaterial"),
								(this.color = new Yo(16777215)),
								(this.roughness = 1),
								(this.metalness = 0),
								(this.map = null),
								(this.lightMap = null),
								(this.lightMapIntensity = 1),
								(this.aoMap = null),
								(this.aoMapIntensity = 1),
								(this.emissive = new Yo(0)),
								(this.emissiveIntensity = 1),
								(this.emissiveMap = null),
								(this.bumpMap = null),
								(this.bumpScale = 1),
								(this.normalMap = null),
								(this.normalMapType = 0),
								(this.normalScale = new Rr(1, 1)),
								(this.displacementMap = null),
								(this.displacementScale = 1),
								(this.displacementBias = 0),
								(this.roughnessMap = null),
								(this.metalnessMap = null),
								(this.alphaMap = null),
								(this.envMap = null),
								(this.envMapIntensity = 1),
								(this.refractionRatio = 0.98),
								(this.wireframe = !1),
								(this.wireframeLinewidth = 1),
								(this.wireframeLinecap = "round"),
								(this.wireframeLinejoin = "round"),
								(this.skinning = !1),
								(this.morphTargets = !1),
								(this.morphNormals = !1),
								(this.vertexTangents = !1),
								this.setValues(t);
						}
						function jp(t) {
							Np.call(this),
								(this.defines = { STANDARD: "", PHYSICAL: "" }),
								(this.type = "MeshPhysicalMaterial"),
								(this.clearcoat = 0),
								(this.clearcoatMap = null),
								(this.clearcoatRoughness = 0),
								(this.clearcoatRoughnessMap = null),
								(this.clearcoatNormalScale = new Rr(1, 1)),
								(this.clearcoatNormalMap = null),
								(this.reflectivity = 0.5),
								(this.sheen = null),
								(this.transmission = 0),
								(this.transmissionMap = null),
								this.setValues(t);
						}
						function Dp(t) {
							ia.call(this),
								(this.type = "MeshPhongMaterial"),
								(this.color = new Yo(16777215)),
								(this.specular = new Yo(1118481)),
								(this.shininess = 30),
								(this.map = null),
								(this.lightMap = null),
								(this.lightMapIntensity = 1),
								(this.aoMap = null),
								(this.aoMapIntensity = 1),
								(this.emissive = new Yo(0)),
								(this.emissiveIntensity = 1),
								(this.emissiveMap = null),
								(this.bumpMap = null),
								(this.bumpScale = 1),
								(this.normalMap = null),
								(this.normalMapType = 0),
								(this.normalScale = new Rr(1, 1)),
								(this.displacementMap = null),
								(this.displacementScale = 1),
								(this.displacementBias = 0),
								(this.specularMap = null),
								(this.alphaMap = null),
								(this.envMap = null),
								(this.combine = 0),
								(this.reflectivity = 1),
								(this.refractionRatio = 0.98),
								(this.wireframe = !1),
								(this.wireframeLinewidth = 1),
								(this.wireframeLinecap = "round"),
								(this.wireframeLinejoin = "round"),
								(this.skinning = !1),
								(this.morphTargets = !1),
								(this.morphNormals = !1),
								this.setValues(t);
						}
						function Ap(t) {
							ia.call(this),
								(this.defines = { TOON: "" }),
								(this.type = "MeshToonMaterial"),
								(this.color = new Yo(16777215)),
								(this.map = null),
								(this.gradientMap = null),
								(this.lightMap = null),
								(this.lightMapIntensity = 1),
								(this.aoMap = null),
								(this.aoMapIntensity = 1),
								(this.emissive = new Yo(0)),
								(this.emissiveIntensity = 1),
								(this.emissiveMap = null),
								(this.bumpMap = null),
								(this.bumpScale = 1),
								(this.normalMap = null),
								(this.normalMapType = 0),
								(this.normalScale = new Rr(1, 1)),
								(this.displacementMap = null),
								(this.displacementScale = 1),
								(this.displacementBias = 0),
								(this.alphaMap = null),
								(this.wireframe = !1),
								(this.wireframeLinewidth = 1),
								(this.wireframeLinecap = "round"),
								(this.wireframeLinejoin = "round"),
								(this.skinning = !1),
								(this.morphTargets = !1),
								(this.morphNormals = !1),
								this.setValues(t);
						}
						function Lp(t) {
							ia.call(this),
								(this.type = "MeshNormalMaterial"),
								(this.bumpMap = null),
								(this.bumpScale = 1),
								(this.normalMap = null),
								(this.normalMapType = 0),
								(this.normalScale = new Rr(1, 1)),
								(this.displacementMap = null),
								(this.displacementScale = 1),
								(this.displacementBias = 0),
								(this.wireframe = !1),
								(this.wireframeLinewidth = 1),
								(this.fog = !1),
								(this.skinning = !1),
								(this.morphTargets = !1),
								(this.morphNormals = !1),
								this.setValues(t);
						}
						function Bp(t) {
							ia.call(this),
								(this.type = "MeshLambertMaterial"),
								(this.color = new Yo(16777215)),
								(this.map = null),
								(this.lightMap = null),
								(this.lightMapIntensity = 1),
								(this.aoMap = null),
								(this.aoMapIntensity = 1),
								(this.emissive = new Yo(0)),
								(this.emissiveIntensity = 1),
								(this.emissiveMap = null),
								(this.specularMap = null),
								(this.alphaMap = null),
								(this.envMap = null),
								(this.combine = 0),
								(this.reflectivity = 1),
								(this.refractionRatio = 0.98),
								(this.wireframe = !1),
								(this.wireframeLinewidth = 1),
								(this.wireframeLinecap = "round"),
								(this.wireframeLinejoin = "round"),
								(this.skinning = !1),
								(this.morphTargets = !1),
								(this.morphNormals = !1),
								this.setValues(t);
						}
						function Gp(t) {
							ia.call(this),
								(this.defines = { MATCAP: "" }),
								(this.type = "MeshMatcapMaterial"),
								(this.color = new Yo(16777215)),
								(this.matcap = null),
								(this.map = null),
								(this.bumpMap = null),
								(this.bumpScale = 1),
								(this.normalMap = null),
								(this.normalMapType = 0),
								(this.normalScale = new Rr(1, 1)),
								(this.displacementMap = null),
								(this.displacementScale = 1),
								(this.displacementBias = 0),
								(this.alphaMap = null),
								(this.skinning = !1),
								(this.morphTargets = !1),
								(this.morphNormals = !1),
								this.setValues(t);
						}
						function Qp(t) {
							eh.call(this),
								(this.type = "LineDashedMaterial"),
								(this.scale = 1),
								(this.dashSize = 3),
								(this.gapSize = 1),
								this.setValues(t);
						}
						(Zp.prototype = Object.create(ia.prototype)),
							(Zp.prototype.constructor = Zp),
							(Zp.prototype.isShadowMaterial = !0),
							(Zp.prototype.copy = function (t) {
								return (
									ia.prototype.copy.call(this, t),
									this.color.copy(t.color),
									this
								);
							}),
							(Hp.prototype = Object.create(ns.prototype)),
							(Hp.prototype.constructor = Hp),
							(Hp.prototype.isRawShaderMaterial = !0),
							(Np.prototype = Object.create(ia.prototype)),
							(Np.prototype.constructor = Np),
							(Np.prototype.isMeshStandardMaterial = !0),
							(Np.prototype.copy = function (t) {
								return (
									ia.prototype.copy.call(this, t),
									(this.defines = { STANDARD: "" }),
									this.color.copy(t.color),
									(this.roughness = t.roughness),
									(this.metalness = t.metalness),
									(this.map = t.map),
									(this.lightMap = t.lightMap),
									(this.lightMapIntensity = t.lightMapIntensity),
									(this.aoMap = t.aoMap),
									(this.aoMapIntensity = t.aoMapIntensity),
									this.emissive.copy(t.emissive),
									(this.emissiveMap = t.emissiveMap),
									(this.emissiveIntensity = t.emissiveIntensity),
									(this.bumpMap = t.bumpMap),
									(this.bumpScale = t.bumpScale),
									(this.normalMap = t.normalMap),
									(this.normalMapType = t.normalMapType),
									this.normalScale.copy(t.normalScale),
									(this.displacementMap = t.displacementMap),
									(this.displacementScale = t.displacementScale),
									(this.displacementBias = t.displacementBias),
									(this.roughnessMap = t.roughnessMap),
									(this.metalnessMap = t.metalnessMap),
									(this.alphaMap = t.alphaMap),
									(this.envMap = t.envMap),
									(this.envMapIntensity = t.envMapIntensity),
									(this.refractionRatio = t.refractionRatio),
									(this.wireframe = t.wireframe),
									(this.wireframeLinewidth = t.wireframeLinewidth),
									(this.wireframeLinecap = t.wireframeLinecap),
									(this.wireframeLinejoin = t.wireframeLinejoin),
									(this.skinning = t.skinning),
									(this.morphTargets = t.morphTargets),
									(this.morphNormals = t.morphNormals),
									(this.vertexTangents = t.vertexTangents),
									this
								);
							}),
							(jp.prototype = Object.create(Np.prototype)),
							(jp.prototype.constructor = jp),
							(jp.prototype.isMeshPhysicalMaterial = !0),
							(jp.prototype.copy = function (t) {
								return (
									Np.prototype.copy.call(this, t),
									(this.defines = { STANDARD: "", PHYSICAL: "" }),
									(this.clearcoat = t.clearcoat),
									(this.clearcoatMap = t.clearcoatMap),
									(this.clearcoatRoughness = t.clearcoatRoughness),
									(this.clearcoatRoughnessMap = t.clearcoatRoughnessMap),
									(this.clearcoatNormalMap = t.clearcoatNormalMap),
									this.clearcoatNormalScale.copy(t.clearcoatNormalScale),
									(this.reflectivity = t.reflectivity),
									t.sheen
										? (this.sheen = (this.sheen || new Yo()).copy(t.sheen))
										: (this.sheen = null),
									(this.transmission = t.transmission),
									(this.transmissionMap = t.transmissionMap),
									this
								);
							}),
							(Dp.prototype = Object.create(ia.prototype)),
							(Dp.prototype.constructor = Dp),
							(Dp.prototype.isMeshPhongMaterial = !0),
							(Dp.prototype.copy = function (t) {
								return (
									ia.prototype.copy.call(this, t),
									this.color.copy(t.color),
									this.specular.copy(t.specular),
									(this.shininess = t.shininess),
									(this.map = t.map),
									(this.lightMap = t.lightMap),
									(this.lightMapIntensity = t.lightMapIntensity),
									(this.aoMap = t.aoMap),
									(this.aoMapIntensity = t.aoMapIntensity),
									this.emissive.copy(t.emissive),
									(this.emissiveMap = t.emissiveMap),
									(this.emissiveIntensity = t.emissiveIntensity),
									(this.bumpMap = t.bumpMap),
									(this.bumpScale = t.bumpScale),
									(this.normalMap = t.normalMap),
									(this.normalMapType = t.normalMapType),
									this.normalScale.copy(t.normalScale),
									(this.displacementMap = t.displacementMap),
									(this.displacementScale = t.displacementScale),
									(this.displacementBias = t.displacementBias),
									(this.specularMap = t.specularMap),
									(this.alphaMap = t.alphaMap),
									(this.envMap = t.envMap),
									(this.combine = t.combine),
									(this.reflectivity = t.reflectivity),
									(this.refractionRatio = t.refractionRatio),
									(this.wireframe = t.wireframe),
									(this.wireframeLinewidth = t.wireframeLinewidth),
									(this.wireframeLinecap = t.wireframeLinecap),
									(this.wireframeLinejoin = t.wireframeLinejoin),
									(this.skinning = t.skinning),
									(this.morphTargets = t.morphTargets),
									(this.morphNormals = t.morphNormals),
									this
								);
							}),
							(Ap.prototype = Object.create(ia.prototype)),
							(Ap.prototype.constructor = Ap),
							(Ap.prototype.isMeshToonMaterial = !0),
							(Ap.prototype.copy = function (t) {
								return (
									ia.prototype.copy.call(this, t),
									this.color.copy(t.color),
									(this.map = t.map),
									(this.gradientMap = t.gradientMap),
									(this.lightMap = t.lightMap),
									(this.lightMapIntensity = t.lightMapIntensity),
									(this.aoMap = t.aoMap),
									(this.aoMapIntensity = t.aoMapIntensity),
									this.emissive.copy(t.emissive),
									(this.emissiveMap = t.emissiveMap),
									(this.emissiveIntensity = t.emissiveIntensity),
									(this.bumpMap = t.bumpMap),
									(this.bumpScale = t.bumpScale),
									(this.normalMap = t.normalMap),
									(this.normalMapType = t.normalMapType),
									this.normalScale.copy(t.normalScale),
									(this.displacementMap = t.displacementMap),
									(this.displacementScale = t.displacementScale),
									(this.displacementBias = t.displacementBias),
									(this.alphaMap = t.alphaMap),
									(this.wireframe = t.wireframe),
									(this.wireframeLinewidth = t.wireframeLinewidth),
									(this.wireframeLinecap = t.wireframeLinecap),
									(this.wireframeLinejoin = t.wireframeLinejoin),
									(this.skinning = t.skinning),
									(this.morphTargets = t.morphTargets),
									(this.morphNormals = t.morphNormals),
									this
								);
							}),
							(Lp.prototype = Object.create(ia.prototype)),
							(Lp.prototype.constructor = Lp),
							(Lp.prototype.isMeshNormalMaterial = !0),
							(Lp.prototype.copy = function (t) {
								return (
									ia.prototype.copy.call(this, t),
									(this.bumpMap = t.bumpMap),
									(this.bumpScale = t.bumpScale),
									(this.normalMap = t.normalMap),
									(this.normalMapType = t.normalMapType),
									this.normalScale.copy(t.normalScale),
									(this.displacementMap = t.displacementMap),
									(this.displacementScale = t.displacementScale),
									(this.displacementBias = t.displacementBias),
									(this.wireframe = t.wireframe),
									(this.wireframeLinewidth = t.wireframeLinewidth),
									(this.skinning = t.skinning),
									(this.morphTargets = t.morphTargets),
									(this.morphNormals = t.morphNormals),
									this
								);
							}),
							(Bp.prototype = Object.create(ia.prototype)),
							(Bp.prototype.constructor = Bp),
							(Bp.prototype.isMeshLambertMaterial = !0),
							(Bp.prototype.copy = function (t) {
								return (
									ia.prototype.copy.call(this, t),
									this.color.copy(t.color),
									(this.map = t.map),
									(this.lightMap = t.lightMap),
									(this.lightMapIntensity = t.lightMapIntensity),
									(this.aoMap = t.aoMap),
									(this.aoMapIntensity = t.aoMapIntensity),
									this.emissive.copy(t.emissive),
									(this.emissiveMap = t.emissiveMap),
									(this.emissiveIntensity = t.emissiveIntensity),
									(this.specularMap = t.specularMap),
									(this.alphaMap = t.alphaMap),
									(this.envMap = t.envMap),
									(this.combine = t.combine),
									(this.reflectivity = t.reflectivity),
									(this.refractionRatio = t.refractionRatio),
									(this.wireframe = t.wireframe),
									(this.wireframeLinewidth = t.wireframeLinewidth),
									(this.wireframeLinecap = t.wireframeLinecap),
									(this.wireframeLinejoin = t.wireframeLinejoin),
									(this.skinning = t.skinning),
									(this.morphTargets = t.morphTargets),
									(this.morphNormals = t.morphNormals),
									this
								);
							}),
							(Gp.prototype = Object.create(ia.prototype)),
							(Gp.prototype.constructor = Gp),
							(Gp.prototype.isMeshMatcapMaterial = !0),
							(Gp.prototype.copy = function (t) {
								return (
									ia.prototype.copy.call(this, t),
									(this.defines = { MATCAP: "" }),
									this.color.copy(t.color),
									(this.matcap = t.matcap),
									(this.map = t.map),
									(this.bumpMap = t.bumpMap),
									(this.bumpScale = t.bumpScale),
									(this.normalMap = t.normalMap),
									(this.normalMapType = t.normalMapType),
									this.normalScale.copy(t.normalScale),
									(this.displacementMap = t.displacementMap),
									(this.displacementScale = t.displacementScale),
									(this.displacementBias = t.displacementBias),
									(this.alphaMap = t.alphaMap),
									(this.skinning = t.skinning),
									(this.morphTargets = t.morphTargets),
									(this.morphNormals = t.morphNormals),
									this
								);
							}),
							(Qp.prototype = Object.create(eh.prototype)),
							(Qp.prototype.constructor = Qp),
							(Qp.prototype.isLineDashedMaterial = !0),
							(Qp.prototype.copy = function (t) {
								return (
									eh.prototype.copy.call(this, t),
									(this.scale = t.scale),
									(this.dashSize = t.dashSize),
									(this.gapSize = t.gapSize),
									this
								);
							});
						var _p = Object.freeze({
							__proto__: null,
							ShadowMaterial: Zp,
							SpriteMaterial: Ul,
							RawShaderMaterial: Hp,
							ShaderMaterial: ns,
							PointsMaterial: uh,
							MeshPhysicalMaterial: jp,
							MeshStandardMaterial: Np,
							MeshPhongMaterial: Dp,
							MeshToonMaterial: Ap,
							MeshNormalMaterial: Lp,
							MeshLambertMaterial: Bp,
							MeshDepthMaterial: cl,
							MeshDistanceMaterial: ll,
							MeshBasicMaterial: ra,
							MeshMatcapMaterial: Gp,
							LineDashedMaterial: Qp,
							LineBasicMaterial: eh,
							Material: ia,
						});
						const Pp = {
							arraySlice: function (t, e, n) {
								return Pp.isTypedArray(t)
									? new t.constructor(
											t.subarray(e, void 0 !== n ? n : t.length)
									  )
									: t.slice(e, n);
							},
							convertArray: function (t, e, n) {
								return !t || (!n && t.constructor === e)
									? t
									: "number" == typeof e.BYTES_PER_ELEMENT
									? new e(t)
									: Array.prototype.slice.call(t);
							},
							isTypedArray: function (t) {
								return ArrayBuffer.isView(t) && !(t instanceof DataView);
							},
							getKeyframeOrder: function (t) {
								const e = t.length,
									n = new Array(e);
								for (let t = 0; t !== e; ++t) n[t] = t;
								return (
									n.sort(function (e, n) {
										return t[e] - t[n];
									}),
									n
								);
							},
							sortedArray: function (t, e, n) {
								const i = t.length,
									r = new t.constructor(i);
								for (let o = 0, a = 0; a !== i; ++o) {
									const i = n[o] * e;
									for (let n = 0; n !== e; ++n) r[a++] = t[i + n];
								}
								return r;
							},
							flattenJSON: function (t, e, n, i) {
								let r = 1,
									o = t[0];
								for (; void 0 !== o && void 0 === o[i]; ) o = t[r++];
								if (void 0 === o) return;
								let a = o[i];
								if (void 0 !== a)
									if (Array.isArray(a))
										do {
											(a = o[i]),
												void 0 !== a && (e.push(o.time), n.push.apply(n, a)),
												(o = t[r++]);
										} while (void 0 !== o);
									else if (void 0 !== a.toArray)
										do {
											(a = o[i]),
												void 0 !== a &&
													(e.push(o.time), a.toArray(n, n.length)),
												(o = t[r++]);
										} while (void 0 !== o);
									else
										do {
											(a = o[i]),
												void 0 !== a && (e.push(o.time), n.push(a)),
												(o = t[r++]);
										} while (void 0 !== o);
							},
							subclip: function (t, e, n, i, r) {
								r = r || 30;
								const o = t.clone();
								o.name = e;
								const a = [];
								for (let t = 0; t < o.tracks.length; ++t) {
									const e = o.tracks[t],
										s = e.getValueSize(),
										c = [],
										l = [];
									for (let t = 0; t < e.times.length; ++t) {
										const o = e.times[t] * r;
										if (!(o < n || o >= i)) {
											c.push(e.times[t]);
											for (let n = 0; n < s; ++n) l.push(e.values[t * s + n]);
										}
									}
									0 !== c.length &&
										((e.times = Pp.convertArray(c, e.times.constructor)),
										(e.values = Pp.convertArray(l, e.values.constructor)),
										a.push(e));
								}
								o.tracks = a;
								let s = 1 / 0;
								for (let t = 0; t < o.tracks.length; ++t)
									s > o.tracks[t].times[0] && (s = o.tracks[t].times[0]);
								for (let t = 0; t < o.tracks.length; ++t)
									o.tracks[t].shift(-1 * s);
								return o.resetDuration(), o;
							},
							makeClipAdditive: function (t, e, n, i) {
								void 0 === e && (e = 0),
									void 0 === n && (n = t),
									(void 0 === i || i <= 0) && (i = 30);
								const r = t.tracks.length,
									o = e / i;
								for (let e = 0; e < r; ++e) {
									const i = n.tracks[e],
										r = i.ValueTypeName;
									if ("bool" === r || "string" === r) continue;
									const a = t.tracks.find(function (t) {
										return t.name === i.name && t.ValueTypeName === r;
									});
									if (void 0 === a) continue;
									const s = i.getValueSize(),
										c = i.times.length - 1;
									let l;
									if (o <= i.times[0])
										l = Pp.arraySlice(i.values, 0, i.valueSize);
									else if (o >= i.times[c]) {
										const t = c * s;
										l = Pp.arraySlice(i.values, t);
									} else {
										const t = i.createInterpolant();
										t.evaluate(o), (l = t.resultBuffer);
									}
									"quaternion" === r &&
										new br(l[0], l[1], l[2], l[3])
											.normalize()
											.conjugate()
											.toArray(l);
									const h = a.times.length;
									for (let t = 0; t < h; ++t) {
										const e = t * s;
										if ("quaternion" === r)
											br.multiplyQuaternionsFlat(
												a.values,
												e,
												l,
												0,
												a.values,
												e
											);
										else for (let t = 0; t < s; ++t) a.values[e + t] -= l[t];
									}
								}
								return (t.blendMode = 2501), t;
							},
						};
						function Jp(t, e, n, i) {
							(this.parameterPositions = t),
								(this._cachedIndex = 0),
								(this.resultBuffer = void 0 !== i ? i : new e.constructor(n)),
								(this.sampleValues = e),
								(this.valueSize = n);
						}
						function Yp(t, e, n, i) {
							Jp.call(this, t, e, n, i),
								(this._weightPrev = -0),
								(this._offsetPrev = -0),
								(this._weightNext = -0),
								(this._offsetNext = -0);
						}
						function Xp(t, e, n, i) {
							Jp.call(this, t, e, n, i);
						}
						function $p(t, e, n, i) {
							Jp.call(this, t, e, n, i);
						}
						function tu(t, e, n, i) {
							if (void 0 === t)
								throw new Error("THREE.KeyframeTrack: track name is undefined");
							if (void 0 === e || 0 === e.length)
								throw new Error(
									"THREE.KeyframeTrack: no keyframes in track named " + t
								);
							(this.name = t),
								(this.times = Pp.convertArray(e, this.TimeBufferType)),
								(this.values = Pp.convertArray(n, this.ValueBufferType)),
								this.setInterpolation(i || this.DefaultInterpolation);
						}
						function eu(t, e, n) {
							tu.call(this, t, e, n);
						}
						function nu(t, e, n, i) {
							tu.call(this, t, e, n, i);
						}
						function iu(t, e, n, i) {
							tu.call(this, t, e, n, i);
						}
						function ru(t, e, n, i) {
							Jp.call(this, t, e, n, i);
						}
						function ou(t, e, n, i) {
							tu.call(this, t, e, n, i);
						}
						function au(t, e, n, i) {
							tu.call(this, t, e, n, i);
						}
						function su(t, e, n, i) {
							tu.call(this, t, e, n, i);
						}
						function cu(t, e, n, i) {
							(this.name = t),
								(this.tracks = n),
								(this.duration = void 0 !== e ? e : -1),
								(this.blendMode = void 0 !== i ? i : lr),
								(this.uuid = qr.generateUUID()),
								this.duration < 0 && this.resetDuration();
						}
						function lu(t) {
							if (void 0 === t.type)
								throw new Error(
									"THREE.KeyframeTrack: track type undefined, can not parse"
								);
							const e = (function (t) {
								switch (t.toLowerCase()) {
									case "scalar":
									case "double":
									case "float":
									case "number":
									case "integer":
										return iu;
									case "vector":
									case "vector2":
									case "vector3":
									case "vector4":
										return su;
									case "color":
										return nu;
									case "quaternion":
										return ou;
									case "bool":
									case "boolean":
										return eu;
									case "string":
										return au;
								}
								throw new Error(
									"THREE.KeyframeTrack: Unsupported typeName: " + t
								);
							})(t.type);
							if (void 0 === t.times) {
								const e = [],
									n = [];
								Pp.flattenJSON(t.keys, e, n, "value"),
									(t.times = e),
									(t.values = n);
							}
							return void 0 !== e.parse
								? e.parse(t)
								: new e(t.name, t.times, t.values, t.interpolation);
						}
						Object.assign(Jp.prototype, {
							evaluate: function (t) {
								let e = this.parameterPositions,
									n = this._cachedIndex,
									i = e[n],
									r = e[n - 1];
								t: {
									e: {
										let o;
										n: {
											i: if (!(t < i)) {
												for (let o = n + 2; ; ) {
													if (void 0 === i) {
														if (t < r) break i;
														return (
															(n = e.length),
															(this._cachedIndex = n),
															this.afterEnd_(n - 1, t, r)
														);
													}
													if (n === o) break;
													if (((r = i), (i = e[++n]), t < i)) break e;
												}
												o = e.length;
												break n;
											}
											if (t >= r) break t;
											{
												const a = e[1];
												t < a && ((n = 2), (r = a));
												for (let o = n - 2; ; ) {
													if (void 0 === r)
														return (
															(this._cachedIndex = 0),
															this.beforeStart_(0, t, i)
														);
													if (n === o) break;
													if (((i = r), (r = e[--n - 1]), t >= r)) break e;
												}
												(o = n), (n = 0);
											}
										}
										for (; n < o; ) {
											const i = (n + o) >>> 1;
											t < e[i] ? (o = i) : (n = i + 1);
										}
										if (((i = e[n]), (r = e[n - 1]), void 0 === r))
											return (
												(this._cachedIndex = 0), this.beforeStart_(0, t, i)
											);
										if (void 0 === i)
											return (
												(n = e.length),
												(this._cachedIndex = n),
												this.afterEnd_(n - 1, r, t)
											);
									}
									(this._cachedIndex = n), this.intervalChanged_(n, r, i);
								}
								return this.interpolate_(n, r, t, i);
							},
							settings: null,
							DefaultSettings_: {},
							getSettings_: function () {
								return this.settings || this.DefaultSettings_;
							},
							copySampleValue_: function (t) {
								const e = this.resultBuffer,
									n = this.sampleValues,
									i = this.valueSize,
									r = t * i;
								for (let t = 0; t !== i; ++t) e[t] = n[r + t];
								return e;
							},
							interpolate_: function () {
								throw new Error("call to abstract method");
							},
							intervalChanged_: function () {},
						}),
							Object.assign(Jp.prototype, {
								beforeStart_: Jp.prototype.copySampleValue_,
								afterEnd_: Jp.prototype.copySampleValue_,
							}),
							(Yp.prototype = Object.assign(Object.create(Jp.prototype), {
								constructor: Yp,
								DefaultSettings_: { endingStart: ar, endingEnd: ar },
								intervalChanged_: function (t, e, n) {
									let i = this.parameterPositions,
										r = t - 2,
										o = t + 1,
										a = i[r],
										s = i[o];
									if (void 0 === a)
										switch (this.getSettings_().endingStart) {
											case sr:
												(r = t), (a = 2 * e - n);
												break;
											case cr:
												(r = i.length - 2), (a = e + i[r] - i[r + 1]);
												break;
											default:
												(r = t), (a = n);
										}
									if (void 0 === s)
										switch (this.getSettings_().endingEnd) {
											case sr:
												(o = t), (s = 2 * n - e);
												break;
											case cr:
												(o = 1), (s = n + i[1] - i[0]);
												break;
											default:
												(o = t - 1), (s = e);
										}
									const c = 0.5 * (n - e),
										l = this.valueSize;
									(this._weightPrev = c / (e - a)),
										(this._weightNext = c / (s - n)),
										(this._offsetPrev = r * l),
										(this._offsetNext = o * l);
								},
								interpolate_: function (t, e, n, i) {
									const r = this.resultBuffer,
										o = this.sampleValues,
										a = this.valueSize,
										s = t * a,
										c = s - a,
										l = this._offsetPrev,
										h = this._offsetNext,
										p = this._weightPrev,
										u = this._weightNext,
										d = (n - e) / (i - e),
										m = d * d,
										f = m * d,
										g = -p * f + 2 * p * m - p * d,
										S = (1 + p) * f + (-1.5 - 2 * p) * m + (-0.5 + p) * d + 1,
										y = (-1 - u) * f + (1.5 + u) * m + 0.5 * d,
										V = u * f - u * m;
									for (let t = 0; t !== a; ++t)
										r[t] =
											g * o[l + t] + S * o[c + t] + y * o[s + t] + V * o[h + t];
									return r;
								},
							})),
							(Xp.prototype = Object.assign(Object.create(Jp.prototype), {
								constructor: Xp,
								interpolate_: function (t, e, n, i) {
									const r = this.resultBuffer,
										o = this.sampleValues,
										a = this.valueSize,
										s = t * a,
										c = s - a,
										l = (n - e) / (i - e),
										h = 1 - l;
									for (let t = 0; t !== a; ++t)
										r[t] = o[c + t] * h + o[s + t] * l;
									return r;
								},
							})),
							($p.prototype = Object.assign(Object.create(Jp.prototype), {
								constructor: $p,
								interpolate_: function (t) {
									return this.copySampleValue_(t - 1);
								},
							})),
							Object.assign(tu, {
								toJSON: function (t) {
									const e = t.constructor;
									let n;
									if (void 0 !== e.toJSON) n = e.toJSON(t);
									else {
										n = {
											name: t.name,
											times: Pp.convertArray(t.times, Array),
											values: Pp.convertArray(t.values, Array),
										};
										const e = t.getInterpolation();
										e !== t.DefaultInterpolation && (n.interpolation = e);
									}
									return (n.type = t.ValueTypeName), n;
								},
							}),
							Object.assign(tu.prototype, {
								constructor: tu,
								TimeBufferType: Float32Array,
								ValueBufferType: Float32Array,
								DefaultInterpolation: rr,
								InterpolantFactoryMethodDiscrete: function (t) {
									return new $p(
										this.times,
										this.values,
										this.getValueSize(),
										t
									);
								},
								InterpolantFactoryMethodLinear: function (t) {
									return new Xp(
										this.times,
										this.values,
										this.getValueSize(),
										t
									);
								},
								InterpolantFactoryMethodSmooth: function (t) {
									return new Yp(
										this.times,
										this.values,
										this.getValueSize(),
										t
									);
								},
								setInterpolation: function (t) {
									let e;
									switch (t) {
										case ir:
											e = this.InterpolantFactoryMethodDiscrete;
											break;
										case rr:
											e = this.InterpolantFactoryMethodLinear;
											break;
										case or:
											e = this.InterpolantFactoryMethodSmooth;
									}
									if (void 0 === e) {
										const e =
											"unsupported interpolation for " +
											this.ValueTypeName +
											" keyframe track named " +
											this.name;
										if (void 0 === this.createInterpolant) {
											if (t === this.DefaultInterpolation) throw new Error(e);
											this.setInterpolation(this.DefaultInterpolation);
										}
										return console.warn("THREE.KeyframeTrack:", e), this;
									}
									return (this.createInterpolant = e), this;
								},
								getInterpolation: function () {
									switch (this.createInterpolant) {
										case this.InterpolantFactoryMethodDiscrete:
											return ir;
										case this.InterpolantFactoryMethodLinear:
											return rr;
										case this.InterpolantFactoryMethodSmooth:
											return or;
									}
								},
								getValueSize: function () {
									return this.values.length / this.times.length;
								},
								shift: function (t) {
									if (0 !== t) {
										const e = this.times;
										for (let n = 0, i = e.length; n !== i; ++n) e[n] += t;
									}
									return this;
								},
								scale: function (t) {
									if (1 !== t) {
										const e = this.times;
										for (let n = 0, i = e.length; n !== i; ++n) e[n] *= t;
									}
									return this;
								},
								trim: function (t, e) {
									const n = this.times,
										i = n.length;
									let r = 0,
										o = i - 1;
									for (; r !== i && n[r] < t; ) ++r;
									for (; -1 !== o && n[o] > e; ) --o;
									if ((++o, 0 !== r || o !== i)) {
										r >= o && ((o = Math.max(o, 1)), (r = o - 1));
										const t = this.getValueSize();
										(this.times = Pp.arraySlice(n, r, o)),
											(this.values = Pp.arraySlice(this.values, r * t, o * t));
									}
									return this;
								},
								validate: function () {
									let t = !0;
									const e = this.getValueSize();
									e - Math.floor(e) != 0 &&
										(console.error(
											"THREE.KeyframeTrack: Invalid value size in track.",
											this
										),
										(t = !1));
									const n = this.times,
										i = this.values,
										r = n.length;
									0 === r &&
										(console.error(
											"THREE.KeyframeTrack: Track is empty.",
											this
										),
										(t = !1));
									let o = null;
									for (let e = 0; e !== r; e++) {
										const i = n[e];
										if ("number" == typeof i && isNaN(i)) {
											console.error(
												"THREE.KeyframeTrack: Time is not a valid number.",
												this,
												e,
												i
											),
												(t = !1);
											break;
										}
										if (null !== o && o > i) {
											console.error(
												"THREE.KeyframeTrack: Out of order keys.",
												this,
												e,
												i,
												o
											),
												(t = !1);
											break;
										}
										o = i;
									}
									if (void 0 !== i && Pp.isTypedArray(i))
										for (let e = 0, n = i.length; e !== n; ++e) {
											const n = i[e];
											if (isNaN(n)) {
												console.error(
													"THREE.KeyframeTrack: Value is not a valid number.",
													this,
													e,
													n
												),
													(t = !1);
												break;
											}
										}
									return t;
								},
								optimize: function () {
									const t = Pp.arraySlice(this.times),
										e = Pp.arraySlice(this.values),
										n = this.getValueSize(),
										i = this.getInterpolation() === or,
										r = t.length - 1;
									let o = 1;
									for (let a = 1; a < r; ++a) {
										let r = !1;
										const s = t[a];
										if (s !== t[a + 1] && (1 !== a || s !== s[0]))
											if (i) r = !0;
											else {
												const t = a * n,
													i = t - n,
													o = t + n;
												for (let a = 0; a !== n; ++a) {
													const n = e[t + a];
													if (n !== e[i + a] || n !== e[o + a]) {
														r = !0;
														break;
													}
												}
											}
										if (r) {
											if (a !== o) {
												t[o] = t[a];
												const i = a * n,
													r = o * n;
												for (let t = 0; t !== n; ++t) e[r + t] = e[i + t];
											}
											++o;
										}
									}
									if (r > 0) {
										t[o] = t[r];
										for (let t = r * n, i = o * n, a = 0; a !== n; ++a)
											e[i + a] = e[t + a];
										++o;
									}
									return (
										o !== t.length
											? ((this.times = Pp.arraySlice(t, 0, o)),
											  (this.values = Pp.arraySlice(e, 0, o * n)))
											: ((this.times = t), (this.values = e)),
										this
									);
								},
								clone: function () {
									const t = Pp.arraySlice(this.times, 0),
										e = Pp.arraySlice(this.values, 0),
										n = new (0, this.constructor)(this.name, t, e);
									return (n.createInterpolant = this.createInterpolant), n;
								},
							}),
							(eu.prototype = Object.assign(Object.create(tu.prototype), {
								constructor: eu,
								ValueTypeName: "bool",
								ValueBufferType: Array,
								DefaultInterpolation: ir,
								InterpolantFactoryMethodLinear: void 0,
								InterpolantFactoryMethodSmooth: void 0,
							})),
							(nu.prototype = Object.assign(Object.create(tu.prototype), {
								constructor: nu,
								ValueTypeName: "color",
							})),
							(iu.prototype = Object.assign(Object.create(tu.prototype), {
								constructor: iu,
								ValueTypeName: "number",
							})),
							(ru.prototype = Object.assign(Object.create(Jp.prototype), {
								constructor: ru,
								interpolate_: function (t, e, n, i) {
									const r = this.resultBuffer,
										o = this.sampleValues,
										a = this.valueSize,
										s = (n - e) / (i - e);
									let c = t * a;
									for (let t = c + a; c !== t; c += 4)
										br.slerpFlat(r, 0, o, c - a, o, c, s);
									return r;
								},
							})),
							(ou.prototype = Object.assign(Object.create(tu.prototype), {
								constructor: ou,
								ValueTypeName: "quaternion",
								DefaultInterpolation: rr,
								InterpolantFactoryMethodLinear: function (t) {
									return new ru(
										this.times,
										this.values,
										this.getValueSize(),
										t
									);
								},
								InterpolantFactoryMethodSmooth: void 0,
							})),
							(au.prototype = Object.assign(Object.create(tu.prototype), {
								constructor: au,
								ValueTypeName: "string",
								ValueBufferType: Array,
								DefaultInterpolation: ir,
								InterpolantFactoryMethodLinear: void 0,
								InterpolantFactoryMethodSmooth: void 0,
							})),
							(su.prototype = Object.assign(Object.create(tu.prototype), {
								constructor: su,
								ValueTypeName: "vector",
							})),
							Object.assign(cu, {
								parse: function (t) {
									const e = [],
										n = t.tracks,
										i = 1 / (t.fps || 1);
									for (let t = 0, r = n.length; t !== r; ++t)
										e.push(lu(n[t]).scale(i));
									return new cu(t.name, t.duration, e, t.blendMode);
								},
								toJSON: function (t) {
									const e = [],
										n = t.tracks,
										i = {
											name: t.name,
											duration: t.duration,
											tracks: e,
											uuid: t.uuid,
											blendMode: t.blendMode,
										};
									for (let t = 0, i = n.length; t !== i; ++t)
										e.push(tu.toJSON(n[t]));
									return i;
								},
								CreateFromMorphTargetSequence: function (t, e, n, i) {
									const r = e.length,
										o = [];
									for (let t = 0; t < r; t++) {
										let a = [],
											s = [];
										a.push((t + r - 1) % r, t, (t + 1) % r), s.push(0, 1, 0);
										const c = Pp.getKeyframeOrder(a);
										(a = Pp.sortedArray(a, 1, c)),
											(s = Pp.sortedArray(s, 1, c)),
											i || 0 !== a[0] || (a.push(r), s.push(s[0])),
											o.push(
												new iu(
													".morphTargetInfluences[" + e[t].name + "]",
													a,
													s
												).scale(1 / n)
											);
									}
									return new cu(t, -1, o);
								},
								findByName: function (t, e) {
									let n = t;
									if (!Array.isArray(t)) {
										const e = t;
										n = (e.geometry && e.geometry.animations) || e.animations;
									}
									for (let t = 0; t < n.length; t++)
										if (n[t].name === e) return n[t];
									return null;
								},
								CreateClipsFromMorphTargetSequences: function (t, e, n) {
									const i = {},
										r = /^([\w-]*?)([\d]+)$/;
									for (let e = 0, n = t.length; e < n; e++) {
										const n = t[e],
											o = n.name.match(r);
										if (o && o.length > 1) {
											const t = o[1];
											let e = i[t];
											e || (i[t] = e = []), e.push(n);
										}
									}
									const o = [];
									for (const t in i)
										o.push(cu.CreateFromMorphTargetSequence(t, i[t], e, n));
									return o;
								},
								parseAnimation: function (t, e) {
									if (!t)
										return (
											console.error(
												"THREE.AnimationClip: No animation in JSONLoader data."
											),
											null
										);
									const n = function (t, e, n, i, r) {
											if (0 !== n.length) {
												const o = [],
													a = [];
												Pp.flattenJSON(n, o, a, i),
													0 !== o.length && r.push(new t(e, o, a));
											}
										},
										i = [],
										r = t.name || "default",
										o = t.fps || 30,
										a = t.blendMode;
									let s = t.length || -1;
									const c = t.hierarchy || [];
									for (let t = 0; t < c.length; t++) {
										const r = c[t].keys;
										if (r && 0 !== r.length)
											if (r[0].morphTargets) {
												const t = {};
												let e;
												for (e = 0; e < r.length; e++)
													if (r[e].morphTargets)
														for (let n = 0; n < r[e].morphTargets.length; n++)
															t[r[e].morphTargets[n]] = -1;
												for (const n in t) {
													const t = [],
														o = [];
													for (let i = 0; i !== r[e].morphTargets.length; ++i) {
														const i = r[e];
														t.push(i.time), o.push(i.morphTarget === n ? 1 : 0);
													}
													i.push(
														new iu(".morphTargetInfluence[" + n + "]", t, o)
													);
												}
												s = t.length * (o || 1);
											} else {
												const o = ".bones[" + e[t].name + "]";
												n(su, o + ".position", r, "pos", i),
													n(ou, o + ".quaternion", r, "rot", i),
													n(su, o + ".scale", r, "scl", i);
											}
									}
									return 0 === i.length ? null : new cu(r, s, i, a);
								},
							}),
							Object.assign(cu.prototype, {
								resetDuration: function () {
									let t = 0;
									for (let e = 0, n = this.tracks.length; e !== n; ++e) {
										const n = this.tracks[e];
										t = Math.max(t, n.times[n.times.length - 1]);
									}
									return (this.duration = t), this;
								},
								trim: function () {
									for (let t = 0; t < this.tracks.length; t++)
										this.tracks[t].trim(0, this.duration);
									return this;
								},
								validate: function () {
									let t = !0;
									for (let e = 0; e < this.tracks.length; e++)
										t = t && this.tracks[e].validate();
									return t;
								},
								optimize: function () {
									for (let t = 0; t < this.tracks.length; t++)
										this.tracks[t].optimize();
									return this;
								},
								clone: function () {
									const t = [];
									for (let e = 0; e < this.tracks.length; e++)
										t.push(this.tracks[e].clone());
									return new cu(this.name, this.duration, t, this.blendMode);
								},
							});
						const hu = {
							enabled: !1,
							files: {},
							add: function (t, e) {
								!1 !== this.enabled && (this.files[t] = e);
							},
							get: function (t) {
								if (!1 !== this.enabled) return this.files[t];
							},
							remove: function (t) {
								delete this.files[t];
							},
							clear: function () {
								this.files = {};
							},
						};
						function pu(t, e, n) {
							const i = this;
							let r,
								o = !1,
								a = 0,
								s = 0;
							const c = [];
							(this.onStart = void 0),
								(this.onLoad = t),
								(this.onProgress = e),
								(this.onError = n),
								(this.itemStart = function (t) {
									s++,
										!1 === o && void 0 !== i.onStart && i.onStart(t, a, s),
										(o = !0);
								}),
								(this.itemEnd = function (t) {
									a++,
										void 0 !== i.onProgress && i.onProgress(t, a, s),
										a === s && ((o = !1), void 0 !== i.onLoad && i.onLoad());
								}),
								(this.itemError = function (t) {
									void 0 !== i.onError && i.onError(t);
								}),
								(this.resolveURL = function (t) {
									return r ? r(t) : t;
								}),
								(this.setURLModifier = function (t) {
									return (r = t), this;
								}),
								(this.addHandler = function (t, e) {
									return c.push(t, e), this;
								}),
								(this.removeHandler = function (t) {
									const e = c.indexOf(t);
									return -1 !== e && c.splice(e, 2), this;
								}),
								(this.getHandler = function (t) {
									for (let e = 0, n = c.length; e < n; e += 2) {
										const n = c[e],
											i = c[e + 1];
										if ((n.global && (n.lastIndex = 0), n.test(t))) return i;
									}
									return null;
								});
						}
						const uu = new pu();
						function du(t) {
							(this.manager = void 0 !== t ? t : uu),
								(this.crossOrigin = "anonymous"),
								(this.path = ""),
								(this.resourcePath = ""),
								(this.requestHeader = {});
						}
						Object.assign(du.prototype, {
							load: function () {},
							loadAsync: function (t, e) {
								const n = this;
								return new Promise(function (i, r) {
									n.load(t, i, e, r);
								});
							},
							parse: function () {},
							setCrossOrigin: function (t) {
								return (this.crossOrigin = t), this;
							},
							setPath: function (t) {
								return (this.path = t), this;
							},
							setResourcePath: function (t) {
								return (this.resourcePath = t), this;
							},
							setRequestHeader: function (t) {
								return (this.requestHeader = t), this;
							},
						});
						const mu = {};
						function fu(t) {
							du.call(this, t);
						}
						function gu(t) {
							du.call(this, t);
						}
						function Su(t) {
							du.call(this, t);
						}
						function yu(t) {
							du.call(this, t);
						}
						function Vu(t) {
							du.call(this, t);
						}
						function qu(t) {
							du.call(this, t);
						}
						function Ru(t) {
							du.call(this, t);
						}
						function Mu() {
							(this.type = "Curve"), (this.arcLengthDivisions = 200);
						}
						function Iu(t, e, n, i, r, o, a, s) {
							Mu.call(this),
								(this.type = "EllipseCurve"),
								(this.aX = t || 0),
								(this.aY = e || 0),
								(this.xRadius = n || 1),
								(this.yRadius = i || 1),
								(this.aStartAngle = r || 0),
								(this.aEndAngle = o || 2 * Math.PI),
								(this.aClockwise = a || !1),
								(this.aRotation = s || 0);
						}
						function vu(t, e, n, i, r, o) {
							Iu.call(this, t, e, n, n, i, r, o), (this.type = "ArcCurve");
						}
						function ku() {
							let t = 0,
								e = 0,
								n = 0,
								i = 0;
							function r(r, o, a, s) {
								(t = r),
									(e = a),
									(n = -3 * r + 3 * o - 2 * a - s),
									(i = 2 * r - 2 * o + a + s);
							}
							return {
								initCatmullRom: function (t, e, n, i, o) {
									r(e, n, o * (n - t), o * (i - e));
								},
								initNonuniformCatmullRom: function (t, e, n, i, o, a, s) {
									let c = (e - t) / o - (n - t) / (o + a) + (n - e) / a,
										l = (n - e) / a - (i - e) / (a + s) + (i - n) / s;
									(c *= a), (l *= a), r(e, n, c, l);
								},
								calc: function (r) {
									const o = r * r;
									return t + e * r + n * o + i * (o * r);
								},
							};
						}
						(fu.prototype = Object.assign(Object.create(du.prototype), {
							constructor: fu,
							load: function (t, e, n, i) {
								void 0 === t && (t = ""),
									void 0 !== this.path && (t = this.path + t),
									(t = this.manager.resolveURL(t));
								const r = this,
									o = hu.get(t);
								if (void 0 !== o)
									return (
										r.manager.itemStart(t),
										setTimeout(function () {
											e && e(o), r.manager.itemEnd(t);
										}, 0),
										o
									);
								if (void 0 !== mu[t])
									return void mu[t].push({
										onLoad: e,
										onProgress: n,
										onError: i,
									});
								const a = t.match(/^data:(.*?)(;base64)?,(.*)$/);
								let s;
								if (a) {
									const n = a[1],
										o = !!a[2];
									let s = a[3];
									(s = decodeURIComponent(s)), o && (s = atob(s));
									try {
										let i;
										const o = (this.responseType || "").toLowerCase();
										switch (o) {
											case "arraybuffer":
											case "blob":
												const t = new Uint8Array(s.length);
												for (let e = 0; e < s.length; e++)
													t[e] = s.charCodeAt(e);
												i =
													"blob" === o
														? new Blob([t.buffer], { type: n })
														: t.buffer;
												break;
											case "document":
												const e = new DOMParser();
												i = e.parseFromString(s, n);
												break;
											case "json":
												i = JSON.parse(s);
												break;
											default:
												i = s;
										}
										setTimeout(function () {
											e && e(i), r.manager.itemEnd(t);
										}, 0);
									} catch (e) {
										setTimeout(function () {
											i && i(e), r.manager.itemError(t), r.manager.itemEnd(t);
										}, 0);
									}
								} else {
									(mu[t] = []),
										mu[t].push({ onLoad: e, onProgress: n, onError: i }),
										(s = new XMLHttpRequest()),
										s.open("GET", t, !0),
										s.addEventListener(
											"load",
											function (e) {
												const n = this.response,
													i = mu[t];
												if (
													(delete mu[t],
													200 === this.status || 0 === this.status)
												) {
													0 === this.status &&
														console.warn(
															"THREE.FileLoader: HTTP Status 0 received."
														),
														hu.add(t, n);
													for (let t = 0, e = i.length; t < e; t++) {
														const e = i[t];
														e.onLoad && e.onLoad(n);
													}
													r.manager.itemEnd(t);
												} else {
													for (let t = 0, n = i.length; t < n; t++) {
														const n = i[t];
														n.onError && n.onError(e);
													}
													r.manager.itemError(t), r.manager.itemEnd(t);
												}
											},
											!1
										),
										s.addEventListener(
											"progress",
											function (e) {
												const n = mu[t];
												for (let t = 0, i = n.length; t < i; t++) {
													const i = n[t];
													i.onProgress && i.onProgress(e);
												}
											},
											!1
										),
										s.addEventListener(
											"error",
											function (e) {
												const n = mu[t];
												delete mu[t];
												for (let t = 0, i = n.length; t < i; t++) {
													const i = n[t];
													i.onError && i.onError(e);
												}
												r.manager.itemError(t), r.manager.itemEnd(t);
											},
											!1
										),
										s.addEventListener(
											"abort",
											function (e) {
												const n = mu[t];
												delete mu[t];
												for (let t = 0, i = n.length; t < i; t++) {
													const i = n[t];
													i.onError && i.onError(e);
												}
												r.manager.itemError(t), r.manager.itemEnd(t);
											},
											!1
										),
										void 0 !== this.responseType &&
											(s.responseType = this.responseType),
										void 0 !== this.withCredentials &&
											(s.withCredentials = this.withCredentials),
										s.overrideMimeType &&
											s.overrideMimeType(
												void 0 !== this.mimeType ? this.mimeType : "text/plain"
											);
									for (const t in this.requestHeader)
										s.setRequestHeader(t, this.requestHeader[t]);
									s.send(null);
								}
								return r.manager.itemStart(t), s;
							},
							setResponseType: function (t) {
								return (this.responseType = t), this;
							},
							setWithCredentials: function (t) {
								return (this.withCredentials = t), this;
							},
							setMimeType: function (t) {
								return (this.mimeType = t), this;
							},
						})),
							(gu.prototype = Object.assign(Object.create(du.prototype), {
								constructor: gu,
								load: function (t, e, n, i) {
									const r = this,
										o = new fu(r.manager);
									o.setPath(r.path),
										o.setRequestHeader(r.requestHeader),
										o.load(
											t,
											function (n) {
												try {
													e(r.parse(JSON.parse(n)));
												} catch (e) {
													i ? i(e) : console.error(e), r.manager.itemError(t);
												}
											},
											n,
											i
										);
								},
								parse: function (t) {
									const e = [];
									for (let n = 0; n < t.length; n++) {
										const i = cu.parse(t[n]);
										e.push(i);
									}
									return e;
								},
							})),
							(Su.prototype = Object.assign(Object.create(du.prototype), {
								constructor: Su,
								load: function (t, e, n, i) {
									const r = this,
										o = [],
										a = new qh();
									a.image = o;
									const s = new fu(this.manager);
									s.setPath(this.path),
										s.setResponseType("arraybuffer"),
										s.setRequestHeader(this.requestHeader);
									let c = 0;
									function l(l) {
										s.load(
											t[l],
											function (t) {
												const n = r.parse(t, !0);
												(o[l] = {
													width: n.width,
													height: n.height,
													format: n.format,
													mipmaps: n.mipmaps,
												}),
													(c += 1),
													6 === c &&
														(1 === n.mipmapCount && (a.minFilter = Bi),
														(a.format = n.format),
														(a.needsUpdate = !0),
														e && e(a));
											},
											n,
											i
										);
									}
									if (Array.isArray(t))
										for (let e = 0, n = t.length; e < n; ++e) l(e);
									else
										s.load(
											t,
											function (t) {
												const n = r.parse(t, !0);
												if (n.isCubemap) {
													const t = n.mipmaps.length / n.mipmapCount;
													for (let e = 0; e < t; e++) {
														o[e] = { mipmaps: [] };
														for (let t = 0; t < n.mipmapCount; t++)
															o[e].mipmaps.push(
																n.mipmaps[e * n.mipmapCount + t]
															),
																(o[e].format = n.format),
																(o[e].width = n.width),
																(o[e].height = n.height);
													}
												} else
													(a.image.width = n.width),
														(a.image.height = n.height),
														(a.mipmaps = n.mipmaps);
												1 === n.mipmapCount && (a.minFilter = Bi),
													(a.format = n.format),
													(a.needsUpdate = !0),
													e && e(a);
											},
											n,
											i
										);
									return a;
								},
							})),
							(yu.prototype = Object.assign(Object.create(du.prototype), {
								constructor: yu,
								load: function (t, e, n, i) {
									const r = this,
										o = new cs(),
										a = new fu(this.manager);
									return (
										a.setResponseType("arraybuffer"),
										a.setRequestHeader(this.requestHeader),
										a.setPath(this.path),
										a.load(
											t,
											function (t) {
												const n = r.parse(t);
												n &&
													(void 0 !== n.image
														? (o.image = n.image)
														: void 0 !== n.data &&
														  ((o.image.width = n.width),
														  (o.image.height = n.height),
														  (o.image.data = n.data)),
													(o.wrapS = void 0 !== n.wrapS ? n.wrapS : Ni),
													(o.wrapT = void 0 !== n.wrapT ? n.wrapT : Ni),
													(o.magFilter =
														void 0 !== n.magFilter ? n.magFilter : Bi),
													(o.minFilter =
														void 0 !== n.minFilter ? n.minFilter : Bi),
													(o.anisotropy =
														void 0 !== n.anisotropy ? n.anisotropy : 1),
													void 0 !== n.format && (o.format = n.format),
													void 0 !== n.type && (o.type = n.type),
													void 0 !== n.mipmaps &&
														((o.mipmaps = n.mipmaps), (o.minFilter = Gi)),
													1 === n.mipmapCount && (o.minFilter = Bi),
													(o.needsUpdate = !0),
													e && e(o, n));
											},
											n,
											i
										),
										o
									);
								},
							})),
							(Vu.prototype = Object.assign(Object.create(du.prototype), {
								constructor: Vu,
								load: function (t, e, n, i) {
									void 0 !== this.path && (t = this.path + t),
										(t = this.manager.resolveURL(t));
									const r = this,
										o = hu.get(t);
									if (void 0 !== o)
										return (
											r.manager.itemStart(t),
											setTimeout(function () {
												e && e(o), r.manager.itemEnd(t);
											}, 0),
											o
										);
									const a = document.createElementNS(
										"http://www.w3.org/1999/xhtml",
										"img"
									);
									function s() {
										a.removeEventListener("load", s, !1),
											a.removeEventListener("error", c, !1),
											hu.add(t, this),
											e && e(this),
											r.manager.itemEnd(t);
									}
									function c(e) {
										a.removeEventListener("load", s, !1),
											a.removeEventListener("error", c, !1),
											i && i(e),
											r.manager.itemError(t),
											r.manager.itemEnd(t);
									}
									return (
										a.addEventListener("load", s, !1),
										a.addEventListener("error", c, !1),
										"data:" !== t.substr(0, 5) &&
											void 0 !== this.crossOrigin &&
											(a.crossOrigin = this.crossOrigin),
										r.manager.itemStart(t),
										(a.src = t),
										a
									);
								},
							})),
							(qu.prototype = Object.assign(Object.create(du.prototype), {
								constructor: qu,
								load: function (t, e, n, i) {
									const r = new Ts(),
										o = new Vu(this.manager);
									o.setCrossOrigin(this.crossOrigin), o.setPath(this.path);
									let a = 0;
									function s(n) {
										o.load(
											t[n],
											function (t) {
												(r.images[n] = t),
													a++,
													6 === a && ((r.needsUpdate = !0), e && e(r));
											},
											void 0,
											i
										);
									}
									for (let e = 0; e < t.length; ++e) s(e);
									return r;
								},
							})),
							(Ru.prototype = Object.assign(Object.create(du.prototype), {
								constructor: Ru,
								load: function (t, e, n, i) {
									const r = new Ur(),
										o = new Vu(this.manager);
									return (
										o.setCrossOrigin(this.crossOrigin),
										o.setPath(this.path),
										o.load(
											t,
											function (n) {
												r.image = n;
												const i =
													t.search(/\.jpe?g($|\?)/i) > 0 ||
													0 === t.search(/^data\:image\/jpeg/);
												(r.format = i ? $i : tr),
													(r.needsUpdate = !0),
													void 0 !== e && e(r);
											},
											n,
											i
										),
										r
									);
								},
							})),
							Object.assign(Mu.prototype, {
								getPoint: function () {
									return (
										console.warn("THREE.Curve: .getPoint() not implemented."),
										null
									);
								},
								getPointAt: function (t, e) {
									const n = this.getUtoTmapping(t);
									return this.getPoint(n, e);
								},
								getPoints: function (t) {
									void 0 === t && (t = 5);
									const e = [];
									for (let n = 0; n <= t; n++) e.push(this.getPoint(n / t));
									return e;
								},
								getSpacedPoints: function (t) {
									void 0 === t && (t = 5);
									const e = [];
									for (let n = 0; n <= t; n++) e.push(this.getPointAt(n / t));
									return e;
								},
								getLength: function () {
									const t = this.getLengths();
									return t[t.length - 1];
								},
								getLengths: function (t) {
									if (
										(void 0 === t && (t = this.arcLengthDivisions),
										this.cacheArcLengths &&
											this.cacheArcLengths.length === t + 1 &&
											!this.needsUpdate)
									)
										return this.cacheArcLengths;
									this.needsUpdate = !1;
									const e = [];
									let n,
										i = this.getPoint(0),
										r = 0;
									e.push(0);
									for (let o = 1; o <= t; o++)
										(n = this.getPoint(o / t)),
											(r += n.distanceTo(i)),
											e.push(r),
											(i = n);
									return (this.cacheArcLengths = e), e;
								},
								updateArcLengths: function () {
									(this.needsUpdate = !0), this.getLengths();
								},
								getUtoTmapping: function (t, e) {
									const n = this.getLengths();
									let i,
										r = 0,
										o = n.length;
									i = e || t * n[o - 1];
									let a,
										s = 0,
										c = o - 1;
									for (; s <= c; )
										if (
											((r = Math.floor(s + (c - s) / 2)), (a = n[r] - i), a < 0)
										)
											s = r + 1;
										else {
											if (!(a > 0)) {
												c = r;
												break;
											}
											c = r - 1;
										}
									if (((r = c), n[r] === i)) return r / (o - 1);
									const l = n[r];
									return (r + (i - l) / (n[r + 1] - l)) / (o - 1);
								},
								getTangent: function (t, e) {
									const n = 1e-4;
									let i = t - n,
										r = t + n;
									i < 0 && (i = 0), r > 1 && (r = 1);
									const o = this.getPoint(i),
										a = this.getPoint(r),
										s = e || (o.isVector2 ? new Rr() : new zr());
									return s.copy(a).sub(o).normalize(), s;
								},
								getTangentAt: function (t, e) {
									const n = this.getUtoTmapping(t);
									return this.getTangent(n, e);
								},
								computeFrenetFrames: function (t, e) {
									const n = new zr(),
										i = [],
										r = [],
										o = [],
										a = new zr(),
										s = new jr();
									for (let e = 0; e <= t; e++) {
										const n = e / t;
										(i[e] = this.getTangentAt(n, new zr())), i[e].normalize();
									}
									(r[0] = new zr()), (o[0] = new zr());
									let c = Number.MAX_VALUE;
									const l = Math.abs(i[0].x),
										h = Math.abs(i[0].y),
										p = Math.abs(i[0].z);
									l <= c && ((c = l), n.set(1, 0, 0)),
										h <= c && ((c = h), n.set(0, 1, 0)),
										p <= c && n.set(0, 0, 1),
										a.crossVectors(i[0], n).normalize(),
										r[0].crossVectors(i[0], a),
										o[0].crossVectors(i[0], r[0]);
									for (let e = 1; e <= t; e++) {
										if (
											((r[e] = r[e - 1].clone()),
											(o[e] = o[e - 1].clone()),
											a.crossVectors(i[e - 1], i[e]),
											a.length() > Number.EPSILON)
										) {
											a.normalize();
											const t = Math.acos(qr.clamp(i[e - 1].dot(i[e]), -1, 1));
											r[e].applyMatrix4(s.makeRotationAxis(a, t));
										}
										o[e].crossVectors(i[e], r[e]);
									}
									if (!0 === e) {
										let e = Math.acos(qr.clamp(r[0].dot(r[t]), -1, 1));
										(e /= t),
											i[0].dot(a.crossVectors(r[0], r[t])) > 0 && (e = -e);
										for (let n = 1; n <= t; n++)
											r[n].applyMatrix4(s.makeRotationAxis(i[n], e * n)),
												o[n].crossVectors(i[n], r[n]);
									}
									return { tangents: i, normals: r, binormals: o };
								},
								clone: function () {
									return new this.constructor().copy(this);
								},
								copy: function (t) {
									return (this.arcLengthDivisions = t.arcLengthDivisions), this;
								},
								toJSON: function () {
									const t = {
										metadata: {
											version: 4.5,
											type: "Curve",
											generator: "Curve.toJSON",
										},
									};
									return (
										(t.arcLengthDivisions = this.arcLengthDivisions),
										(t.type = this.type),
										t
									);
								},
								fromJSON: function (t) {
									return (this.arcLengthDivisions = t.arcLengthDivisions), this;
								},
							}),
							(Iu.prototype = Object.create(Mu.prototype)),
							(Iu.prototype.constructor = Iu),
							(Iu.prototype.isEllipseCurve = !0),
							(Iu.prototype.getPoint = function (t, e) {
								const n = e || new Rr(),
									i = 2 * Math.PI;
								let r = this.aEndAngle - this.aStartAngle;
								const o = Math.abs(r) < Number.EPSILON;
								for (; r < 0; ) r += i;
								for (; r > i; ) r -= i;
								r < Number.EPSILON && (r = o ? 0 : i),
									!0 !== this.aClockwise ||
										o ||
										(r === i ? (r = -i) : (r -= i));
								const a = this.aStartAngle + t * r;
								let s = this.aX + this.xRadius * Math.cos(a),
									c = this.aY + this.yRadius * Math.sin(a);
								if (0 !== this.aRotation) {
									const t = Math.cos(this.aRotation),
										e = Math.sin(this.aRotation),
										n = s - this.aX,
										i = c - this.aY;
									(s = n * t - i * e + this.aX), (c = n * e + i * t + this.aY);
								}
								return n.set(s, c);
							}),
							(Iu.prototype.copy = function (t) {
								return (
									Mu.prototype.copy.call(this, t),
									(this.aX = t.aX),
									(this.aY = t.aY),
									(this.xRadius = t.xRadius),
									(this.yRadius = t.yRadius),
									(this.aStartAngle = t.aStartAngle),
									(this.aEndAngle = t.aEndAngle),
									(this.aClockwise = t.aClockwise),
									(this.aRotation = t.aRotation),
									this
								);
							}),
							(Iu.prototype.toJSON = function () {
								const t = Mu.prototype.toJSON.call(this);
								return (
									(t.aX = this.aX),
									(t.aY = this.aY),
									(t.xRadius = this.xRadius),
									(t.yRadius = this.yRadius),
									(t.aStartAngle = this.aStartAngle),
									(t.aEndAngle = this.aEndAngle),
									(t.aClockwise = this.aClockwise),
									(t.aRotation = this.aRotation),
									t
								);
							}),
							(Iu.prototype.fromJSON = function (t) {
								return (
									Mu.prototype.fromJSON.call(this, t),
									(this.aX = t.aX),
									(this.aY = t.aY),
									(this.xRadius = t.xRadius),
									(this.yRadius = t.yRadius),
									(this.aStartAngle = t.aStartAngle),
									(this.aEndAngle = t.aEndAngle),
									(this.aClockwise = t.aClockwise),
									(this.aRotation = t.aRotation),
									this
								);
							}),
							(vu.prototype = Object.create(Iu.prototype)),
							(vu.prototype.constructor = vu),
							(vu.prototype.isArcCurve = !0);
						const Uu = new zr(),
							wu = new ku(),
							xu = new ku(),
							Ou = new ku();
						function bu(t, e, n, i) {
							Mu.call(this),
								(this.type = "CatmullRomCurve3"),
								(this.points = t || []),
								(this.closed = e || !1),
								(this.curveType = n || "centripetal"),
								(this.tension = void 0 !== i ? i : 0.5);
						}
						function Ku(t, e, n, i, r) {
							const o = 0.5 * (i - e),
								a = 0.5 * (r - n),
								s = t * t;
							return (
								(2 * n - 2 * i + o + a) * (t * s) +
								(-3 * n + 3 * i - 2 * o - a) * s +
								o * t +
								n
							);
						}
						function Tu(t, e, n, i) {
							return (
								(function (t, e) {
									const n = 1 - t;
									return n * n * e;
								})(t, e) +
								(function (t, e) {
									return 2 * (1 - t) * t * e;
								})(t, n) +
								(function (t, e) {
									return t * t * e;
								})(t, i)
							);
						}
						function zu(t, e, n, i, r) {
							return (
								(function (t, e) {
									const n = 1 - t;
									return n * n * n * e;
								})(t, e) +
								(function (t, e) {
									const n = 1 - t;
									return 3 * n * n * t * e;
								})(t, n) +
								(function (t, e) {
									return 3 * (1 - t) * t * t * e;
								})(t, i) +
								(function (t, e) {
									return t * t * t * e;
								})(t, r)
							);
						}
						function Wu(t, e, n, i) {
							Mu.call(this),
								(this.type = "CubicBezierCurve"),
								(this.v0 = t || new Rr()),
								(this.v1 = e || new Rr()),
								(this.v2 = n || new Rr()),
								(this.v3 = i || new Rr());
						}
						function Eu(t, e, n, i) {
							Mu.call(this),
								(this.type = "CubicBezierCurve3"),
								(this.v0 = t || new zr()),
								(this.v1 = e || new zr()),
								(this.v2 = n || new zr()),
								(this.v3 = i || new zr());
						}
						function Cu(t, e) {
							Mu.call(this),
								(this.type = "LineCurve"),
								(this.v1 = t || new Rr()),
								(this.v2 = e || new Rr());
						}
						function Fu(t, e) {
							Mu.call(this),
								(this.type = "LineCurve3"),
								(this.v1 = t || new zr()),
								(this.v2 = e || new zr());
						}
						function Zu(t, e, n) {
							Mu.call(this),
								(this.type = "QuadraticBezierCurve"),
								(this.v0 = t || new Rr()),
								(this.v1 = e || new Rr()),
								(this.v2 = n || new Rr());
						}
						function Hu(t, e, n) {
							Mu.call(this),
								(this.type = "QuadraticBezierCurve3"),
								(this.v0 = t || new zr()),
								(this.v1 = e || new zr()),
								(this.v2 = n || new zr());
						}
						function Nu(t) {
							Mu.call(this),
								(this.type = "SplineCurve"),
								(this.points = t || []);
						}
						(bu.prototype = Object.create(Mu.prototype)),
							(bu.prototype.constructor = bu),
							(bu.prototype.isCatmullRomCurve3 = !0),
							(bu.prototype.getPoint = function (t, e) {
								const n = e || new zr(),
									i = this.points,
									r = i.length,
									o = (r - (this.closed ? 0 : 1)) * t;
								let a,
									s,
									c,
									l,
									h = Math.floor(o),
									p = o - h;
								if (
									(this.closed
										? (h += h > 0 ? 0 : (Math.floor(Math.abs(h) / r) + 1) * r)
										: 0 === p && h === r - 1 && ((h = r - 2), (p = 1)),
									this.closed || h > 0
										? (a = i[(h - 1) % r])
										: (Uu.subVectors(i[0], i[1]).add(i[0]), (a = Uu)),
									(s = i[h % r]),
									(c = i[(h + 1) % r]),
									this.closed || h + 2 < r
										? (l = i[(h + 2) % r])
										: (Uu.subVectors(i[r - 1], i[r - 2]).add(i[r - 1]),
										  (l = Uu)),
									"centripetal" === this.curveType ||
										"chordal" === this.curveType)
								) {
									const t = "chordal" === this.curveType ? 0.5 : 0.25;
									let e = Math.pow(a.distanceToSquared(s), t),
										n = Math.pow(s.distanceToSquared(c), t),
										i = Math.pow(c.distanceToSquared(l), t);
									n < 1e-4 && (n = 1),
										e < 1e-4 && (e = n),
										i < 1e-4 && (i = n),
										wu.initNonuniformCatmullRom(a.x, s.x, c.x, l.x, e, n, i),
										xu.initNonuniformCatmullRom(a.y, s.y, c.y, l.y, e, n, i),
										Ou.initNonuniformCatmullRom(a.z, s.z, c.z, l.z, e, n, i);
								} else
									"catmullrom" === this.curveType &&
										(wu.initCatmullRom(a.x, s.x, c.x, l.x, this.tension),
										xu.initCatmullRom(a.y, s.y, c.y, l.y, this.tension),
										Ou.initCatmullRom(a.z, s.z, c.z, l.z, this.tension));
								return n.set(wu.calc(p), xu.calc(p), Ou.calc(p)), n;
							}),
							(bu.prototype.copy = function (t) {
								Mu.prototype.copy.call(this, t), (this.points = []);
								for (let e = 0, n = t.points.length; e < n; e++) {
									const n = t.points[e];
									this.points.push(n.clone());
								}
								return (
									(this.closed = t.closed),
									(this.curveType = t.curveType),
									(this.tension = t.tension),
									this
								);
							}),
							(bu.prototype.toJSON = function () {
								const t = Mu.prototype.toJSON.call(this);
								t.points = [];
								for (let e = 0, n = this.points.length; e < n; e++) {
									const n = this.points[e];
									t.points.push(n.toArray());
								}
								return (
									(t.closed = this.closed),
									(t.curveType = this.curveType),
									(t.tension = this.tension),
									t
								);
							}),
							(bu.prototype.fromJSON = function (t) {
								Mu.prototype.fromJSON.call(this, t), (this.points = []);
								for (let e = 0, n = t.points.length; e < n; e++) {
									const n = t.points[e];
									this.points.push(new zr().fromArray(n));
								}
								return (
									(this.closed = t.closed),
									(this.curveType = t.curveType),
									(this.tension = t.tension),
									this
								);
							}),
							(Wu.prototype = Object.create(Mu.prototype)),
							(Wu.prototype.constructor = Wu),
							(Wu.prototype.isCubicBezierCurve = !0),
							(Wu.prototype.getPoint = function (t, e) {
								const n = e || new Rr(),
									i = this.v0,
									r = this.v1,
									o = this.v2,
									a = this.v3;
								return (
									n.set(zu(t, i.x, r.x, o.x, a.x), zu(t, i.y, r.y, o.y, a.y)), n
								);
							}),
							(Wu.prototype.copy = function (t) {
								return (
									Mu.prototype.copy.call(this, t),
									this.v0.copy(t.v0),
									this.v1.copy(t.v1),
									this.v2.copy(t.v2),
									this.v3.copy(t.v3),
									this
								);
							}),
							(Wu.prototype.toJSON = function () {
								const t = Mu.prototype.toJSON.call(this);
								return (
									(t.v0 = this.v0.toArray()),
									(t.v1 = this.v1.toArray()),
									(t.v2 = this.v2.toArray()),
									(t.v3 = this.v3.toArray()),
									t
								);
							}),
							(Wu.prototype.fromJSON = function (t) {
								return (
									Mu.prototype.fromJSON.call(this, t),
									this.v0.fromArray(t.v0),
									this.v1.fromArray(t.v1),
									this.v2.fromArray(t.v2),
									this.v3.fromArray(t.v3),
									this
								);
							}),
							(Eu.prototype = Object.create(Mu.prototype)),
							(Eu.prototype.constructor = Eu),
							(Eu.prototype.isCubicBezierCurve3 = !0),
							(Eu.prototype.getPoint = function (t, e) {
								const n = e || new zr(),
									i = this.v0,
									r = this.v1,
									o = this.v2,
									a = this.v3;
								return (
									n.set(
										zu(t, i.x, r.x, o.x, a.x),
										zu(t, i.y, r.y, o.y, a.y),
										zu(t, i.z, r.z, o.z, a.z)
									),
									n
								);
							}),
							(Eu.prototype.copy = function (t) {
								return (
									Mu.prototype.copy.call(this, t),
									this.v0.copy(t.v0),
									this.v1.copy(t.v1),
									this.v2.copy(t.v2),
									this.v3.copy(t.v3),
									this
								);
							}),
							(Eu.prototype.toJSON = function () {
								const t = Mu.prototype.toJSON.call(this);
								return (
									(t.v0 = this.v0.toArray()),
									(t.v1 = this.v1.toArray()),
									(t.v2 = this.v2.toArray()),
									(t.v3 = this.v3.toArray()),
									t
								);
							}),
							(Eu.prototype.fromJSON = function (t) {
								return (
									Mu.prototype.fromJSON.call(this, t),
									this.v0.fromArray(t.v0),
									this.v1.fromArray(t.v1),
									this.v2.fromArray(t.v2),
									this.v3.fromArray(t.v3),
									this
								);
							}),
							(Cu.prototype = Object.create(Mu.prototype)),
							(Cu.prototype.constructor = Cu),
							(Cu.prototype.isLineCurve = !0),
							(Cu.prototype.getPoint = function (t, e) {
								const n = e || new Rr();
								return (
									1 === t
										? n.copy(this.v2)
										: (n.copy(this.v2).sub(this.v1),
										  n.multiplyScalar(t).add(this.v1)),
									n
								);
							}),
							(Cu.prototype.getPointAt = function (t, e) {
								return this.getPoint(t, e);
							}),
							(Cu.prototype.getTangent = function (t, e) {
								const n = e || new Rr();
								return n.copy(this.v2).sub(this.v1).normalize(), n;
							}),
							(Cu.prototype.copy = function (t) {
								return (
									Mu.prototype.copy.call(this, t),
									this.v1.copy(t.v1),
									this.v2.copy(t.v2),
									this
								);
							}),
							(Cu.prototype.toJSON = function () {
								const t = Mu.prototype.toJSON.call(this);
								return (
									(t.v1 = this.v1.toArray()), (t.v2 = this.v2.toArray()), t
								);
							}),
							(Cu.prototype.fromJSON = function (t) {
								return (
									Mu.prototype.fromJSON.call(this, t),
									this.v1.fromArray(t.v1),
									this.v2.fromArray(t.v2),
									this
								);
							}),
							(Fu.prototype = Object.create(Mu.prototype)),
							(Fu.prototype.constructor = Fu),
							(Fu.prototype.isLineCurve3 = !0),
							(Fu.prototype.getPoint = function (t, e) {
								const n = e || new zr();
								return (
									1 === t
										? n.copy(this.v2)
										: (n.copy(this.v2).sub(this.v1),
										  n.multiplyScalar(t).add(this.v1)),
									n
								);
							}),
							(Fu.prototype.getPointAt = function (t, e) {
								return this.getPoint(t, e);
							}),
							(Fu.prototype.copy = function (t) {
								return (
									Mu.prototype.copy.call(this, t),
									this.v1.copy(t.v1),
									this.v2.copy(t.v2),
									this
								);
							}),
							(Fu.prototype.toJSON = function () {
								const t = Mu.prototype.toJSON.call(this);
								return (
									(t.v1 = this.v1.toArray()), (t.v2 = this.v2.toArray()), t
								);
							}),
							(Fu.prototype.fromJSON = function (t) {
								return (
									Mu.prototype.fromJSON.call(this, t),
									this.v1.fromArray(t.v1),
									this.v2.fromArray(t.v2),
									this
								);
							}),
							(Zu.prototype = Object.create(Mu.prototype)),
							(Zu.prototype.constructor = Zu),
							(Zu.prototype.isQuadraticBezierCurve = !0),
							(Zu.prototype.getPoint = function (t, e) {
								const n = e || new Rr(),
									i = this.v0,
									r = this.v1,
									o = this.v2;
								return n.set(Tu(t, i.x, r.x, o.x), Tu(t, i.y, r.y, o.y)), n;
							}),
							(Zu.prototype.copy = function (t) {
								return (
									Mu.prototype.copy.call(this, t),
									this.v0.copy(t.v0),
									this.v1.copy(t.v1),
									this.v2.copy(t.v2),
									this
								);
							}),
							(Zu.prototype.toJSON = function () {
								const t = Mu.prototype.toJSON.call(this);
								return (
									(t.v0 = this.v0.toArray()),
									(t.v1 = this.v1.toArray()),
									(t.v2 = this.v2.toArray()),
									t
								);
							}),
							(Zu.prototype.fromJSON = function (t) {
								return (
									Mu.prototype.fromJSON.call(this, t),
									this.v0.fromArray(t.v0),
									this.v1.fromArray(t.v1),
									this.v2.fromArray(t.v2),
									this
								);
							}),
							(Hu.prototype = Object.create(Mu.prototype)),
							(Hu.prototype.constructor = Hu),
							(Hu.prototype.isQuadraticBezierCurve3 = !0),
							(Hu.prototype.getPoint = function (t, e) {
								const n = e || new zr(),
									i = this.v0,
									r = this.v1,
									o = this.v2;
								return (
									n.set(
										Tu(t, i.x, r.x, o.x),
										Tu(t, i.y, r.y, o.y),
										Tu(t, i.z, r.z, o.z)
									),
									n
								);
							}),
							(Hu.prototype.copy = function (t) {
								return (
									Mu.prototype.copy.call(this, t),
									this.v0.copy(t.v0),
									this.v1.copy(t.v1),
									this.v2.copy(t.v2),
									this
								);
							}),
							(Hu.prototype.toJSON = function () {
								const t = Mu.prototype.toJSON.call(this);
								return (
									(t.v0 = this.v0.toArray()),
									(t.v1 = this.v1.toArray()),
									(t.v2 = this.v2.toArray()),
									t
								);
							}),
							(Hu.prototype.fromJSON = function (t) {
								return (
									Mu.prototype.fromJSON.call(this, t),
									this.v0.fromArray(t.v0),
									this.v1.fromArray(t.v1),
									this.v2.fromArray(t.v2),
									this
								);
							}),
							(Nu.prototype = Object.create(Mu.prototype)),
							(Nu.prototype.constructor = Nu),
							(Nu.prototype.isSplineCurve = !0),
							(Nu.prototype.getPoint = function (t, e) {
								const n = e || new Rr(),
									i = this.points,
									r = (i.length - 1) * t,
									o = Math.floor(r),
									a = r - o,
									s = i[0 === o ? o : o - 1],
									c = i[o],
									l = i[o > i.length - 2 ? i.length - 1 : o + 1],
									h = i[o > i.length - 3 ? i.length - 1 : o + 2];
								return (
									n.set(Ku(a, s.x, c.x, l.x, h.x), Ku(a, s.y, c.y, l.y, h.y)), n
								);
							}),
							(Nu.prototype.copy = function (t) {
								Mu.prototype.copy.call(this, t), (this.points = []);
								for (let e = 0, n = t.points.length; e < n; e++) {
									const n = t.points[e];
									this.points.push(n.clone());
								}
								return this;
							}),
							(Nu.prototype.toJSON = function () {
								const t = Mu.prototype.toJSON.call(this);
								t.points = [];
								for (let e = 0, n = this.points.length; e < n; e++) {
									const n = this.points[e];
									t.points.push(n.toArray());
								}
								return t;
							}),
							(Nu.prototype.fromJSON = function (t) {
								Mu.prototype.fromJSON.call(this, t), (this.points = []);
								for (let e = 0, n = t.points.length; e < n; e++) {
									const n = t.points[e];
									this.points.push(new Rr().fromArray(n));
								}
								return this;
							});
						var ju = Object.freeze({
							__proto__: null,
							ArcCurve: vu,
							CatmullRomCurve3: bu,
							CubicBezierCurve: Wu,
							CubicBezierCurve3: Eu,
							EllipseCurve: Iu,
							LineCurve: Cu,
							LineCurve3: Fu,
							QuadraticBezierCurve: Zu,
							QuadraticBezierCurve3: Hu,
							SplineCurve: Nu,
						});
						function Du() {
							Mu.call(this),
								(this.type = "CurvePath"),
								(this.curves = []),
								(this.autoClose = !1);
						}
						function Au(t) {
							Du.call(this),
								(this.type = "Path"),
								(this.currentPoint = new Rr()),
								t && this.setFromPoints(t);
						}
						function Lu(t) {
							Au.call(this, t),
								(this.uuid = qr.generateUUID()),
								(this.type = "Shape"),
								(this.holes = []);
						}
						function Bu(t, e) {
							oo.call(this),
								(this.type = "Light"),
								(this.color = new Yo(t)),
								(this.intensity = void 0 !== e ? e : 1),
								(this.receiveShadow = void 0);
						}
						function Gu(t, e, n) {
							Bu.call(this, t, n),
								(this.type = "HemisphereLight"),
								(this.castShadow = void 0),
								this.position.copy(oo.DefaultUp),
								this.updateMatrix(),
								(this.groundColor = new Yo(e));
						}
						function Qu(t) {
							(this.camera = t),
								(this.bias = 0),
								(this.normalBias = 0),
								(this.radius = 1),
								(this.mapSize = new Rr(512, 512)),
								(this.map = null),
								(this.mapPass = null),
								(this.matrix = new jr()),
								(this.autoUpdate = !0),
								(this.needsUpdate = !1),
								(this._frustum = new ps()),
								(this._frameExtents = new Rr(1, 1)),
								(this._viewportCount = 1),
								(this._viewports = [new wr(0, 0, 1, 1)]);
						}
						function _u() {
							Qu.call(this, new rs(50, 1, 0.5, 500));
						}
						function Pu(t, e, n, i, r, o) {
							Bu.call(this, t, e),
								(this.type = "SpotLight"),
								this.position.copy(oo.DefaultUp),
								this.updateMatrix(),
								(this.target = new oo()),
								Object.defineProperty(this, "power", {
									get: function () {
										return this.intensity * Math.PI;
									},
									set: function (t) {
										this.intensity = t / Math.PI;
									},
								}),
								(this.distance = void 0 !== n ? n : 0),
								(this.angle = void 0 !== i ? i : Math.PI / 3),
								(this.penumbra = void 0 !== r ? r : 0),
								(this.decay = void 0 !== o ? o : 1),
								(this.shadow = new _u());
						}
						function Ju() {
							Qu.call(this, new rs(90, 1, 0.5, 500)),
								(this._frameExtents = new Rr(4, 2)),
								(this._viewportCount = 6),
								(this._viewports = [
									new wr(2, 1, 1, 1),
									new wr(0, 1, 1, 1),
									new wr(3, 1, 1, 1),
									new wr(1, 1, 1, 1),
									new wr(3, 0, 1, 1),
									new wr(1, 0, 1, 1),
								]),
								(this._cubeDirections = [
									new zr(1, 0, 0),
									new zr(-1, 0, 0),
									new zr(0, 0, 1),
									new zr(0, 0, -1),
									new zr(0, 1, 0),
									new zr(0, -1, 0),
								]),
								(this._cubeUps = [
									new zr(0, 1, 0),
									new zr(0, 1, 0),
									new zr(0, 1, 0),
									new zr(0, 1, 0),
									new zr(0, 0, 1),
									new zr(0, 0, -1),
								]);
						}
						function Yu(t, e, n, i) {
							Bu.call(this, t, e),
								(this.type = "PointLight"),
								Object.defineProperty(this, "power", {
									get: function () {
										return 4 * this.intensity * Math.PI;
									},
									set: function (t) {
										this.intensity = t / (4 * Math.PI);
									},
								}),
								(this.distance = void 0 !== n ? n : 0),
								(this.decay = void 0 !== i ? i : 1),
								(this.shadow = new Ju());
						}
						function Xu(t, e, n, i, r, o) {
							is.call(this),
								(this.type = "OrthographicCamera"),
								(this.zoom = 1),
								(this.view = null),
								(this.left = void 0 !== t ? t : -1),
								(this.right = void 0 !== e ? e : 1),
								(this.top = void 0 !== n ? n : 1),
								(this.bottom = void 0 !== i ? i : -1),
								(this.near = void 0 !== r ? r : 0.1),
								(this.far = void 0 !== o ? o : 2e3),
								this.updateProjectionMatrix();
						}
						function $u() {
							Qu.call(this, new Xu(-5, 5, 5, -5, 0.5, 500));
						}
						function td(t, e) {
							Bu.call(this, t, e),
								(this.type = "DirectionalLight"),
								this.position.copy(oo.DefaultUp),
								this.updateMatrix(),
								(this.target = new oo()),
								(this.shadow = new $u());
						}
						function ed(t, e) {
							Bu.call(this, t, e),
								(this.type = "AmbientLight"),
								(this.castShadow = void 0);
						}
						function nd(t, e, n, i) {
							Bu.call(this, t, e),
								(this.type = "RectAreaLight"),
								(this.width = void 0 !== n ? n : 10),
								(this.height = void 0 !== i ? i : 10);
						}
						function id() {
							this.coefficients = [];
							for (let t = 0; t < 9; t++) this.coefficients.push(new zr());
						}
						function rd(t, e) {
							Bu.call(this, void 0, e),
								(this.type = "LightProbe"),
								(this.sh = void 0 !== t ? t : new id());
						}
						function od(t) {
							du.call(this, t), (this.textures = {});
						}
						(Du.prototype = Object.assign(Object.create(Mu.prototype), {
							constructor: Du,
							add: function (t) {
								this.curves.push(t);
							},
							closePath: function () {
								const t = this.curves[0].getPoint(0),
									e = this.curves[this.curves.length - 1].getPoint(1);
								t.equals(e) || this.curves.push(new Cu(e, t));
							},
							getPoint: function (t) {
								const e = t * this.getLength(),
									n = this.getCurveLengths();
								let i = 0;
								for (; i < n.length; ) {
									if (n[i] >= e) {
										const t = n[i] - e,
											r = this.curves[i],
											o = r.getLength(),
											a = 0 === o ? 0 : 1 - t / o;
										return r.getPointAt(a);
									}
									i++;
								}
								return null;
							},
							getLength: function () {
								const t = this.getCurveLengths();
								return t[t.length - 1];
							},
							updateArcLengths: function () {
								(this.needsUpdate = !0),
									(this.cacheLengths = null),
									this.getCurveLengths();
							},
							getCurveLengths: function () {
								if (
									this.cacheLengths &&
									this.cacheLengths.length === this.curves.length
								)
									return this.cacheLengths;
								const t = [];
								let e = 0;
								for (let n = 0, i = this.curves.length; n < i; n++)
									(e += this.curves[n].getLength()), t.push(e);
								return (this.cacheLengths = t), t;
							},
							getSpacedPoints: function (t) {
								void 0 === t && (t = 40);
								const e = [];
								for (let n = 0; n <= t; n++) e.push(this.getPoint(n / t));
								return this.autoClose && e.push(e[0]), e;
							},
							getPoints: function (t) {
								t = t || 12;
								const e = [];
								let n;
								for (let i = 0, r = this.curves; i < r.length; i++) {
									const o = r[i],
										a =
											o && o.isEllipseCurve
												? 2 * t
												: o && (o.isLineCurve || o.isLineCurve3)
												? 1
												: o && o.isSplineCurve
												? t * o.points.length
												: t,
										s = o.getPoints(a);
									for (let t = 0; t < s.length; t++) {
										const i = s[t];
										(n && n.equals(i)) || (e.push(i), (n = i));
									}
								}
								return (
									this.autoClose &&
										e.length > 1 &&
										!e[e.length - 1].equals(e[0]) &&
										e.push(e[0]),
									e
								);
							},
							copy: function (t) {
								Mu.prototype.copy.call(this, t), (this.curves = []);
								for (let e = 0, n = t.curves.length; e < n; e++) {
									const n = t.curves[e];
									this.curves.push(n.clone());
								}
								return (this.autoClose = t.autoClose), this;
							},
							toJSON: function () {
								const t = Mu.prototype.toJSON.call(this);
								(t.autoClose = this.autoClose), (t.curves = []);
								for (let e = 0, n = this.curves.length; e < n; e++) {
									const n = this.curves[e];
									t.curves.push(n.toJSON());
								}
								return t;
							},
							fromJSON: function (t) {
								Mu.prototype.fromJSON.call(this, t),
									(this.autoClose = t.autoClose),
									(this.curves = []);
								for (let e = 0, n = t.curves.length; e < n; e++) {
									const n = t.curves[e];
									this.curves.push(new ju[n.type]().fromJSON(n));
								}
								return this;
							},
						})),
							(Au.prototype = Object.assign(Object.create(Du.prototype), {
								constructor: Au,
								setFromPoints: function (t) {
									this.moveTo(t[0].x, t[0].y);
									for (let e = 1, n = t.length; e < n; e++)
										this.lineTo(t[e].x, t[e].y);
									return this;
								},
								moveTo: function (t, e) {
									return this.currentPoint.set(t, e), this;
								},
								lineTo: function (t, e) {
									const n = new Cu(this.currentPoint.clone(), new Rr(t, e));
									return this.curves.push(n), this.currentPoint.set(t, e), this;
								},
								quadraticCurveTo: function (t, e, n, i) {
									const r = new Zu(
										this.currentPoint.clone(),
										new Rr(t, e),
										new Rr(n, i)
									);
									return this.curves.push(r), this.currentPoint.set(n, i), this;
								},
								bezierCurveTo: function (t, e, n, i, r, o) {
									const a = new Wu(
										this.currentPoint.clone(),
										new Rr(t, e),
										new Rr(n, i),
										new Rr(r, o)
									);
									return this.curves.push(a), this.currentPoint.set(r, o), this;
								},
								splineThru: function (t) {
									const e = new Nu([this.currentPoint.clone()].concat(t));
									return (
										this.curves.push(e),
										this.currentPoint.copy(t[t.length - 1]),
										this
									);
								},
								arc: function (t, e, n, i, r, o) {
									const a = this.currentPoint.x,
										s = this.currentPoint.y;
									return this.absarc(t + a, e + s, n, i, r, o), this;
								},
								absarc: function (t, e, n, i, r, o) {
									return this.absellipse(t, e, n, n, i, r, o), this;
								},
								ellipse: function (t, e, n, i, r, o, a, s) {
									const c = this.currentPoint.x,
										l = this.currentPoint.y;
									return this.absellipse(t + c, e + l, n, i, r, o, a, s), this;
								},
								absellipse: function (t, e, n, i, r, o, a, s) {
									const c = new Iu(t, e, n, i, r, o, a, s);
									if (this.curves.length > 0) {
										const t = c.getPoint(0);
										t.equals(this.currentPoint) || this.lineTo(t.x, t.y);
									}
									this.curves.push(c);
									const l = c.getPoint(1);
									return this.currentPoint.copy(l), this;
								},
								copy: function (t) {
									return (
										Du.prototype.copy.call(this, t),
										this.currentPoint.copy(t.currentPoint),
										this
									);
								},
								toJSON: function () {
									const t = Du.prototype.toJSON.call(this);
									return (t.currentPoint = this.currentPoint.toArray()), t;
								},
								fromJSON: function (t) {
									return (
										Du.prototype.fromJSON.call(this, t),
										this.currentPoint.fromArray(t.currentPoint),
										this
									);
								},
							})),
							(Lu.prototype = Object.assign(Object.create(Au.prototype), {
								constructor: Lu,
								getPointsHoles: function (t) {
									const e = [];
									for (let n = 0, i = this.holes.length; n < i; n++)
										e[n] = this.holes[n].getPoints(t);
									return e;
								},
								extractPoints: function (t) {
									return {
										shape: this.getPoints(t),
										holes: this.getPointsHoles(t),
									};
								},
								copy: function (t) {
									Au.prototype.copy.call(this, t), (this.holes = []);
									for (let e = 0, n = t.holes.length; e < n; e++) {
										const n = t.holes[e];
										this.holes.push(n.clone());
									}
									return this;
								},
								toJSON: function () {
									const t = Au.prototype.toJSON.call(this);
									(t.uuid = this.uuid), (t.holes = []);
									for (let e = 0, n = this.holes.length; e < n; e++) {
										const n = this.holes[e];
										t.holes.push(n.toJSON());
									}
									return t;
								},
								fromJSON: function (t) {
									Au.prototype.fromJSON.call(this, t),
										(this.uuid = t.uuid),
										(this.holes = []);
									for (let e = 0, n = t.holes.length; e < n; e++) {
										const n = t.holes[e];
										this.holes.push(new Au().fromJSON(n));
									}
									return this;
								},
							})),
							(Bu.prototype = Object.assign(Object.create(oo.prototype), {
								constructor: Bu,
								isLight: !0,
								copy: function (t) {
									return (
										oo.prototype.copy.call(this, t),
										this.color.copy(t.color),
										(this.intensity = t.intensity),
										this
									);
								},
								toJSON: function (t) {
									const e = oo.prototype.toJSON.call(this, t);
									return (
										(e.object.color = this.color.getHex()),
										(e.object.intensity = this.intensity),
										void 0 !== this.groundColor &&
											(e.object.groundColor = this.groundColor.getHex()),
										void 0 !== this.distance &&
											(e.object.distance = this.distance),
										void 0 !== this.angle && (e.object.angle = this.angle),
										void 0 !== this.decay && (e.object.decay = this.decay),
										void 0 !== this.penumbra &&
											(e.object.penumbra = this.penumbra),
										void 0 !== this.shadow &&
											(e.object.shadow = this.shadow.toJSON()),
										e
									);
								},
							})),
							(Gu.prototype = Object.assign(Object.create(Bu.prototype), {
								constructor: Gu,
								isHemisphereLight: !0,
								copy: function (t) {
									return (
										Bu.prototype.copy.call(this, t),
										this.groundColor.copy(t.groundColor),
										this
									);
								},
							})),
							Object.assign(Qu.prototype, {
								_projScreenMatrix: new jr(),
								_lightPositionWorld: new zr(),
								_lookTarget: new zr(),
								getViewportCount: function () {
									return this._viewportCount;
								},
								getFrustum: function () {
									return this._frustum;
								},
								updateMatrices: function (t) {
									const e = this.camera,
										n = this.matrix,
										i = this._projScreenMatrix,
										r = this._lookTarget,
										o = this._lightPositionWorld;
									o.setFromMatrixPosition(t.matrixWorld),
										e.position.copy(o),
										r.setFromMatrixPosition(t.target.matrixWorld),
										e.lookAt(r),
										e.updateMatrixWorld(),
										i.multiplyMatrices(
											e.projectionMatrix,
											e.matrixWorldInverse
										),
										this._frustum.setFromProjectionMatrix(i),
										n.set(
											0.5,
											0,
											0,
											0.5,
											0,
											0.5,
											0,
											0.5,
											0,
											0,
											0.5,
											0.5,
											0,
											0,
											0,
											1
										),
										n.multiply(e.projectionMatrix),
										n.multiply(e.matrixWorldInverse);
								},
								getViewport: function (t) {
									return this._viewports[t];
								},
								getFrameExtents: function () {
									return this._frameExtents;
								},
								copy: function (t) {
									return (
										(this.camera = t.camera.clone()),
										(this.bias = t.bias),
										(this.radius = t.radius),
										this.mapSize.copy(t.mapSize),
										this
									);
								},
								clone: function () {
									return new this.constructor().copy(this);
								},
								toJSON: function () {
									const t = {};
									return (
										0 !== this.bias && (t.bias = this.bias),
										0 !== this.normalBias && (t.normalBias = this.normalBias),
										1 !== this.radius && (t.radius = this.radius),
										(512 === this.mapSize.x && 512 === this.mapSize.y) ||
											(t.mapSize = this.mapSize.toArray()),
										(t.camera = this.camera.toJSON(!1).object),
										delete t.camera.matrix,
										t
									);
								},
							}),
							(_u.prototype = Object.assign(Object.create(Qu.prototype), {
								constructor: _u,
								isSpotLightShadow: !0,
								updateMatrices: function (t) {
									const e = this.camera,
										n = 2 * qr.RAD2DEG * t.angle,
										i = this.mapSize.width / this.mapSize.height,
										r = t.distance || e.far;
									(n === e.fov && i === e.aspect && r === e.far) ||
										((e.fov = n),
										(e.aspect = i),
										(e.far = r),
										e.updateProjectionMatrix()),
										Qu.prototype.updateMatrices.call(this, t);
								},
							})),
							(Pu.prototype = Object.assign(Object.create(Bu.prototype), {
								constructor: Pu,
								isSpotLight: !0,
								copy: function (t) {
									return (
										Bu.prototype.copy.call(this, t),
										(this.distance = t.distance),
										(this.angle = t.angle),
										(this.penumbra = t.penumbra),
										(this.decay = t.decay),
										(this.target = t.target.clone()),
										(this.shadow = t.shadow.clone()),
										this
									);
								},
							})),
							(Ju.prototype = Object.assign(Object.create(Qu.prototype), {
								constructor: Ju,
								isPointLightShadow: !0,
								updateMatrices: function (t, e) {
									void 0 === e && (e = 0);
									const n = this.camera,
										i = this.matrix,
										r = this._lightPositionWorld,
										o = this._lookTarget,
										a = this._projScreenMatrix;
									r.setFromMatrixPosition(t.matrixWorld),
										n.position.copy(r),
										o.copy(n.position),
										o.add(this._cubeDirections[e]),
										n.up.copy(this._cubeUps[e]),
										n.lookAt(o),
										n.updateMatrixWorld(),
										i.makeTranslation(-r.x, -r.y, -r.z),
										a.multiplyMatrices(
											n.projectionMatrix,
											n.matrixWorldInverse
										),
										this._frustum.setFromProjectionMatrix(a);
								},
							})),
							(Yu.prototype = Object.assign(Object.create(Bu.prototype), {
								constructor: Yu,
								isPointLight: !0,
								copy: function (t) {
									return (
										Bu.prototype.copy.call(this, t),
										(this.distance = t.distance),
										(this.decay = t.decay),
										(this.shadow = t.shadow.clone()),
										this
									);
								},
							})),
							(Xu.prototype = Object.assign(Object.create(is.prototype), {
								constructor: Xu,
								isOrthographicCamera: !0,
								copy: function (t, e) {
									return (
										is.prototype.copy.call(this, t, e),
										(this.left = t.left),
										(this.right = t.right),
										(this.top = t.top),
										(this.bottom = t.bottom),
										(this.near = t.near),
										(this.far = t.far),
										(this.zoom = t.zoom),
										(this.view =
											null === t.view ? null : Object.assign({}, t.view)),
										this
									);
								},
								setViewOffset: function (t, e, n, i, r, o) {
									null === this.view &&
										(this.view = {
											enabled: !0,
											fullWidth: 1,
											fullHeight: 1,
											offsetX: 0,
											offsetY: 0,
											width: 1,
											height: 1,
										}),
										(this.view.enabled = !0),
										(this.view.fullWidth = t),
										(this.view.fullHeight = e),
										(this.view.offsetX = n),
										(this.view.offsetY = i),
										(this.view.width = r),
										(this.view.height = o),
										this.updateProjectionMatrix();
								},
								clearViewOffset: function () {
									null !== this.view && (this.view.enabled = !1),
										this.updateProjectionMatrix();
								},
								updateProjectionMatrix: function () {
									const t = (this.right - this.left) / (2 * this.zoom),
										e = (this.top - this.bottom) / (2 * this.zoom),
										n = (this.right + this.left) / 2,
										i = (this.top + this.bottom) / 2;
									let r = n - t,
										o = n + t,
										a = i + e,
										s = i - e;
									if (null !== this.view && this.view.enabled) {
										const t =
												(this.right - this.left) /
												this.view.fullWidth /
												this.zoom,
											e =
												(this.top - this.bottom) /
												this.view.fullHeight /
												this.zoom;
										(r += t * this.view.offsetX),
											(o = r + t * this.view.width),
											(a -= e * this.view.offsetY),
											(s = a - e * this.view.height);
									}
									this.projectionMatrix.makeOrthographic(
										r,
										o,
										a,
										s,
										this.near,
										this.far
									),
										this.projectionMatrixInverse.getInverse(
											this.projectionMatrix
										);
								},
								toJSON: function (t) {
									const e = oo.prototype.toJSON.call(this, t);
									return (
										(e.object.zoom = this.zoom),
										(e.object.left = this.left),
										(e.object.right = this.right),
										(e.object.top = this.top),
										(e.object.bottom = this.bottom),
										(e.object.near = this.near),
										(e.object.far = this.far),
										null !== this.view &&
											(e.object.view = Object.assign({}, this.view)),
										e
									);
								},
							})),
							($u.prototype = Object.assign(Object.create(Qu.prototype), {
								constructor: $u,
								isDirectionalLightShadow: !0,
								updateMatrices: function (t) {
									Qu.prototype.updateMatrices.call(this, t);
								},
							})),
							(td.prototype = Object.assign(Object.create(Bu.prototype), {
								constructor: td,
								isDirectionalLight: !0,
								copy: function (t) {
									return (
										Bu.prototype.copy.call(this, t),
										(this.target = t.target.clone()),
										(this.shadow = t.shadow.clone()),
										this
									);
								},
							})),
							(ed.prototype = Object.assign(Object.create(Bu.prototype), {
								constructor: ed,
								isAmbientLight: !0,
							})),
							(nd.prototype = Object.assign(Object.create(Bu.prototype), {
								constructor: nd,
								isRectAreaLight: !0,
								copy: function (t) {
									return (
										Bu.prototype.copy.call(this, t),
										(this.width = t.width),
										(this.height = t.height),
										this
									);
								},
								toJSON: function (t) {
									const e = Bu.prototype.toJSON.call(this, t);
									return (
										(e.object.width = this.width),
										(e.object.height = this.height),
										e
									);
								},
							})),
							Object.assign(id.prototype, {
								isSphericalHarmonics3: !0,
								set: function (t) {
									for (let e = 0; e < 9; e++) this.coefficients[e].copy(t[e]);
									return this;
								},
								zero: function () {
									for (let t = 0; t < 9; t++) this.coefficients[t].set(0, 0, 0);
									return this;
								},
								getAt: function (t, e) {
									const n = t.x,
										i = t.y,
										r = t.z,
										o = this.coefficients;
									return (
										e.copy(o[0]).multiplyScalar(0.282095),
										e.addScaledVector(o[1], 0.488603 * i),
										e.addScaledVector(o[2], 0.488603 * r),
										e.addScaledVector(o[3], 0.488603 * n),
										e.addScaledVector(o[4], n * i * 1.092548),
										e.addScaledVector(o[5], i * r * 1.092548),
										e.addScaledVector(o[6], 0.315392 * (3 * r * r - 1)),
										e.addScaledVector(o[7], n * r * 1.092548),
										e.addScaledVector(o[8], 0.546274 * (n * n - i * i)),
										e
									);
								},
								getIrradianceAt: function (t, e) {
									const n = t.x,
										i = t.y,
										r = t.z,
										o = this.coefficients;
									return (
										e.copy(o[0]).multiplyScalar(0.886227),
										e.addScaledVector(o[1], 1.023328 * i),
										e.addScaledVector(o[2], 1.023328 * r),
										e.addScaledVector(o[3], 1.023328 * n),
										e.addScaledVector(o[4], 0.858086 * n * i),
										e.addScaledVector(o[5], 0.858086 * i * r),
										e.addScaledVector(o[6], 0.743125 * r * r - 0.247708),
										e.addScaledVector(o[7], 0.858086 * n * r),
										e.addScaledVector(o[8], 0.429043 * (n * n - i * i)),
										e
									);
								},
								add: function (t) {
									for (let e = 0; e < 9; e++)
										this.coefficients[e].add(t.coefficients[e]);
									return this;
								},
								addScaledSH: function (t, e) {
									for (let n = 0; n < 9; n++)
										this.coefficients[n].addScaledVector(t.coefficients[n], e);
									return this;
								},
								scale: function (t) {
									for (let e = 0; e < 9; e++)
										this.coefficients[e].multiplyScalar(t);
									return this;
								},
								lerp: function (t, e) {
									for (let n = 0; n < 9; n++)
										this.coefficients[n].lerp(t.coefficients[n], e);
									return this;
								},
								equals: function (t) {
									for (let e = 0; e < 9; e++)
										if (!this.coefficients[e].equals(t.coefficients[e]))
											return !1;
									return !0;
								},
								copy: function (t) {
									return this.set(t.coefficients);
								},
								clone: function () {
									return new this.constructor().copy(this);
								},
								fromArray: function (t, e) {
									void 0 === e && (e = 0);
									const n = this.coefficients;
									for (let i = 0; i < 9; i++) n[i].fromArray(t, e + 3 * i);
									return this;
								},
								toArray: function (t, e) {
									void 0 === t && (t = []), void 0 === e && (e = 0);
									const n = this.coefficients;
									for (let i = 0; i < 9; i++) n[i].toArray(t, e + 3 * i);
									return t;
								},
							}),
							Object.assign(id, {
								getBasisAt: function (t, e) {
									const n = t.x,
										i = t.y,
										r = t.z;
									(e[0] = 0.282095),
										(e[1] = 0.488603 * i),
										(e[2] = 0.488603 * r),
										(e[3] = 0.488603 * n),
										(e[4] = 1.092548 * n * i),
										(e[5] = 1.092548 * i * r),
										(e[6] = 0.315392 * (3 * r * r - 1)),
										(e[7] = 1.092548 * n * r),
										(e[8] = 0.546274 * (n * n - i * i));
								},
							}),
							(rd.prototype = Object.assign(Object.create(Bu.prototype), {
								constructor: rd,
								isLightProbe: !0,
								copy: function (t) {
									return (
										Bu.prototype.copy.call(this, t), this.sh.copy(t.sh), this
									);
								},
								fromJSON: function (t) {
									return (
										(this.intensity = t.intensity),
										this.sh.fromArray(t.sh),
										this
									);
								},
								toJSON: function (t) {
									const e = Bu.prototype.toJSON.call(this, t);
									return (e.object.sh = this.sh.toArray()), e;
								},
							})),
							(od.prototype = Object.assign(Object.create(du.prototype), {
								constructor: od,
								load: function (t, e, n, i) {
									const r = this,
										o = new fu(r.manager);
									o.setPath(r.path),
										o.setRequestHeader(r.requestHeader),
										o.load(
											t,
											function (n) {
												try {
													e(r.parse(JSON.parse(n)));
												} catch (e) {
													i ? i(e) : console.error(e), r.manager.itemError(t);
												}
											},
											n,
											i
										);
								},
								parse: function (t) {
									const e = this.textures;
									function n(t) {
										return (
											void 0 === e[t] &&
												console.warn(
													"THREE.MaterialLoader: Undefined texture",
													t
												),
											e[t]
										);
									}
									const i = new _p[t.type]();
									if (
										(void 0 !== t.uuid && (i.uuid = t.uuid),
										void 0 !== t.name && (i.name = t.name),
										void 0 !== t.color && i.color.setHex(t.color),
										void 0 !== t.roughness && (i.roughness = t.roughness),
										void 0 !== t.metalness && (i.metalness = t.metalness),
										void 0 !== t.sheen && (i.sheen = new Yo().setHex(t.sheen)),
										void 0 !== t.emissive && i.emissive.setHex(t.emissive),
										void 0 !== t.specular && i.specular.setHex(t.specular),
										void 0 !== t.shininess && (i.shininess = t.shininess),
										void 0 !== t.clearcoat && (i.clearcoat = t.clearcoat),
										void 0 !== t.clearcoatRoughness &&
											(i.clearcoatRoughness = t.clearcoatRoughness),
										void 0 !== t.fog && (i.fog = t.fog),
										void 0 !== t.flatShading && (i.flatShading = t.flatShading),
										void 0 !== t.blending && (i.blending = t.blending),
										void 0 !== t.combine && (i.combine = t.combine),
										void 0 !== t.side && (i.side = t.side),
										void 0 !== t.opacity && (i.opacity = t.opacity),
										void 0 !== t.transparent && (i.transparent = t.transparent),
										void 0 !== t.alphaTest && (i.alphaTest = t.alphaTest),
										void 0 !== t.depthTest && (i.depthTest = t.depthTest),
										void 0 !== t.depthWrite && (i.depthWrite = t.depthWrite),
										void 0 !== t.colorWrite && (i.colorWrite = t.colorWrite),
										void 0 !== t.stencilWrite &&
											(i.stencilWrite = t.stencilWrite),
										void 0 !== t.stencilWriteMask &&
											(i.stencilWriteMask = t.stencilWriteMask),
										void 0 !== t.stencilFunc && (i.stencilFunc = t.stencilFunc),
										void 0 !== t.stencilRef && (i.stencilRef = t.stencilRef),
										void 0 !== t.stencilFuncMask &&
											(i.stencilFuncMask = t.stencilFuncMask),
										void 0 !== t.stencilFail && (i.stencilFail = t.stencilFail),
										void 0 !== t.stencilZFail &&
											(i.stencilZFail = t.stencilZFail),
										void 0 !== t.stencilZPass &&
											(i.stencilZPass = t.stencilZPass),
										void 0 !== t.wireframe && (i.wireframe = t.wireframe),
										void 0 !== t.wireframeLinewidth &&
											(i.wireframeLinewidth = t.wireframeLinewidth),
										void 0 !== t.wireframeLinecap &&
											(i.wireframeLinecap = t.wireframeLinecap),
										void 0 !== t.wireframeLinejoin &&
											(i.wireframeLinejoin = t.wireframeLinejoin),
										void 0 !== t.rotation && (i.rotation = t.rotation),
										1 !== t.linewidth && (i.linewidth = t.linewidth),
										void 0 !== t.dashSize && (i.dashSize = t.dashSize),
										void 0 !== t.gapSize && (i.gapSize = t.gapSize),
										void 0 !== t.scale && (i.scale = t.scale),
										void 0 !== t.polygonOffset &&
											(i.polygonOffset = t.polygonOffset),
										void 0 !== t.polygonOffsetFactor &&
											(i.polygonOffsetFactor = t.polygonOffsetFactor),
										void 0 !== t.polygonOffsetUnits &&
											(i.polygonOffsetUnits = t.polygonOffsetUnits),
										void 0 !== t.skinning && (i.skinning = t.skinning),
										void 0 !== t.morphTargets &&
											(i.morphTargets = t.morphTargets),
										void 0 !== t.morphNormals &&
											(i.morphNormals = t.morphNormals),
										void 0 !== t.dithering && (i.dithering = t.dithering),
										void 0 !== t.vertexTangents &&
											(i.vertexTangents = t.vertexTangents),
										void 0 !== t.visible && (i.visible = t.visible),
										void 0 !== t.toneMapped && (i.toneMapped = t.toneMapped),
										void 0 !== t.userData && (i.userData = t.userData),
										void 0 !== t.vertexColors &&
											("number" == typeof t.vertexColors
												? (i.vertexColors = t.vertexColors > 0)
												: (i.vertexColors = t.vertexColors)),
										void 0 !== t.uniforms)
									)
										for (const e in t.uniforms) {
											const r = t.uniforms[e];
											switch (((i.uniforms[e] = {}), r.type)) {
												case "t":
													i.uniforms[e].value = n(r.value);
													break;
												case "c":
													i.uniforms[e].value = new Yo().setHex(r.value);
													break;
												case "v2":
													i.uniforms[e].value = new Rr().fromArray(r.value);
													break;
												case "v3":
													i.uniforms[e].value = new zr().fromArray(r.value);
													break;
												case "v4":
													i.uniforms[e].value = new wr().fromArray(r.value);
													break;
												case "m3":
													i.uniforms[e].value = new Mr().fromArray(r.value);
												case "m4":
													i.uniforms[e].value = new jr().fromArray(r.value);
													break;
												default:
													i.uniforms[e].value = r.value;
											}
										}
									if (
										(void 0 !== t.defines && (i.defines = t.defines),
										void 0 !== t.vertexShader &&
											(i.vertexShader = t.vertexShader),
										void 0 !== t.fragmentShader &&
											(i.fragmentShader = t.fragmentShader),
										void 0 !== t.extensions)
									)
										for (const e in t.extensions)
											i.extensions[e] = t.extensions[e];
									if (
										(void 0 !== t.shading && (i.flatShading = 1 === t.shading),
										void 0 !== t.size && (i.size = t.size),
										void 0 !== t.sizeAttenuation &&
											(i.sizeAttenuation = t.sizeAttenuation),
										void 0 !== t.map && (i.map = n(t.map)),
										void 0 !== t.matcap && (i.matcap = n(t.matcap)),
										void 0 !== t.alphaMap && (i.alphaMap = n(t.alphaMap)),
										void 0 !== t.bumpMap && (i.bumpMap = n(t.bumpMap)),
										void 0 !== t.bumpScale && (i.bumpScale = t.bumpScale),
										void 0 !== t.normalMap && (i.normalMap = n(t.normalMap)),
										void 0 !== t.normalMapType &&
											(i.normalMapType = t.normalMapType),
										void 0 !== t.normalScale)
									) {
										let e = t.normalScale;
										!1 === Array.isArray(e) && (e = [e, e]),
											(i.normalScale = new Rr().fromArray(e));
									}
									return (
										void 0 !== t.displacementMap &&
											(i.displacementMap = n(t.displacementMap)),
										void 0 !== t.displacementScale &&
											(i.displacementScale = t.displacementScale),
										void 0 !== t.displacementBias &&
											(i.displacementBias = t.displacementBias),
										void 0 !== t.roughnessMap &&
											(i.roughnessMap = n(t.roughnessMap)),
										void 0 !== t.metalnessMap &&
											(i.metalnessMap = n(t.metalnessMap)),
										void 0 !== t.emissiveMap &&
											(i.emissiveMap = n(t.emissiveMap)),
										void 0 !== t.emissiveIntensity &&
											(i.emissiveIntensity = t.emissiveIntensity),
										void 0 !== t.specularMap &&
											(i.specularMap = n(t.specularMap)),
										void 0 !== t.envMap && (i.envMap = n(t.envMap)),
										void 0 !== t.envMapIntensity &&
											(i.envMapIntensity = t.envMapIntensity),
										void 0 !== t.reflectivity &&
											(i.reflectivity = t.reflectivity),
										void 0 !== t.refractionRatio &&
											(i.refractionRatio = t.refractionRatio),
										void 0 !== t.lightMap && (i.lightMap = n(t.lightMap)),
										void 0 !== t.lightMapIntensity &&
											(i.lightMapIntensity = t.lightMapIntensity),
										void 0 !== t.aoMap && (i.aoMap = n(t.aoMap)),
										void 0 !== t.aoMapIntensity &&
											(i.aoMapIntensity = t.aoMapIntensity),
										void 0 !== t.gradientMap &&
											(i.gradientMap = n(t.gradientMap)),
										void 0 !== t.clearcoatMap &&
											(i.clearcoatMap = n(t.clearcoatMap)),
										void 0 !== t.clearcoatRoughnessMap &&
											(i.clearcoatRoughnessMap = n(t.clearcoatRoughnessMap)),
										void 0 !== t.clearcoatNormalMap &&
											(i.clearcoatNormalMap = n(t.clearcoatNormalMap)),
										void 0 !== t.clearcoatNormalScale &&
											(i.clearcoatNormalScale = new Rr().fromArray(
												t.clearcoatNormalScale
											)),
										void 0 !== t.transmission &&
											(i.transmission = t.transmission),
										void 0 !== t.transmissionMap &&
											(i.transmissionMap = n(t.transmissionMap)),
										i
									);
								},
								setTextures: function (t) {
									return (this.textures = t), this;
								},
							}));
						const ad = function (t) {
							const e = t.lastIndexOf("/");
							return -1 === e ? "./" : t.substr(0, e + 1);
						};
						function sd() {
							Ua.call(this),
								(this.type = "InstancedBufferGeometry"),
								(this.instanceCount = 1 / 0);
						}
						function cd(t, e, n, i) {
							"number" == typeof n &&
								((i = n),
								(n = !1),
								console.error(
									"THREE.InstancedBufferAttribute: The constructor now expects normalized as the third argument."
								)),
								sa.call(this, t, e, n),
								(this.meshPerAttribute = i || 1);
						}
						function ld(t) {
							du.call(this, t);
						}
						(sd.prototype = Object.assign(Object.create(Ua.prototype), {
							constructor: sd,
							isInstancedBufferGeometry: !0,
							copy: function (t) {
								return (
									Ua.prototype.copy.call(this, t),
									(this.instanceCount = t.instanceCount),
									this
								);
							},
							clone: function () {
								return new this.constructor().copy(this);
							},
							toJSON: function () {
								const t = Ua.prototype.toJSON.call(this);
								return (
									(t.instanceCount = this.instanceCount),
									(t.isInstancedBufferGeometry = !0),
									t
								);
							},
						})),
							(cd.prototype = Object.assign(Object.create(sa.prototype), {
								constructor: cd,
								isInstancedBufferAttribute: !0,
								copy: function (t) {
									return (
										sa.prototype.copy.call(this, t),
										(this.meshPerAttribute = t.meshPerAttribute),
										this
									);
								},
								toJSON: function () {
									const t = sa.prototype.toJSON.call(this);
									return (
										(t.meshPerAttribute = this.meshPerAttribute),
										(t.isInstancedBufferAttribute = !0),
										t
									);
								},
							})),
							(ld.prototype = Object.assign(Object.create(du.prototype), {
								constructor: ld,
								load: function (t, e, n, i) {
									const r = this,
										o = new fu(r.manager);
									o.setPath(r.path),
										o.setRequestHeader(r.requestHeader),
										o.load(
											t,
											function (n) {
												try {
													e(r.parse(JSON.parse(n)));
												} catch (e) {
													i ? i(e) : console.error(e), r.manager.itemError(t);
												}
											},
											n,
											i
										);
								},
								parse: function (t) {
									const e = {},
										n = {};
									function i(t, i) {
										if (void 0 !== e[i]) return e[i];
										const r = t.interleavedBuffers[i],
											o = (function (t, e) {
												if (void 0 !== n[e]) return n[e];
												const i = t.arrayBuffers[e],
													r = new Uint32Array(i).buffer;
												return (n[e] = r), r;
											})(t, r.buffer),
											a = new Il(new hd[r.type](o), r.stride);
										return (a.uuid = r.uuid), (e[i] = a), a;
									}
									const r = t.isInstancedBufferGeometry ? new sd() : new Ua(),
										o = t.data.index;
									if (void 0 !== o) {
										const t = new hd[o.type](o.array);
										r.setIndex(new sa(t, 1));
									}
									const a = t.data.attributes;
									for (const e in a) {
										const n = a[e];
										let o;
										if (n.isInterleavedBufferAttribute)
											o = new kl(
												i(t.data, n.data),
												n.itemSize,
												n.offset,
												n.normalized
											);
										else {
											const t = new hd[n.type](n.array);
											o = new (n.isInstancedBufferAttribute ? cd : sa)(
												t,
												n.itemSize,
												n.normalized
											);
										}
										void 0 !== n.name && (o.name = n.name),
											r.setAttribute(e, o);
									}
									const s = t.data.morphAttributes;
									if (s)
										for (const e in s) {
											const n = s[e],
												o = [];
											for (let e = 0, r = n.length; e < r; e++) {
												const r = n[e];
												let a;
												(a = r.isInterleavedBufferAttribute
													? new kl(
															i(t.data, r.data),
															r.itemSize,
															r.offset,
															r.normalized
													  )
													: new sa(
															new hd[r.type](r.array),
															r.itemSize,
															r.normalized
													  )),
													void 0 !== r.name && (a.name = r.name),
													o.push(a);
											}
											r.morphAttributes[e] = o;
										}
									t.data.morphTargetsRelative && (r.morphTargetsRelative = !0);
									const c = t.data.groups || t.data.drawcalls || t.data.offsets;
									if (void 0 !== c)
										for (let t = 0, e = c.length; t !== e; ++t) {
											const e = c[t];
											r.addGroup(e.start, e.count, e.materialIndex);
										}
									const l = t.data.boundingSphere;
									if (void 0 !== l) {
										const t = new zr();
										void 0 !== l.center && t.fromArray(l.center),
											(r.boundingSphere = new vo(t, l.radius));
									}
									return (
										t.name && (r.name = t.name),
										t.userData && (r.userData = t.userData),
										r
									);
								},
							}));
						const hd = {
							Int8Array,
							Uint8Array,
							Uint8ClampedArray:
								"undefined" != typeof Uint8ClampedArray
									? Uint8ClampedArray
									: Uint8Array,
							Int16Array,
							Uint16Array,
							Int32Array,
							Uint32Array,
							Float32Array,
							Float64Array,
						};
						function pd(t) {
							du.call(this, t);
						}
						pd.prototype = Object.assign(Object.create(du.prototype), {
							constructor: pd,
							load: function (t, e, n, i) {
								const r = this,
									o = "" === this.path ? ad(t) : this.path;
								this.resourcePath = this.resourcePath || o;
								const a = new fu(r.manager);
								a.setPath(this.path),
									a.setRequestHeader(this.requestHeader),
									a.load(
										t,
										function (n) {
											let o = null;
											try {
												o = JSON.parse(n);
											} catch (e) {
												return (
													void 0 !== i && i(e),
													void console.error(
														"THREE:ObjectLoader: Can't parse " + t + ".",
														e.message
													)
												);
											}
											const a = o.metadata;
											void 0 !== a &&
											void 0 !== a.type &&
											"geometry" !== a.type.toLowerCase()
												? r.parse(o, e)
												: console.error("THREE.ObjectLoader: Can't load " + t);
										},
										n,
										i
									);
							},
							parse: function (t, e) {
								const n = this.parseShape(t.shapes),
									i = this.parseGeometries(t.geometries, n),
									r = this.parseImages(t.images, function () {
										void 0 !== e && e(s);
									}),
									o = this.parseTextures(t.textures, r),
									a = this.parseMaterials(t.materials, o),
									s = this.parseObject(t.object, i, a);
								return (
									t.animations &&
										(s.animations = this.parseAnimations(t.animations)),
									(void 0 !== t.images && 0 !== t.images.length) ||
										(void 0 !== e && e(s)),
									s
								);
							},
							parseShape: function (t) {
								const e = {};
								if (void 0 !== t)
									for (let n = 0, i = t.length; n < i; n++) {
										const i = new Lu().fromJSON(t[n]);
										e[i.uuid] = i;
									}
								return e;
							},
							parseGeometries: function (t, e) {
								const n = {};
								let i;
								if (void 0 !== t) {
									const r = new ld();
									for (let o = 0, a = t.length; o < a; o++) {
										let a;
										const s = t[o];
										switch (s.type) {
											case "PlaneGeometry":
											case "PlaneBufferGeometry":
												a = new Fp[s.type](
													s.width,
													s.height,
													s.widthSegments,
													s.heightSegments
												);
												break;
											case "BoxGeometry":
											case "BoxBufferGeometry":
											case "CubeGeometry":
												a = new Fp[s.type](
													s.width,
													s.height,
													s.depth,
													s.widthSegments,
													s.heightSegments,
													s.depthSegments
												);
												break;
											case "CircleGeometry":
											case "CircleBufferGeometry":
												a = new Fp[s.type](
													s.radius,
													s.segments,
													s.thetaStart,
													s.thetaLength
												);
												break;
											case "CylinderGeometry":
											case "CylinderBufferGeometry":
												a = new Fp[s.type](
													s.radiusTop,
													s.radiusBottom,
													s.height,
													s.radialSegments,
													s.heightSegments,
													s.openEnded,
													s.thetaStart,
													s.thetaLength
												);
												break;
											case "ConeGeometry":
											case "ConeBufferGeometry":
												a = new Fp[s.type](
													s.radius,
													s.height,
													s.radialSegments,
													s.heightSegments,
													s.openEnded,
													s.thetaStart,
													s.thetaLength
												);
												break;
											case "SphereGeometry":
											case "SphereBufferGeometry":
												a = new Fp[s.type](
													s.radius,
													s.widthSegments,
													s.heightSegments,
													s.phiStart,
													s.phiLength,
													s.thetaStart,
													s.thetaLength
												);
												break;
											case "DodecahedronGeometry":
											case "DodecahedronBufferGeometry":
											case "IcosahedronGeometry":
											case "IcosahedronBufferGeometry":
											case "OctahedronGeometry":
											case "OctahedronBufferGeometry":
											case "TetrahedronGeometry":
											case "TetrahedronBufferGeometry":
												a = new Fp[s.type](s.radius, s.detail);
												break;
											case "RingGeometry":
											case "RingBufferGeometry":
												a = new Fp[s.type](
													s.innerRadius,
													s.outerRadius,
													s.thetaSegments,
													s.phiSegments,
													s.thetaStart,
													s.thetaLength
												);
												break;
											case "TorusGeometry":
											case "TorusBufferGeometry":
												a = new Fp[s.type](
													s.radius,
													s.tube,
													s.radialSegments,
													s.tubularSegments,
													s.arc
												);
												break;
											case "TorusKnotGeometry":
											case "TorusKnotBufferGeometry":
												a = new Fp[s.type](
													s.radius,
													s.tube,
													s.tubularSegments,
													s.radialSegments,
													s.p,
													s.q
												);
												break;
											case "TubeGeometry":
											case "TubeBufferGeometry":
												a = new Fp[s.type](
													new ju[s.path.type]().fromJSON(s.path),
													s.tubularSegments,
													s.radius,
													s.radialSegments,
													s.closed
												);
												break;
											case "LatheGeometry":
											case "LatheBufferGeometry":
												a = new Fp[s.type](
													s.points,
													s.segments,
													s.phiStart,
													s.phiLength
												);
												break;
											case "PolyhedronGeometry":
											case "PolyhedronBufferGeometry":
												a = new Fp[s.type](
													s.vertices,
													s.indices,
													s.radius,
													s.details
												);
												break;
											case "ShapeGeometry":
											case "ShapeBufferGeometry":
												i = [];
												for (let t = 0, n = s.shapes.length; t < n; t++) {
													const n = e[s.shapes[t]];
													i.push(n);
												}
												a = new Fp[s.type](i, s.curveSegments);
												break;
											case "ExtrudeGeometry":
											case "ExtrudeBufferGeometry":
												i = [];
												for (let t = 0, n = s.shapes.length; t < n; t++) {
													const n = e[s.shapes[t]];
													i.push(n);
												}
												const t = s.options.extrudePath;
												void 0 !== t &&
													(s.options.extrudePath = new ju[t.type]().fromJSON(
														t
													)),
													(a = new Fp[s.type](i, s.options));
												break;
											case "BufferGeometry":
											case "InstancedBufferGeometry":
												a = r.parse(s);
												break;
											case "Geometry":
												console.error(
													'THREE.ObjectLoader: Loading "Geometry" is not supported anymore.'
												);
												break;
											default:
												console.warn(
													'THREE.ObjectLoader: Unsupported geometry type "' +
														s.type +
														'"'
												);
												continue;
										}
										(a.uuid = s.uuid),
											void 0 !== s.name && (a.name = s.name),
											!0 === a.isBufferGeometry &&
												void 0 !== s.userData &&
												(a.userData = s.userData),
											(n[s.uuid] = a);
									}
								}
								return n;
							},
							parseMaterials: function (t, e) {
								const n = {},
									i = {};
								if (void 0 !== t) {
									const r = new od();
									r.setTextures(e);
									for (let e = 0, o = t.length; e < o; e++) {
										const o = t[e];
										if ("MultiMaterial" === o.type) {
											const t = [];
											for (let e = 0; e < o.materials.length; e++) {
												const i = o.materials[e];
												void 0 === n[i.uuid] && (n[i.uuid] = r.parse(i)),
													t.push(n[i.uuid]);
											}
											i[o.uuid] = t;
										} else
											void 0 === n[o.uuid] && (n[o.uuid] = r.parse(o)),
												(i[o.uuid] = n[o.uuid]);
									}
								}
								return i;
							},
							parseAnimations: function (t) {
								const e = [];
								for (let n = 0; n < t.length; n++) {
									const i = t[n],
										r = cu.parse(i);
									void 0 !== i.uuid && (r.uuid = i.uuid), e.push(r);
								}
								return e;
							},
							parseImages: function (t, e) {
								const n = this,
									i = {};
								let r;
								function o(t) {
									return (
										n.manager.itemStart(t),
										r.load(
											t,
											function () {
												n.manager.itemEnd(t);
											},
											void 0,
											function () {
												n.manager.itemError(t), n.manager.itemEnd(t);
											}
										)
									);
								}
								if (void 0 !== t && t.length > 0) {
									const a = new pu(e);
									(r = new Vu(a)), r.setCrossOrigin(this.crossOrigin);
									for (let e = 0, r = t.length; e < r; e++) {
										const r = t[e],
											a = r.url;
										if (Array.isArray(a)) {
											i[r.uuid] = [];
											for (let t = 0, e = a.length; t < e; t++) {
												const e = a[t],
													s = /^(\/\/)|([a-z]+:(\/\/)?)/i.test(e)
														? e
														: n.resourcePath + e;
												i[r.uuid].push(o(s));
											}
										} else {
											const t = /^(\/\/)|([a-z]+:(\/\/)?)/i.test(r.url)
												? r.url
												: n.resourcePath + r.url;
											i[r.uuid] = o(t);
										}
									}
								}
								return i;
							},
							parseTextures: function (t, e) {
								function n(t, e) {
									return "number" == typeof t
										? t
										: (console.warn(
												"THREE.ObjectLoader.parseTexture: Constant should be in numeric form.",
												t
										  ),
										  e[t]);
								}
								const i = {};
								if (void 0 !== t)
									for (let r = 0, o = t.length; r < o; r++) {
										const o = t[r];
										let a;
										void 0 === o.image &&
											console.warn(
												'THREE.ObjectLoader: No "image" specified for',
												o.uuid
											),
											void 0 === e[o.image] &&
												console.warn(
													"THREE.ObjectLoader: Undefined image",
													o.image
												),
											(a = Array.isArray(e[o.image])
												? new Ts(e[o.image])
												: new Ur(e[o.image])),
											(a.needsUpdate = !0),
											(a.uuid = o.uuid),
											void 0 !== o.name && (a.name = o.name),
											void 0 !== o.mapping && (a.mapping = n(o.mapping, ud)),
											void 0 !== o.offset && a.offset.fromArray(o.offset),
											void 0 !== o.repeat && a.repeat.fromArray(o.repeat),
											void 0 !== o.center && a.center.fromArray(o.center),
											void 0 !== o.rotation && (a.rotation = o.rotation),
											void 0 !== o.wrap &&
												((a.wrapS = n(o.wrap[0], dd)),
												(a.wrapT = n(o.wrap[1], dd))),
											void 0 !== o.format && (a.format = o.format),
											void 0 !== o.type && (a.type = o.type),
											void 0 !== o.encoding && (a.encoding = o.encoding),
											void 0 !== o.minFilter &&
												(a.minFilter = n(o.minFilter, md)),
											void 0 !== o.magFilter &&
												(a.magFilter = n(o.magFilter, md)),
											void 0 !== o.anisotropy && (a.anisotropy = o.anisotropy),
											void 0 !== o.flipY && (a.flipY = o.flipY),
											void 0 !== o.premultiplyAlpha &&
												(a.premultiplyAlpha = o.premultiplyAlpha),
											void 0 !== o.unpackAlignment &&
												(a.unpackAlignment = o.unpackAlignment),
											(i[o.uuid] = a);
									}
								return i;
							},
							parseObject: function (t, e, n) {
								let i, r, o;
								function a(t) {
									return (
										void 0 === e[t] &&
											console.warn("THREE.ObjectLoader: Undefined geometry", t),
										e[t]
									);
								}
								function s(t) {
									if (void 0 !== t) {
										if (Array.isArray(t)) {
											const e = [];
											for (let i = 0, r = t.length; i < r; i++) {
												const r = t[i];
												void 0 === n[r] &&
													console.warn(
														"THREE.ObjectLoader: Undefined material",
														r
													),
													e.push(n[r]);
											}
											return e;
										}
										return (
											void 0 === n[t] &&
												console.warn(
													"THREE.ObjectLoader: Undefined material",
													t
												),
											n[t]
										);
									}
								}
								switch (t.type) {
									case "Scene":
										(i = new ao()),
											void 0 !== t.background &&
												Number.isInteger(t.background) &&
												(i.background = new Yo(t.background)),
											void 0 !== t.fog &&
												("Fog" === t.fog.type
													? (i.fog = new Ml(t.fog.color, t.fog.near, t.fog.far))
													: "FogExp2" === t.fog.type &&
													  (i.fog = new Rl(t.fog.color, t.fog.density)));
										break;
									case "PerspectiveCamera":
										(i = new rs(t.fov, t.aspect, t.near, t.far)),
											void 0 !== t.focus && (i.focus = t.focus),
											void 0 !== t.zoom && (i.zoom = t.zoom),
											void 0 !== t.filmGauge && (i.filmGauge = t.filmGauge),
											void 0 !== t.filmOffset && (i.filmOffset = t.filmOffset),
											void 0 !== t.view && (i.view = Object.assign({}, t.view));
										break;
									case "OrthographicCamera":
										(i = new Xu(
											t.left,
											t.right,
											t.top,
											t.bottom,
											t.near,
											t.far
										)),
											void 0 !== t.zoom && (i.zoom = t.zoom),
											void 0 !== t.view && (i.view = Object.assign({}, t.view));
										break;
									case "AmbientLight":
										i = new ed(t.color, t.intensity);
										break;
									case "DirectionalLight":
										i = new td(t.color, t.intensity);
										break;
									case "PointLight":
										i = new Yu(t.color, t.intensity, t.distance, t.decay);
										break;
									case "RectAreaLight":
										i = new nd(t.color, t.intensity, t.width, t.height);
										break;
									case "SpotLight":
										i = new Pu(
											t.color,
											t.intensity,
											t.distance,
											t.angle,
											t.penumbra,
											t.decay
										);
										break;
									case "HemisphereLight":
										i = new Gu(t.color, t.groundColor, t.intensity);
										break;
									case "LightProbe":
										i = new rd().fromJSON(t);
										break;
									case "SkinnedMesh":
										console.warn(
											"THREE.ObjectLoader.parseObject() does not support SkinnedMesh yet."
										);
									case "Mesh":
										(r = a(t.geometry)),
											(o = s(t.material)),
											(i = new La(r, o));
										break;
									case "InstancedMesh":
										(r = a(t.geometry)), (o = s(t.material));
										const e = t.count,
											n = t.instanceMatrix;
										(i = new th(r, o, e)),
											(i.instanceMatrix = new sa(
												new Float32Array(n.array),
												16
											));
										break;
									case "LOD":
										i = new Ll();
										break;
									case "Line":
										i = new sh(a(t.geometry), s(t.material), t.mode);
										break;
									case "LineLoop":
										i = new ph(a(t.geometry), s(t.material));
										break;
									case "LineSegments":
										i = new hh(a(t.geometry), s(t.material));
										break;
									case "PointCloud":
									case "Points":
										i = new Sh(a(t.geometry), s(t.material));
										break;
									case "Sprite":
										i = new Nl(s(t.material));
										break;
									case "Group":
										i = new fl();
										break;
									default:
										i = new oo();
								}
								if (
									((i.uuid = t.uuid),
									void 0 !== t.name && (i.name = t.name),
									void 0 !== t.matrix
										? (i.matrix.fromArray(t.matrix),
										  void 0 !== t.matrixAutoUpdate &&
												(i.matrixAutoUpdate = t.matrixAutoUpdate),
										  i.matrixAutoUpdate &&
												i.matrix.decompose(i.position, i.quaternion, i.scale))
										: (void 0 !== t.position &&
												i.position.fromArray(t.position),
										  void 0 !== t.rotation && i.rotation.fromArray(t.rotation),
										  void 0 !== t.quaternion &&
												i.quaternion.fromArray(t.quaternion),
										  void 0 !== t.scale && i.scale.fromArray(t.scale)),
									void 0 !== t.castShadow && (i.castShadow = t.castShadow),
									void 0 !== t.receiveShadow &&
										(i.receiveShadow = t.receiveShadow),
									t.shadow &&
										(void 0 !== t.shadow.bias &&
											(i.shadow.bias = t.shadow.bias),
										void 0 !== t.shadow.normalBias &&
											(i.shadow.normalBias = t.shadow.normalBias),
										void 0 !== t.shadow.radius &&
											(i.shadow.radius = t.shadow.radius),
										void 0 !== t.shadow.mapSize &&
											i.shadow.mapSize.fromArray(t.shadow.mapSize),
										void 0 !== t.shadow.camera &&
											(i.shadow.camera = this.parseObject(t.shadow.camera))),
									void 0 !== t.visible && (i.visible = t.visible),
									void 0 !== t.frustumCulled &&
										(i.frustumCulled = t.frustumCulled),
									void 0 !== t.renderOrder && (i.renderOrder = t.renderOrder),
									void 0 !== t.userData && (i.userData = t.userData),
									void 0 !== t.layers && (i.layers.mask = t.layers),
									void 0 !== t.children)
								) {
									const r = t.children;
									for (let t = 0; t < r.length; t++)
										i.add(this.parseObject(r[t], e, n));
								}
								if ("LOD" === t.type) {
									void 0 !== t.autoUpdate && (i.autoUpdate = t.autoUpdate);
									const e = t.levels;
									for (let t = 0; t < e.length; t++) {
										const n = e[t],
											r = i.getObjectByProperty("uuid", n.object);
										void 0 !== r && i.addLevel(r, n.distance);
									}
								}
								return i;
							},
						});
						const ud = {
								UVMapping: 300,
								CubeReflectionMapping: 301,
								CubeRefractionMapping: 302,
								EquirectangularReflectionMapping: 303,
								EquirectangularRefractionMapping: 304,
								CubeUVReflectionMapping: Fi,
								CubeUVRefractionMapping: Zi,
							},
							dd = {
								RepeatWrapping: Hi,
								ClampToEdgeWrapping: Ni,
								MirroredRepeatWrapping: ji,
							},
							md = {
								NearestFilter: Di,
								NearestMipmapNearestFilter: Ai,
								NearestMipmapLinearFilter: Li,
								LinearFilter: Bi,
								LinearMipmapNearestFilter: 1007,
								LinearMipmapLinearFilter: Gi,
							};
						function fd(t) {
							"undefined" == typeof createImageBitmap &&
								console.warn(
									"THREE.ImageBitmapLoader: createImageBitmap() not supported."
								),
								"undefined" == typeof fetch &&
									console.warn(
										"THREE.ImageBitmapLoader: fetch() not supported."
									),
								du.call(this, t),
								(this.options = { premultiplyAlpha: "none" });
						}
						function gd() {
							(this.type = "ShapePath"),
								(this.color = new Yo()),
								(this.subPaths = []),
								(this.currentPath = null);
						}
						function Sd(t) {
							(this.type = "Font"), (this.data = t);
						}
						function yd(t, e, n, i, r) {
							const o = r.glyphs[t] || r.glyphs["?"];
							if (!o)
								return void console.error(
									'THREE.Font: character "' +
										t +
										'" does not exists in font family ' +
										r.familyName +
										"."
								);
							const a = new gd();
							let s, c, l, h, p, u, d, m;
							if (o.o) {
								const t =
									o._cachedOutline || (o._cachedOutline = o.o.split(" "));
								for (let r = 0, o = t.length; r < o; )
									switch (t[r++]) {
										case "m":
											(s = t[r++] * e + n),
												(c = t[r++] * e + i),
												a.moveTo(s, c);
											break;
										case "l":
											(s = t[r++] * e + n),
												(c = t[r++] * e + i),
												a.lineTo(s, c);
											break;
										case "q":
											(l = t[r++] * e + n),
												(h = t[r++] * e + i),
												(p = t[r++] * e + n),
												(u = t[r++] * e + i),
												a.quadraticCurveTo(p, u, l, h);
											break;
										case "b":
											(l = t[r++] * e + n),
												(h = t[r++] * e + i),
												(p = t[r++] * e + n),
												(u = t[r++] * e + i),
												(d = t[r++] * e + n),
												(m = t[r++] * e + i),
												a.bezierCurveTo(p, u, d, m, l, h);
									}
							}
							return { offsetX: o.ha * e, path: a };
						}
						function Vd(t) {
							du.call(this, t);
						}
						let qd;
						(fd.prototype = Object.assign(Object.create(du.prototype), {
							constructor: fd,
							isImageBitmapLoader: !0,
							setOptions: function (t) {
								return (this.options = t), this;
							},
							load: function (t, e, n, i) {
								void 0 === t && (t = ""),
									void 0 !== this.path && (t = this.path + t),
									(t = this.manager.resolveURL(t));
								const r = this,
									o = hu.get(t);
								if (void 0 !== o)
									return (
										r.manager.itemStart(t),
										setTimeout(function () {
											e && e(o), r.manager.itemEnd(t);
										}, 0),
										o
									);
								fetch(t)
									.then(function (t) {
										return t.blob();
									})
									.then(function (t) {
										return createImageBitmap(t, r.options);
									})
									.then(function (n) {
										hu.add(t, n), e && e(n), r.manager.itemEnd(t);
									})
									.catch(function (e) {
										i && i(e), r.manager.itemError(t), r.manager.itemEnd(t);
									}),
									r.manager.itemStart(t);
							},
						})),
							Object.assign(gd.prototype, {
								moveTo: function (t, e) {
									return (
										(this.currentPath = new Au()),
										this.subPaths.push(this.currentPath),
										this.currentPath.moveTo(t, e),
										this
									);
								},
								lineTo: function (t, e) {
									return this.currentPath.lineTo(t, e), this;
								},
								quadraticCurveTo: function (t, e, n, i) {
									return this.currentPath.quadraticCurveTo(t, e, n, i), this;
								},
								bezierCurveTo: function (t, e, n, i, r, o) {
									return this.currentPath.bezierCurveTo(t, e, n, i, r, o), this;
								},
								splineThru: function (t) {
									return this.currentPath.splineThru(t), this;
								},
								toShapes: function (t, e) {
									function n(t) {
										const e = [];
										for (let n = 0, i = t.length; n < i; n++) {
											const i = t[n],
												r = new Lu();
											(r.curves = i.curves), e.push(r);
										}
										return e;
									}
									function i(t, e) {
										const n = e.length;
										let i = !1;
										for (let r = n - 1, o = 0; o < n; r = o++) {
											let n = e[r],
												a = e[o],
												s = a.x - n.x,
												c = a.y - n.y;
											if (Math.abs(c) > Number.EPSILON) {
												if (
													(c < 0 &&
														((n = e[o]), (s = -s), (a = e[r]), (c = -c)),
													t.y < n.y || t.y > a.y)
												)
													continue;
												if (t.y === n.y) {
													if (t.x === n.x) return !0;
												} else {
													const e = c * (t.x - n.x) - s * (t.y - n.y);
													if (0 === e) return !0;
													if (e < 0) continue;
													i = !i;
												}
											} else {
												if (t.y !== n.y) continue;
												if (
													(a.x <= t.x && t.x <= n.x) ||
													(n.x <= t.x && t.x <= a.x)
												)
													return !0;
											}
										}
										return i;
									}
									const r = up.isClockWise,
										o = this.subPaths;
									if (0 === o.length) return [];
									if (!0 === e) return n(o);
									let a,
										s,
										c,
										l = [];
									if (1 === o.length)
										return (
											(s = o[0]),
											(c = new Lu()),
											(c.curves = s.curves),
											l.push(c),
											l
										);
									let h = !r(o[0].getPoints());
									h = t ? !h : h;
									const p = [],
										u = [];
									let d,
										m,
										f = [],
										g = 0;
									(u[g] = void 0), (f[g] = []);
									for (let e = 0, n = o.length; e < n; e++)
										(s = o[e]),
											(d = s.getPoints()),
											(a = r(d)),
											(a = t ? !a : a),
											a
												? (!h && u[g] && g++,
												  (u[g] = { s: new Lu(), p: d }),
												  (u[g].s.curves = s.curves),
												  h && g++,
												  (f[g] = []))
												: f[g].push({ h: s, p: d[0] });
									if (!u[0]) return n(o);
									if (u.length > 1) {
										let t = !1;
										const e = [];
										for (let t = 0, e = u.length; t < e; t++) p[t] = [];
										for (let n = 0, r = u.length; n < r; n++) {
											const r = f[n];
											for (let o = 0; o < r.length; o++) {
												const a = r[o];
												let s = !0;
												for (let r = 0; r < u.length; r++)
													i(a.p, u[r].p) &&
														(n !== r && e.push({ froms: n, tos: r, hole: o }),
														s ? ((s = !1), p[r].push(a)) : (t = !0));
												s && p[n].push(a);
											}
										}
										e.length > 0 && (t || (f = p));
									}
									for (let t = 0, e = u.length; t < e; t++) {
										(c = u[t].s), l.push(c), (m = f[t]);
										for (let t = 0, e = m.length; t < e; t++)
											c.holes.push(m[t].h);
									}
									return l;
								},
							}),
							Object.assign(Sd.prototype, {
								isFont: !0,
								generateShapes: function (t, e) {
									void 0 === e && (e = 100);
									const n = [],
										i = (function (t, e, n) {
											const i = Array.from
													? Array.from(t)
													: String(t).split(""),
												r = e / n.resolution,
												o =
													(n.boundingBox.yMax -
														n.boundingBox.yMin +
														n.underlineThickness) *
													r,
												a = [];
											let s = 0,
												c = 0;
											for (let t = 0; t < i.length; t++) {
												const e = i[t];
												if ("\n" === e) (s = 0), (c -= o);
												else {
													const t = yd(e, r, s, c, n);
													(s += t.offsetX), a.push(t.path);
												}
											}
											return a;
										})(t, e, this.data);
									for (let t = 0, e = i.length; t < e; t++)
										Array.prototype.push.apply(n, i[t].toShapes());
									return n;
								},
							}),
							(Vd.prototype = Object.assign(Object.create(du.prototype), {
								constructor: Vd,
								load: function (t, e, n, i) {
									const r = this,
										o = new fu(this.manager);
									o.setPath(this.path),
										o.setRequestHeader(this.requestHeader),
										o.load(
											t,
											function (t) {
												let n;
												try {
													n = JSON.parse(t);
												} catch (e) {
													console.warn(
														"THREE.FontLoader: typeface.js support is being deprecated. Use typeface.json instead."
													),
														(n = JSON.parse(t.substring(65, t.length - 2)));
												}
												const i = r.parse(n);
												e && e(i);
											},
											n,
											i
										);
								},
								parse: function (t) {
									return new Sd(t);
								},
							}));
						const Rd = function () {
							return (
								void 0 === qd &&
									(qd = new (window.AudioContext ||
										window.webkitAudioContext)()),
								qd
							);
						};
						function Md(t) {
							du.call(this, t);
						}
						function Id(t, e, n) {
							rd.call(this, void 0, n);
							const i = new Yo().set(t),
								r = new Yo().set(e),
								o = new zr(i.r, i.g, i.b),
								a = new zr(r.r, r.g, r.b),
								s = Math.sqrt(Math.PI),
								c = s * Math.sqrt(0.75);
							this.sh.coefficients[0].copy(o).add(a).multiplyScalar(s),
								this.sh.coefficients[1].copy(o).sub(a).multiplyScalar(c);
						}
						function vd(t, e) {
							rd.call(this, void 0, e);
							const n = new Yo().set(t);
							this.sh.coefficients[0]
								.set(n.r, n.g, n.b)
								.multiplyScalar(2 * Math.sqrt(Math.PI));
						}
						(Md.prototype = Object.assign(Object.create(du.prototype), {
							constructor: Md,
							load: function (t, e, n, i) {
								const r = this,
									o = new fu(r.manager);
								o.setResponseType("arraybuffer"),
									o.setPath(r.path),
									o.setRequestHeader(r.requestHeader),
									o.load(
										t,
										function (n) {
											try {
												const t = n.slice(0);
												Rd().decodeAudioData(t, function (t) {
													e(t);
												});
											} catch (e) {
												i ? i(e) : console.error(e), r.manager.itemError(t);
											}
										},
										n,
										i
									);
							},
						})),
							(Id.prototype = Object.assign(Object.create(rd.prototype), {
								constructor: Id,
								isHemisphereLightProbe: !0,
								copy: function (t) {
									return rd.prototype.copy.call(this, t), this;
								},
								toJSON: function (t) {
									return rd.prototype.toJSON.call(this, t);
								},
							})),
							(vd.prototype = Object.assign(Object.create(rd.prototype), {
								constructor: vd,
								isAmbientLightProbe: !0,
								copy: function (t) {
									return rd.prototype.copy.call(this, t), this;
								},
								toJSON: function (t) {
									return rd.prototype.toJSON.call(this, t);
								},
							}));
						const kd = new jr(),
							Ud = new jr();
						function wd(t) {
							(this.autoStart = void 0 === t || t),
								(this.startTime = 0),
								(this.oldTime = 0),
								(this.elapsedTime = 0),
								(this.running = !1);
						}
						Object.assign(
							function () {
								(this.type = "StereoCamera"),
									(this.aspect = 1),
									(this.eyeSep = 0.064),
									(this.cameraL = new rs()),
									this.cameraL.layers.enable(1),
									(this.cameraL.matrixAutoUpdate = !1),
									(this.cameraR = new rs()),
									this.cameraR.layers.enable(2),
									(this.cameraR.matrixAutoUpdate = !1),
									(this._cache = {
										focus: null,
										fov: null,
										aspect: null,
										near: null,
										far: null,
										zoom: null,
										eyeSep: null,
									});
							}.prototype,
							{
								update: function (t) {
									const e = this._cache;
									if (
										e.focus !== t.focus ||
										e.fov !== t.fov ||
										e.aspect !== t.aspect * this.aspect ||
										e.near !== t.near ||
										e.far !== t.far ||
										e.zoom !== t.zoom ||
										e.eyeSep !== this.eyeSep
									) {
										(e.focus = t.focus),
											(e.fov = t.fov),
											(e.aspect = t.aspect * this.aspect),
											(e.near = t.near),
											(e.far = t.far),
											(e.zoom = t.zoom),
											(e.eyeSep = this.eyeSep);
										const n = t.projectionMatrix.clone(),
											i = e.eyeSep / 2,
											r = (i * e.near) / e.focus,
											o =
												(e.near * Math.tan(qr.DEG2RAD * e.fov * 0.5)) / e.zoom;
										let a, s;
										(Ud.elements[12] = -i),
											(kd.elements[12] = i),
											(a = -o * e.aspect + r),
											(s = o * e.aspect + r),
											(n.elements[0] = (2 * e.near) / (s - a)),
											(n.elements[8] = (s + a) / (s - a)),
											this.cameraL.projectionMatrix.copy(n),
											(a = -o * e.aspect - r),
											(s = o * e.aspect - r),
											(n.elements[0] = (2 * e.near) / (s - a)),
											(n.elements[8] = (s + a) / (s - a)),
											this.cameraR.projectionMatrix.copy(n);
									}
									this.cameraL.matrixWorld.copy(t.matrixWorld).multiply(Ud),
										this.cameraR.matrixWorld.copy(t.matrixWorld).multiply(kd);
								},
							}
						),
							Object.assign(wd.prototype, {
								start: function () {
									(this.startTime = (
										"undefined" == typeof performance ? Date : performance
									).now()),
										(this.oldTime = this.startTime),
										(this.elapsedTime = 0),
										(this.running = !0);
								},
								stop: function () {
									this.getElapsedTime(),
										(this.running = !1),
										(this.autoStart = !1);
								},
								getElapsedTime: function () {
									return this.getDelta(), this.elapsedTime;
								},
								getDelta: function () {
									let t = 0;
									if (this.autoStart && !this.running) return this.start(), 0;
									if (this.running) {
										const e = (
											"undefined" == typeof performance ? Date : performance
										).now();
										(t = (e - this.oldTime) / 1e3),
											(this.oldTime = e),
											(this.elapsedTime += t);
									}
									return t;
								},
							});
						const xd = new zr(),
							Od = new br(),
							bd = new zr(),
							Kd = new zr();
						function Td() {
							oo.call(this),
								(this.type = "AudioListener"),
								(this.context = Rd()),
								(this.gain = this.context.createGain()),
								this.gain.connect(this.context.destination),
								(this.filter = null),
								(this.timeDelta = 0),
								(this._clock = new wd());
						}
						function zd(t) {
							oo.call(this),
								(this.type = "Audio"),
								(this.listener = t),
								(this.context = t.context),
								(this.gain = this.context.createGain()),
								this.gain.connect(t.getInput()),
								(this.autoplay = !1),
								(this.buffer = null),
								(this.detune = 0),
								(this.loop = !1),
								(this.loopStart = 0),
								(this.loopEnd = 0),
								(this.offset = 0),
								(this.duration = void 0),
								(this.playbackRate = 1),
								(this.isPlaying = !1),
								(this.hasPlaybackControl = !0),
								(this.sourceType = "empty"),
								(this._startedAt = 0),
								(this._progress = 0),
								(this.filters = []);
						}
						(Td.prototype = Object.assign(Object.create(oo.prototype), {
							constructor: Td,
							getInput: function () {
								return this.gain;
							},
							removeFilter: function () {
								return (
									null !== this.filter &&
										(this.gain.disconnect(this.filter),
										this.filter.disconnect(this.context.destination),
										this.gain.connect(this.context.destination),
										(this.filter = null)),
									this
								);
							},
							getFilter: function () {
								return this.filter;
							},
							setFilter: function (t) {
								return (
									null !== this.filter
										? (this.gain.disconnect(this.filter),
										  this.filter.disconnect(this.context.destination))
										: this.gain.disconnect(this.context.destination),
									(this.filter = t),
									this.gain.connect(this.filter),
									this.filter.connect(this.context.destination),
									this
								);
							},
							getMasterVolume: function () {
								return this.gain.gain.value;
							},
							setMasterVolume: function (t) {
								return (
									this.gain.gain.setTargetAtTime(
										t,
										this.context.currentTime,
										0.01
									),
									this
								);
							},
							updateMatrixWorld: function (t) {
								oo.prototype.updateMatrixWorld.call(this, t);
								const e = this.context.listener,
									n = this.up;
								if (
									((this.timeDelta = this._clock.getDelta()),
									this.matrixWorld.decompose(xd, Od, bd),
									Kd.set(0, 0, -1).applyQuaternion(Od),
									e.positionX)
								) {
									const t = this.context.currentTime + this.timeDelta;
									e.positionX.linearRampToValueAtTime(xd.x, t),
										e.positionY.linearRampToValueAtTime(xd.y, t),
										e.positionZ.linearRampToValueAtTime(xd.z, t),
										e.forwardX.linearRampToValueAtTime(Kd.x, t),
										e.forwardY.linearRampToValueAtTime(Kd.y, t),
										e.forwardZ.linearRampToValueAtTime(Kd.z, t),
										e.upX.linearRampToValueAtTime(n.x, t),
										e.upY.linearRampToValueAtTime(n.y, t),
										e.upZ.linearRampToValueAtTime(n.z, t);
								} else
									e.setPosition(xd.x, xd.y, xd.z),
										e.setOrientation(Kd.x, Kd.y, Kd.z, n.x, n.y, n.z);
							},
						})),
							(zd.prototype = Object.assign(Object.create(oo.prototype), {
								constructor: zd,
								getOutput: function () {
									return this.gain;
								},
								setNodeSource: function (t) {
									return (
										(this.hasPlaybackControl = !1),
										(this.sourceType = "audioNode"),
										(this.source = t),
										this.connect(),
										this
									);
								},
								setMediaElementSource: function (t) {
									return (
										(this.hasPlaybackControl = !1),
										(this.sourceType = "mediaNode"),
										(this.source = this.context.createMediaElementSource(t)),
										this.connect(),
										this
									);
								},
								setMediaStreamSource: function (t) {
									return (
										(this.hasPlaybackControl = !1),
										(this.sourceType = "mediaStreamNode"),
										(this.source = this.context.createMediaStreamSource(t)),
										this.connect(),
										this
									);
								},
								setBuffer: function (t) {
									return (
										(this.buffer = t),
										(this.sourceType = "buffer"),
										this.autoplay && this.play(),
										this
									);
								},
								play: function (t) {
									if ((void 0 === t && (t = 0), !0 === this.isPlaying))
										return void console.warn(
											"THREE.Audio: Audio is already playing."
										);
									if (!1 === this.hasPlaybackControl)
										return void console.warn(
											"THREE.Audio: this Audio has no playback control."
										);
									this._startedAt = this.context.currentTime + t;
									const e = this.context.createBufferSource();
									return (
										(e.buffer = this.buffer),
										(e.loop = this.loop),
										(e.loopStart = this.loopStart),
										(e.loopEnd = this.loopEnd),
										(e.onended = this.onEnded.bind(this)),
										e.start(
											this._startedAt,
											this._progress + this.offset,
											this.duration
										),
										(this.isPlaying = !0),
										(this.source = e),
										this.setDetune(this.detune),
										this.setPlaybackRate(this.playbackRate),
										this.connect()
									);
								},
								pause: function () {
									if (!1 !== this.hasPlaybackControl)
										return (
											!0 === this.isPlaying &&
												((this._progress +=
													Math.max(
														this.context.currentTime - this._startedAt,
														0
													) * this.playbackRate),
												!0 === this.loop &&
													(this._progress =
														this._progress %
														(this.duration || this.buffer.duration)),
												this.source.stop(),
												(this.source.onended = null),
												(this.isPlaying = !1)),
											this
										);
									console.warn(
										"THREE.Audio: this Audio has no playback control."
									);
								},
								stop: function () {
									if (!1 !== this.hasPlaybackControl)
										return (
											(this._progress = 0),
											this.source.stop(),
											(this.source.onended = null),
											(this.isPlaying = !1),
											this
										);
									console.warn(
										"THREE.Audio: this Audio has no playback control."
									);
								},
								connect: function () {
									if (this.filters.length > 0) {
										this.source.connect(this.filters[0]);
										for (let t = 1, e = this.filters.length; t < e; t++)
											this.filters[t - 1].connect(this.filters[t]);
										this.filters[this.filters.length - 1].connect(
											this.getOutput()
										);
									} else this.source.connect(this.getOutput());
									return this;
								},
								disconnect: function () {
									if (this.filters.length > 0) {
										this.source.disconnect(this.filters[0]);
										for (let t = 1, e = this.filters.length; t < e; t++)
											this.filters[t - 1].disconnect(this.filters[t]);
										this.filters[this.filters.length - 1].disconnect(
											this.getOutput()
										);
									} else this.source.disconnect(this.getOutput());
									return this;
								},
								getFilters: function () {
									return this.filters;
								},
								setFilters: function (t) {
									return (
										t || (t = []),
										!0 === this.isPlaying
											? (this.disconnect(), (this.filters = t), this.connect())
											: (this.filters = t),
										this
									);
								},
								setDetune: function (t) {
									if (((this.detune = t), void 0 !== this.source.detune))
										return (
											!0 === this.isPlaying &&
												this.source.detune.setTargetAtTime(
													this.detune,
													this.context.currentTime,
													0.01
												),
											this
										);
								},
								getDetune: function () {
									return this.detune;
								},
								getFilter: function () {
									return this.getFilters()[0];
								},
								setFilter: function (t) {
									return this.setFilters(t ? [t] : []);
								},
								setPlaybackRate: function (t) {
									if (!1 !== this.hasPlaybackControl)
										return (
											(this.playbackRate = t),
											!0 === this.isPlaying &&
												this.source.playbackRate.setTargetAtTime(
													this.playbackRate,
													this.context.currentTime,
													0.01
												),
											this
										);
									console.warn(
										"THREE.Audio: this Audio has no playback control."
									);
								},
								getPlaybackRate: function () {
									return this.playbackRate;
								},
								onEnded: function () {
									this.isPlaying = !1;
								},
								getLoop: function () {
									return !1 === this.hasPlaybackControl
										? (console.warn(
												"THREE.Audio: this Audio has no playback control."
										  ),
										  !1)
										: this.loop;
								},
								setLoop: function (t) {
									if (!1 !== this.hasPlaybackControl)
										return (
											(this.loop = t),
											!0 === this.isPlaying && (this.source.loop = this.loop),
											this
										);
									console.warn(
										"THREE.Audio: this Audio has no playback control."
									);
								},
								setLoopStart: function (t) {
									return (this.loopStart = t), this;
								},
								setLoopEnd: function (t) {
									return (this.loopEnd = t), this;
								},
								getVolume: function () {
									return this.gain.gain.value;
								},
								setVolume: function (t) {
									return (
										this.gain.gain.setTargetAtTime(
											t,
											this.context.currentTime,
											0.01
										),
										this
									);
								},
							}));
						const Wd = new zr(),
							Ed = new br(),
							Cd = new zr(),
							Fd = new zr();
						function Zd(t) {
							zd.call(this, t),
								(this.panner = this.context.createPanner()),
								(this.panner.panningModel = "HRTF"),
								this.panner.connect(this.gain);
						}
						function Hd(t, e) {
							(this.analyser = t.context.createAnalyser()),
								(this.analyser.fftSize = void 0 !== e ? e : 2048),
								(this.data = new Uint8Array(this.analyser.frequencyBinCount)),
								t.getOutput().connect(this.analyser);
						}
						function Nd(t, e, n) {
							let i, r, o;
							switch (((this.binding = t), (this.valueSize = n), e)) {
								case "quaternion":
									(i = this._slerp),
										(r = this._slerpAdditive),
										(o = this._setAdditiveIdentityQuaternion),
										(this.buffer = new Float64Array(6 * n)),
										(this._workIndex = 5);
									break;
								case "string":
								case "bool":
									(i = this._select),
										(r = this._select),
										(o = this._setAdditiveIdentityOther),
										(this.buffer = new Array(5 * n));
									break;
								default:
									(i = this._lerp),
										(r = this._lerpAdditive),
										(o = this._setAdditiveIdentityNumeric),
										(this.buffer = new Float64Array(5 * n));
							}
							(this._mixBufferRegion = i),
								(this._mixBufferRegionAdditive = r),
								(this._setIdentity = o),
								(this._origIndex = 3),
								(this._addIndex = 4),
								(this.cumulativeWeight = 0),
								(this.cumulativeWeightAdditive = 0),
								(this.useCount = 0),
								(this.referenceCount = 0);
						}
						(Zd.prototype = Object.assign(Object.create(zd.prototype), {
							constructor: Zd,
							getOutput: function () {
								return this.panner;
							},
							getRefDistance: function () {
								return this.panner.refDistance;
							},
							setRefDistance: function (t) {
								return (this.panner.refDistance = t), this;
							},
							getRolloffFactor: function () {
								return this.panner.rolloffFactor;
							},
							setRolloffFactor: function (t) {
								return (this.panner.rolloffFactor = t), this;
							},
							getDistanceModel: function () {
								return this.panner.distanceModel;
							},
							setDistanceModel: function (t) {
								return (this.panner.distanceModel = t), this;
							},
							getMaxDistance: function () {
								return this.panner.maxDistance;
							},
							setMaxDistance: function (t) {
								return (this.panner.maxDistance = t), this;
							},
							setDirectionalCone: function (t, e, n) {
								return (
									(this.panner.coneInnerAngle = t),
									(this.panner.coneOuterAngle = e),
									(this.panner.coneOuterGain = n),
									this
								);
							},
							updateMatrixWorld: function (t) {
								if (
									(oo.prototype.updateMatrixWorld.call(this, t),
									!0 === this.hasPlaybackControl && !1 === this.isPlaying)
								)
									return;
								this.matrixWorld.decompose(Wd, Ed, Cd),
									Fd.set(0, 0, 1).applyQuaternion(Ed);
								const e = this.panner;
								if (e.positionX) {
									const t = this.context.currentTime + this.listener.timeDelta;
									e.positionX.linearRampToValueAtTime(Wd.x, t),
										e.positionY.linearRampToValueAtTime(Wd.y, t),
										e.positionZ.linearRampToValueAtTime(Wd.z, t),
										e.orientationX.linearRampToValueAtTime(Fd.x, t),
										e.orientationY.linearRampToValueAtTime(Fd.y, t),
										e.orientationZ.linearRampToValueAtTime(Fd.z, t);
								} else
									e.setPosition(Wd.x, Wd.y, Wd.z),
										e.setOrientation(Fd.x, Fd.y, Fd.z);
							},
						})),
							Object.assign(Hd.prototype, {
								getFrequencyData: function () {
									return (
										this.analyser.getByteFrequencyData(this.data), this.data
									);
								},
								getAverageFrequency: function () {
									let t = 0;
									const e = this.getFrequencyData();
									for (let n = 0; n < e.length; n++) t += e[n];
									return t / e.length;
								},
							}),
							Object.assign(Nd.prototype, {
								accumulate: function (t, e) {
									const n = this.buffer,
										i = this.valueSize,
										r = t * i + i;
									let o = this.cumulativeWeight;
									if (0 === o) {
										for (let t = 0; t !== i; ++t) n[r + t] = n[t];
										o = e;
									} else {
										o += e;
										const t = e / o;
										this._mixBufferRegion(n, r, 0, t, i);
									}
									this.cumulativeWeight = o;
								},
								accumulateAdditive: function (t) {
									const e = this.buffer,
										n = this.valueSize,
										i = n * this._addIndex;
									0 === this.cumulativeWeightAdditive && this._setIdentity(),
										this._mixBufferRegionAdditive(e, i, 0, t, n),
										(this.cumulativeWeightAdditive += t);
								},
								apply: function (t) {
									const e = this.valueSize,
										n = this.buffer,
										i = t * e + e,
										r = this.cumulativeWeight,
										o = this.cumulativeWeightAdditive,
										a = this.binding;
									if (
										((this.cumulativeWeight = 0),
										(this.cumulativeWeightAdditive = 0),
										r < 1)
									) {
										const t = e * this._origIndex;
										this._mixBufferRegion(n, i, t, 1 - r, e);
									}
									o > 0 &&
										this._mixBufferRegionAdditive(
											n,
											i,
											this._addIndex * e,
											1,
											e
										);
									for (let t = e, r = e + e; t !== r; ++t)
										if (n[t] !== n[t + e]) {
											a.setValue(n, i);
											break;
										}
								},
								saveOriginalState: function () {
									const t = this.binding,
										e = this.buffer,
										n = this.valueSize,
										i = n * this._origIndex;
									t.getValue(e, i);
									for (let t = n, r = i; t !== r; ++t) e[t] = e[i + (t % n)];
									this._setIdentity(),
										(this.cumulativeWeight = 0),
										(this.cumulativeWeightAdditive = 0);
								},
								restoreOriginalState: function () {
									const t = 3 * this.valueSize;
									this.binding.setValue(this.buffer, t);
								},
								_setAdditiveIdentityNumeric: function () {
									const t = this._addIndex * this.valueSize,
										e = t + this.valueSize;
									for (let n = t; n < e; n++) this.buffer[n] = 0;
								},
								_setAdditiveIdentityQuaternion: function () {
									this._setAdditiveIdentityNumeric(),
										(this.buffer[4 * this._addIndex + 3] = 1);
								},
								_setAdditiveIdentityOther: function () {
									const t = this._origIndex * this.valueSize,
										e = this._addIndex * this.valueSize;
									for (let n = 0; n < this.valueSize; n++)
										this.buffer[e + n] = this.buffer[t + n];
								},
								_select: function (t, e, n, i, r) {
									if (i >= 0.5)
										for (let i = 0; i !== r; ++i) t[e + i] = t[n + i];
								},
								_slerp: function (t, e, n, i) {
									br.slerpFlat(t, e, t, e, t, n, i);
								},
								_slerpAdditive: function (t, e, n, i, r) {
									const o = this._workIndex * r;
									br.multiplyQuaternionsFlat(t, o, t, e, t, n),
										br.slerpFlat(t, e, t, e, t, o, i);
								},
								_lerp: function (t, e, n, i, r) {
									const o = 1 - i;
									for (let a = 0; a !== r; ++a) {
										const r = e + a;
										t[r] = t[r] * o + t[n + a] * i;
									}
								},
								_lerpAdditive: function (t, e, n, i, r) {
									for (let o = 0; o !== r; ++o) {
										const r = e + o;
										t[r] = t[r] + t[n + o] * i;
									}
								},
							});
						const jd = new RegExp("[\\[\\]\\.:\\/]", "g"),
							Dd = "[^\\[\\]\\.:\\/]",
							Ad = "[^" + "\\[\\]\\.:\\/".replace("\\.", "") + "]",
							Ld = /((?:WC+[\/:])*)/.source.replace("WC", Dd),
							Bd = /(WCOD+)?/.source.replace("WCOD", Ad),
							Gd = /(?:\.(WC+)(?:\[(.+)\])?)?/.source.replace("WC", Dd),
							Qd = /\.(WC+)(?:\[(.+)\])?/.source.replace("WC", Dd),
							_d = new RegExp("^" + Ld + Bd + Gd + Qd + "$"),
							Pd = ["material", "materials", "bones"];
						function Jd(t, e, n) {
							const i = n || Yd.parseTrackName(e);
							(this._targetGroup = t), (this._bindings = t.subscribe_(e, i));
						}
						function Yd(t, e, n) {
							(this.path = e),
								(this.parsedPath = n || Yd.parseTrackName(e)),
								(this.node = Yd.findNode(t, this.parsedPath.nodeName) || t),
								(this.rootNode = t);
						}
						function Xd(t, e, n, i) {
							(this._mixer = t),
								(this._clip = e),
								(this._localRoot = n || null),
								(this.blendMode = i || e.blendMode);
							const r = e.tracks,
								o = r.length,
								a = new Array(o),
								s = { endingStart: ar, endingEnd: ar };
							for (let t = 0; t !== o; ++t) {
								const e = r[t].createInterpolant(null);
								(a[t] = e), (e.settings = s);
							}
							(this._interpolantSettings = s),
								(this._interpolants = a),
								(this._propertyBindings = new Array(o)),
								(this._cacheIndex = null),
								(this._byClipCacheIndex = null),
								(this._timeScaleInterpolant = null),
								(this._weightInterpolant = null),
								(this.loop = 2201),
								(this._loopCount = -1),
								(this._startTime = null),
								(this.time = 0),
								(this.timeScale = 1),
								(this._effectiveTimeScale = 1),
								(this.weight = 1),
								(this._effectiveWeight = 1),
								(this.repetitions = 1 / 0),
								(this.paused = !1),
								(this.enabled = !0),
								(this.clampWhenFinished = !1),
								(this.zeroSlopeAtStart = !0),
								(this.zeroSlopeAtEnd = !0);
						}
						function $d(t) {
							(this._root = t),
								this._initMemoryManager(),
								(this._accuIndex = 0),
								(this.time = 0),
								(this.timeScale = 1);
						}
						function tm(t) {
							"string" == typeof t &&
								(console.warn(
									"THREE.Uniform: Type parameter is no longer needed."
								),
								(t = arguments[1])),
								(this.value = t);
						}
						function em(t, e, n) {
							Il.call(this, t, e), (this.meshPerAttribute = n || 1);
						}
						function nm(t, e, n, i) {
							(this.ray = new To(t, e)),
								(this.near = n || 0),
								(this.far = i || 1 / 0),
								(this.camera = null),
								(this.layers = new Br()),
								(this.params = {
									Mesh: {},
									Line: { threshold: 1 },
									LOD: {},
									Points: { threshold: 1 },
									Sprite: {},
								}),
								Object.defineProperties(this.params, {
									PointCloud: {
										get: function () {
											return (
												console.warn(
													"THREE.Raycaster: params.PointCloud has been renamed to params.Points."
												),
												this.Points
											);
										},
									},
								});
						}
						function im(t, e) {
							return t.distance - e.distance;
						}
						function rm(t, e, n, i) {
							if ((t.layers.test(e.layers) && t.raycast(e, n), !0 === i)) {
								const i = t.children;
								for (let t = 0, r = i.length; t < r; t++) rm(i[t], e, n, !0);
							}
						}
						Object.assign(Jd.prototype, {
							getValue: function (t, e) {
								this.bind();
								const n = this._targetGroup.nCachedObjects_,
									i = this._bindings[n];
								void 0 !== i && i.getValue(t, e);
							},
							setValue: function (t, e) {
								const n = this._bindings;
								for (
									let i = this._targetGroup.nCachedObjects_, r = n.length;
									i !== r;
									++i
								)
									n[i].setValue(t, e);
							},
							bind: function () {
								const t = this._bindings;
								for (
									let e = this._targetGroup.nCachedObjects_, n = t.length;
									e !== n;
									++e
								)
									t[e].bind();
							},
							unbind: function () {
								const t = this._bindings;
								for (
									let e = this._targetGroup.nCachedObjects_, n = t.length;
									e !== n;
									++e
								)
									t[e].unbind();
							},
						}),
							Object.assign(Yd, {
								Composite: Jd,
								create: function (t, e, n) {
									return t && t.isAnimationObjectGroup
										? new Yd.Composite(t, e, n)
										: new Yd(t, e, n);
								},
								sanitizeNodeName: function (t) {
									return t.replace(/\s/g, "_").replace(jd, "");
								},
								parseTrackName: function (t) {
									const e = _d.exec(t);
									if (!e)
										throw new Error(
											"PropertyBinding: Cannot parse trackName: " + t
										);
									const n = {
											nodeName: e[2],
											objectName: e[3],
											objectIndex: e[4],
											propertyName: e[5],
											propertyIndex: e[6],
										},
										i = n.nodeName && n.nodeName.lastIndexOf(".");
									if (void 0 !== i && -1 !== i) {
										const t = n.nodeName.substring(i + 1);
										-1 !== Pd.indexOf(t) &&
											((n.nodeName = n.nodeName.substring(0, i)),
											(n.objectName = t));
									}
									if (null === n.propertyName || 0 === n.propertyName.length)
										throw new Error(
											"PropertyBinding: can not parse propertyName from trackName: " +
												t
										);
									return n;
								},
								findNode: function (t, e) {
									if (
										!e ||
										"" === e ||
										"." === e ||
										-1 === e ||
										e === t.name ||
										e === t.uuid
									)
										return t;
									if (t.skeleton) {
										const n = t.skeleton.getBoneByName(e);
										if (void 0 !== n) return n;
									}
									if (t.children) {
										const n = function (t) {
												for (let i = 0; i < t.length; i++) {
													const r = t[i];
													if (r.name === e || r.uuid === e) return r;
													const o = n(r.children);
													if (o) return o;
												}
												return null;
											},
											i = n(t.children);
										if (i) return i;
									}
									return null;
								},
							}),
							Object.assign(Yd.prototype, {
								_getValue_unavailable: function () {},
								_setValue_unavailable: function () {},
								BindingType: {
									Direct: 0,
									EntireArray: 1,
									ArrayElement: 2,
									HasFromToArray: 3,
								},
								Versioning: {
									None: 0,
									NeedsUpdate: 1,
									MatrixWorldNeedsUpdate: 2,
								},
								GetterByBindingType: [
									function (t, e) {
										t[e] = this.node[this.propertyName];
									},
									function (t, e) {
										const n = this.resolvedProperty;
										for (let i = 0, r = n.length; i !== r; ++i) t[e++] = n[i];
									},
									function (t, e) {
										t[e] = this.resolvedProperty[this.propertyIndex];
									},
									function (t, e) {
										this.resolvedProperty.toArray(t, e);
									},
								],
								SetterByBindingTypeAndVersioning: [
									[
										function (t, e) {
											this.targetObject[this.propertyName] = t[e];
										},
										function (t, e) {
											(this.targetObject[this.propertyName] = t[e]),
												(this.targetObject.needsUpdate = !0);
										},
										function (t, e) {
											(this.targetObject[this.propertyName] = t[e]),
												(this.targetObject.matrixWorldNeedsUpdate = !0);
										},
									],
									[
										function (t, e) {
											const n = this.resolvedProperty;
											for (let i = 0, r = n.length; i !== r; ++i) n[i] = t[e++];
										},
										function (t, e) {
											const n = this.resolvedProperty;
											for (let i = 0, r = n.length; i !== r; ++i) n[i] = t[e++];
											this.targetObject.needsUpdate = !0;
										},
										function (t, e) {
											const n = this.resolvedProperty;
											for (let i = 0, r = n.length; i !== r; ++i) n[i] = t[e++];
											this.targetObject.matrixWorldNeedsUpdate = !0;
										},
									],
									[
										function (t, e) {
											this.resolvedProperty[this.propertyIndex] = t[e];
										},
										function (t, e) {
											(this.resolvedProperty[this.propertyIndex] = t[e]),
												(this.targetObject.needsUpdate = !0);
										},
										function (t, e) {
											(this.resolvedProperty[this.propertyIndex] = t[e]),
												(this.targetObject.matrixWorldNeedsUpdate = !0);
										},
									],
									[
										function (t, e) {
											this.resolvedProperty.fromArray(t, e);
										},
										function (t, e) {
											this.resolvedProperty.fromArray(t, e),
												(this.targetObject.needsUpdate = !0);
										},
										function (t, e) {
											this.resolvedProperty.fromArray(t, e),
												(this.targetObject.matrixWorldNeedsUpdate = !0);
										},
									],
								],
								getValue: function (t, e) {
									this.bind(), this.getValue(t, e);
								},
								setValue: function (t, e) {
									this.bind(), this.setValue(t, e);
								},
								bind: function () {
									let t = this.node,
										e = this.parsedPath,
										n = e.objectName,
										i = e.propertyName,
										r = e.propertyIndex;
									if (
										(t ||
											((t =
												Yd.findNode(this.rootNode, e.nodeName) ||
												this.rootNode),
											(this.node = t)),
										(this.getValue = this._getValue_unavailable),
										(this.setValue = this._setValue_unavailable),
										!t)
									)
										return void console.error(
											"THREE.PropertyBinding: Trying to update node for track: " +
												this.path +
												" but it wasn't found."
										);
									if (n) {
										let i = e.objectIndex;
										switch (n) {
											case "materials":
												if (!t.material)
													return void console.error(
														"THREE.PropertyBinding: Can not bind to material as node does not have a material.",
														this
													);
												if (!t.material.materials)
													return void console.error(
														"THREE.PropertyBinding: Can not bind to material.materials as node.material does not have a materials array.",
														this
													);
												t = t.material.materials;
												break;
											case "bones":
												if (!t.skeleton)
													return void console.error(
														"THREE.PropertyBinding: Can not bind to bones as node does not have a skeleton.",
														this
													);
												t = t.skeleton.bones;
												for (let e = 0; e < t.length; e++)
													if (t[e].name === i) {
														i = e;
														break;
													}
												break;
											default:
												if (void 0 === t[n])
													return void console.error(
														"THREE.PropertyBinding: Can not bind to objectName of node undefined.",
														this
													);
												t = t[n];
										}
										if (void 0 !== i) {
											if (void 0 === t[i])
												return void console.error(
													"THREE.PropertyBinding: Trying to bind to objectIndex of objectName, but is undefined.",
													this,
													t
												);
											t = t[i];
										}
									}
									const o = t[i];
									if (void 0 === o) {
										const n = e.nodeName;
										return void console.error(
											"THREE.PropertyBinding: Trying to update property for track: " +
												n +
												"." +
												i +
												" but it wasn't found.",
											t
										);
									}
									let a = this.Versioning.None;
									(this.targetObject = t),
										void 0 !== t.needsUpdate
											? (a = this.Versioning.NeedsUpdate)
											: void 0 !== t.matrixWorldNeedsUpdate &&
											  (a = this.Versioning.MatrixWorldNeedsUpdate);
									let s = this.BindingType.Direct;
									if (void 0 !== r) {
										if ("morphTargetInfluences" === i) {
											if (!t.geometry)
												return void console.error(
													"THREE.PropertyBinding: Can not bind to morphTargetInfluences because node does not have a geometry.",
													this
												);
											if (!t.geometry.isBufferGeometry)
												return void console.error(
													"THREE.PropertyBinding: Can not bind to morphTargetInfluences on THREE.Geometry. Use THREE.BufferGeometry instead.",
													this
												);
											if (!t.geometry.morphAttributes)
												return void console.error(
													"THREE.PropertyBinding: Can not bind to morphTargetInfluences because node does not have a geometry.morphAttributes.",
													this
												);
											void 0 !== t.morphTargetDictionary[r] &&
												(r = t.morphTargetDictionary[r]);
										}
										(s = this.BindingType.ArrayElement),
											(this.resolvedProperty = o),
											(this.propertyIndex = r);
									} else
										void 0 !== o.fromArray && void 0 !== o.toArray
											? ((s = this.BindingType.HasFromToArray),
											  (this.resolvedProperty = o))
											: Array.isArray(o)
											? ((s = this.BindingType.EntireArray),
											  (this.resolvedProperty = o))
											: (this.propertyName = i);
									(this.getValue = this.GetterByBindingType[s]),
										(this.setValue =
											this.SetterByBindingTypeAndVersioning[s][a]);
								},
								unbind: function () {
									(this.node = null),
										(this.getValue = this._getValue_unbound),
										(this.setValue = this._setValue_unbound);
								},
							}),
							Object.assign(Yd.prototype, {
								_getValue_unbound: Yd.prototype.getValue,
								_setValue_unbound: Yd.prototype.setValue,
							}),
							Object.assign(
								function () {
									(this.uuid = qr.generateUUID()),
										(this._objects = Array.prototype.slice.call(arguments)),
										(this.nCachedObjects_ = 0);
									const t = {};
									this._indicesByUUID = t;
									for (let e = 0, n = arguments.length; e !== n; ++e)
										t[arguments[e].uuid] = e;
									(this._paths = []),
										(this._parsedPaths = []),
										(this._bindings = []),
										(this._bindingsIndicesByPath = {});
									const e = this;
									this.stats = {
										objects: {
											get total() {
												return e._objects.length;
											},
											get inUse() {
												return this.total - e.nCachedObjects_;
											},
										},
										get bindingsPerObject() {
											return e._bindings.length;
										},
									};
								}.prototype,
								{
									isAnimationObjectGroup: !0,
									add: function () {
										const t = this._objects,
											e = this._indicesByUUID,
											n = this._paths,
											i = this._parsedPaths,
											r = this._bindings,
											o = r.length;
										let a,
											s = t.length,
											c = this.nCachedObjects_;
										for (let l = 0, h = arguments.length; l !== h; ++l) {
											const h = arguments[l],
												p = h.uuid;
											let u = e[p];
											if (void 0 === u) {
												(u = s++), (e[p] = u), t.push(h);
												for (let t = 0, e = o; t !== e; ++t)
													r[t].push(new Yd(h, n[t], i[t]));
											} else if (u < c) {
												a = t[u];
												const s = --c,
													l = t[s];
												(e[l.uuid] = u), (t[u] = l), (e[p] = s), (t[s] = h);
												for (let t = 0, e = o; t !== e; ++t) {
													const e = r[t],
														o = e[s];
													let a = e[u];
													(e[u] = o),
														void 0 === a && (a = new Yd(h, n[t], i[t])),
														(e[s] = a);
												}
											} else
												t[u] !== a &&
													console.error(
														"THREE.AnimationObjectGroup: Different objects with the same UUID detected. Clean the caches or recreate your infrastructure when reloading scenes."
													);
										}
										this.nCachedObjects_ = c;
									},
									remove: function () {
										const t = this._objects,
											e = this._indicesByUUID,
											n = this._bindings,
											i = n.length;
										let r = this.nCachedObjects_;
										for (let o = 0, a = arguments.length; o !== a; ++o) {
											const a = arguments[o],
												s = a.uuid,
												c = e[s];
											if (void 0 !== c && c >= r) {
												const o = r++,
													l = t[o];
												(e[l.uuid] = c), (t[c] = l), (e[s] = o), (t[o] = a);
												for (let t = 0, e = i; t !== e; ++t) {
													const e = n[t],
														i = e[o],
														r = e[c];
													(e[c] = i), (e[o] = r);
												}
											}
										}
										this.nCachedObjects_ = r;
									},
									uncache: function () {
										const t = this._objects,
											e = this._indicesByUUID,
											n = this._bindings,
											i = n.length;
										let r = this.nCachedObjects_,
											o = t.length;
										for (let a = 0, s = arguments.length; a !== s; ++a) {
											const s = arguments[a].uuid,
												c = e[s];
											if (void 0 !== c)
												if ((delete e[s], c < r)) {
													const a = --r,
														s = t[a],
														l = --o,
														h = t[l];
													(e[s.uuid] = c),
														(t[c] = s),
														(e[h.uuid] = a),
														(t[a] = h),
														t.pop();
													for (let t = 0, e = i; t !== e; ++t) {
														const e = n[t],
															i = e[a],
															r = e[l];
														(e[c] = i), (e[a] = r), e.pop();
													}
												} else {
													const r = --o,
														a = t[r];
													(e[a.uuid] = c), (t[c] = a), t.pop();
													for (let t = 0, e = i; t !== e; ++t) {
														const e = n[t];
														(e[c] = e[r]), e.pop();
													}
												}
										}
										this.nCachedObjects_ = r;
									},
									subscribe_: function (t, e) {
										let n = this._bindingsIndicesByPath,
											i = n[t],
											r = this._bindings;
										if (void 0 !== i) return r[i];
										const o = this._paths,
											a = this._parsedPaths,
											s = this._objects,
											c = s.length,
											l = this.nCachedObjects_,
											h = new Array(c);
										(i = r.length), (n[t] = i), o.push(t), a.push(e), r.push(h);
										for (let n = l, i = s.length; n !== i; ++n) {
											const i = s[n];
											h[n] = new Yd(i, t, e);
										}
										return h;
									},
									unsubscribe_: function (t) {
										const e = this._bindingsIndicesByPath,
											n = e[t];
										if (void 0 !== n) {
											const i = this._paths,
												r = this._parsedPaths,
												o = this._bindings,
												a = o.length - 1,
												s = o[a];
											(e[t[a]] = n),
												(o[n] = s),
												o.pop(),
												(r[n] = r[a]),
												r.pop(),
												(i[n] = i[a]),
												i.pop();
										}
									},
								}
							),
							Object.assign(Xd.prototype, {
								play: function () {
									return this._mixer._activateAction(this), this;
								},
								stop: function () {
									return this._mixer._deactivateAction(this), this.reset();
								},
								reset: function () {
									return (
										(this.paused = !1),
										(this.enabled = !0),
										(this.time = 0),
										(this._loopCount = -1),
										(this._startTime = null),
										this.stopFading().stopWarping()
									);
								},
								isRunning: function () {
									return (
										this.enabled &&
										!this.paused &&
										0 !== this.timeScale &&
										null === this._startTime &&
										this._mixer._isActiveAction(this)
									);
								},
								isScheduled: function () {
									return this._mixer._isActiveAction(this);
								},
								startAt: function (t) {
									return (this._startTime = t), this;
								},
								setLoop: function (t, e) {
									return (this.loop = t), (this.repetitions = e), this;
								},
								setEffectiveWeight: function (t) {
									return (
										(this.weight = t),
										(this._effectiveWeight = this.enabled ? t : 0),
										this.stopFading()
									);
								},
								getEffectiveWeight: function () {
									return this._effectiveWeight;
								},
								fadeIn: function (t) {
									return this._scheduleFading(t, 0, 1);
								},
								fadeOut: function (t) {
									return this._scheduleFading(t, 1, 0);
								},
								crossFadeFrom: function (t, e, n) {
									if ((t.fadeOut(e), this.fadeIn(e), n)) {
										const n = this._clip.duration,
											i = t._clip.duration,
											r = i / n,
											o = n / i;
										t.warp(1, r, e), this.warp(o, 1, e);
									}
									return this;
								},
								crossFadeTo: function (t, e, n) {
									return t.crossFadeFrom(this, e, n);
								},
								stopFading: function () {
									let t = this._weightInterpolant;
									return (
										null !== t &&
											((this._weightInterpolant = null),
											this._mixer._takeBackControlInterpolant(t)),
										this
									);
								},
								setEffectiveTimeScale: function (t) {
									return (
										(this.timeScale = t),
										(this._effectiveTimeScale = this.paused ? 0 : t),
										this.stopWarping()
									);
								},
								getEffectiveTimeScale: function () {
									return this._effectiveTimeScale;
								},
								setDuration: function (t) {
									return (
										(this.timeScale = this._clip.duration / t),
										this.stopWarping()
									);
								},
								syncWith: function (t) {
									return (
										(this.time = t.time),
										(this.timeScale = t.timeScale),
										this.stopWarping()
									);
								},
								halt: function (t) {
									return this.warp(this._effectiveTimeScale, 0, t);
								},
								warp: function (t, e, n) {
									const i = this._mixer,
										r = i.time,
										o = this.timeScale;
									let a = this._timeScaleInterpolant;
									null === a &&
										((a = i._lendControlInterpolant()),
										(this._timeScaleInterpolant = a));
									const s = a.parameterPositions,
										c = a.sampleValues;
									return (
										(s[0] = r),
										(s[1] = r + n),
										(c[0] = t / o),
										(c[1] = e / o),
										this
									);
								},
								stopWarping: function () {
									let t = this._timeScaleInterpolant;
									return (
										null !== t &&
											((this._timeScaleInterpolant = null),
											this._mixer._takeBackControlInterpolant(t)),
										this
									);
								},
								getMixer: function () {
									return this._mixer;
								},
								getClip: function () {
									return this._clip;
								},
								getRoot: function () {
									return this._localRoot || this._mixer._root;
								},
								_update: function (t, e, n, i) {
									if (!this.enabled) return void this._updateWeight(t);
									const r = this._startTime;
									if (null !== r) {
										const i = (t - r) * n;
										if (i < 0 || 0 === n) return;
										(this._startTime = null), (e = n * i);
									}
									e *= this._updateTimeScale(t);
									const o = this._updateTime(e),
										a = this._updateWeight(t);
									if (a > 0) {
										const t = this._interpolants,
											e = this._propertyBindings;
										switch (this.blendMode) {
											case 2501:
												for (let n = 0, i = t.length; n !== i; ++n)
													t[n].evaluate(o), e[n].accumulateAdditive(a);
												break;
											case lr:
											default:
												for (let n = 0, r = t.length; n !== r; ++n)
													t[n].evaluate(o), e[n].accumulate(i, a);
										}
									}
								},
								_updateWeight: function (t) {
									let e = 0;
									if (this.enabled) {
										e = this.weight;
										const n = this._weightInterpolant;
										if (null !== n) {
											const i = n.evaluate(t)[0];
											(e *= i),
												t > n.parameterPositions[1] &&
													(this.stopFading(), 0 === i && (this.enabled = !1));
										}
									}
									return (this._effectiveWeight = e), e;
								},
								_updateTimeScale: function (t) {
									let e = 0;
									if (!this.paused) {
										e = this.timeScale;
										const n = this._timeScaleInterpolant;
										null !== n &&
											((e *= n.evaluate(t)[0]),
											t > n.parameterPositions[1] &&
												(this.stopWarping(),
												0 === e ? (this.paused = !0) : (this.timeScale = e)));
									}
									return (this._effectiveTimeScale = e), e;
								},
								_updateTime: function (t) {
									const e = this._clip.duration,
										n = this.loop;
									let i = this.time + t,
										r = this._loopCount;
									const o = 2202 === n;
									if (0 === t)
										return -1 === r ? i : o && 1 == (1 & r) ? e - i : i;
									if (2200 === n) {
										-1 === r &&
											((this._loopCount = 0), this._setEndings(!0, !0, !1));
										t: {
											if (i >= e) i = e;
											else {
												if (!(i < 0)) {
													this.time = i;
													break t;
												}
												i = 0;
											}
											this.clampWhenFinished
												? (this.paused = !0)
												: (this.enabled = !1),
												(this.time = i),
												this._mixer.dispatchEvent({
													type: "finished",
													action: this,
													direction: t < 0 ? -1 : 1,
												});
										}
									} else {
										if (
											(-1 === r &&
												(t >= 0
													? ((r = 0),
													  this._setEndings(!0, 0 === this.repetitions, o))
													: this._setEndings(0 === this.repetitions, !0, o)),
											i >= e || i < 0)
										) {
											const n = Math.floor(i / e);
											(i -= e * n), (r += Math.abs(n));
											const a = this.repetitions - r;
											if (a <= 0)
												this.clampWhenFinished
													? (this.paused = !0)
													: (this.enabled = !1),
													(i = t > 0 ? e : 0),
													(this.time = i),
													this._mixer.dispatchEvent({
														type: "finished",
														action: this,
														direction: t > 0 ? 1 : -1,
													});
											else {
												if (1 === a) {
													const e = t < 0;
													this._setEndings(e, !e, o);
												} else this._setEndings(!1, !1, o);
												(this._loopCount = r),
													(this.time = i),
													this._mixer.dispatchEvent({
														type: "loop",
														action: this,
														loopDelta: n,
													});
											}
										} else this.time = i;
										if (o && 1 == (1 & r)) return e - i;
									}
									return i;
								},
								_setEndings: function (t, e, n) {
									const i = this._interpolantSettings;
									n
										? ((i.endingStart = sr), (i.endingEnd = sr))
										: ((i.endingStart = t
												? this.zeroSlopeAtStart
													? sr
													: ar
												: cr),
										  (i.endingEnd = e ? (this.zeroSlopeAtEnd ? sr : ar) : cr));
								},
								_scheduleFading: function (t, e, n) {
									const i = this._mixer,
										r = i.time;
									let o = this._weightInterpolant;
									null === o &&
										((o = i._lendControlInterpolant()),
										(this._weightInterpolant = o));
									const a = o.parameterPositions,
										s = o.sampleValues;
									return (
										(a[0] = r), (s[0] = e), (a[1] = r + t), (s[1] = n), this
									);
								},
							}),
							($d.prototype = Object.assign(Object.create(Sr.prototype), {
								constructor: $d,
								_bindAction: function (t, e) {
									const n = t._localRoot || this._root,
										i = t._clip.tracks,
										r = i.length,
										o = t._propertyBindings,
										a = t._interpolants,
										s = n.uuid,
										c = this._bindingsByRootAndName;
									let l = c[s];
									void 0 === l && ((l = {}), (c[s] = l));
									for (let t = 0; t !== r; ++t) {
										const r = i[t],
											c = r.name;
										let h = l[c];
										if (void 0 !== h) o[t] = h;
										else {
											if (((h = o[t]), void 0 !== h)) {
												null === h._cacheIndex &&
													(++h.referenceCount,
													this._addInactiveBinding(h, s, c));
												continue;
											}
											const i = e && e._propertyBindings[t].binding.parsedPath;
											(h = new Nd(
												Yd.create(n, c, i),
												r.ValueTypeName,
												r.getValueSize()
											)),
												++h.referenceCount,
												this._addInactiveBinding(h, s, c),
												(o[t] = h);
										}
										a[t].resultBuffer = h.buffer;
									}
								},
								_activateAction: function (t) {
									if (!this._isActiveAction(t)) {
										if (null === t._cacheIndex) {
											const e = (t._localRoot || this._root).uuid,
												n = t._clip.uuid,
												i = this._actionsByClip[n];
											this._bindAction(t, i && i.knownActions[0]),
												this._addInactiveAction(t, n, e);
										}
										const e = t._propertyBindings;
										for (let t = 0, n = e.length; t !== n; ++t) {
											const n = e[t];
											0 == n.useCount++ &&
												(this._lendBinding(n), n.saveOriginalState());
										}
										this._lendAction(t);
									}
								},
								_deactivateAction: function (t) {
									if (this._isActiveAction(t)) {
										const e = t._propertyBindings;
										for (let t = 0, n = e.length; t !== n; ++t) {
											const n = e[t];
											0 == --n.useCount &&
												(n.restoreOriginalState(), this._takeBackBinding(n));
										}
										this._takeBackAction(t);
									}
								},
								_initMemoryManager: function () {
									(this._actions = []),
										(this._nActiveActions = 0),
										(this._actionsByClip = {}),
										(this._bindings = []),
										(this._nActiveBindings = 0),
										(this._bindingsByRootAndName = {}),
										(this._controlInterpolants = []),
										(this._nActiveControlInterpolants = 0);
									const t = this;
									this.stats = {
										actions: {
											get total() {
												return t._actions.length;
											},
											get inUse() {
												return t._nActiveActions;
											},
										},
										bindings: {
											get total() {
												return t._bindings.length;
											},
											get inUse() {
												return t._nActiveBindings;
											},
										},
										controlInterpolants: {
											get total() {
												return t._controlInterpolants.length;
											},
											get inUse() {
												return t._nActiveControlInterpolants;
											},
										},
									};
								},
								_isActiveAction: function (t) {
									const e = t._cacheIndex;
									return null !== e && e < this._nActiveActions;
								},
								_addInactiveAction: function (t, e, n) {
									const i = this._actions,
										r = this._actionsByClip;
									let o = r[e];
									if (void 0 === o)
										(o = { knownActions: [t], actionByRoot: {} }),
											(t._byClipCacheIndex = 0),
											(r[e] = o);
									else {
										const e = o.knownActions;
										(t._byClipCacheIndex = e.length), e.push(t);
									}
									(t._cacheIndex = i.length),
										i.push(t),
										(o.actionByRoot[n] = t);
								},
								_removeInactiveAction: function (t) {
									const e = this._actions,
										n = e[e.length - 1],
										i = t._cacheIndex;
									(n._cacheIndex = i),
										(e[i] = n),
										e.pop(),
										(t._cacheIndex = null);
									const r = t._clip.uuid,
										o = this._actionsByClip,
										a = o[r],
										s = a.knownActions,
										c = s[s.length - 1],
										l = t._byClipCacheIndex;
									(c._byClipCacheIndex = l),
										(s[l] = c),
										s.pop(),
										(t._byClipCacheIndex = null),
										delete a.actionByRoot[(t._localRoot || this._root).uuid],
										0 === s.length && delete o[r],
										this._removeInactiveBindingsForAction(t);
								},
								_removeInactiveBindingsForAction: function (t) {
									const e = t._propertyBindings;
									for (let t = 0, n = e.length; t !== n; ++t) {
										const n = e[t];
										0 == --n.referenceCount && this._removeInactiveBinding(n);
									}
								},
								_lendAction: function (t) {
									const e = this._actions,
										n = t._cacheIndex,
										i = this._nActiveActions++,
										r = e[i];
									(t._cacheIndex = i),
										(e[i] = t),
										(r._cacheIndex = n),
										(e[n] = r);
								},
								_takeBackAction: function (t) {
									const e = this._actions,
										n = t._cacheIndex,
										i = --this._nActiveActions,
										r = e[i];
									(t._cacheIndex = i),
										(e[i] = t),
										(r._cacheIndex = n),
										(e[n] = r);
								},
								_addInactiveBinding: function (t, e, n) {
									const i = this._bindingsByRootAndName,
										r = this._bindings;
									let o = i[e];
									void 0 === o && ((o = {}), (i[e] = o)),
										(o[n] = t),
										(t._cacheIndex = r.length),
										r.push(t);
								},
								_removeInactiveBinding: function (t) {
									const e = this._bindings,
										n = t.binding,
										i = n.rootNode.uuid,
										r = n.path,
										o = this._bindingsByRootAndName,
										a = o[i],
										s = e[e.length - 1],
										c = t._cacheIndex;
									(s._cacheIndex = c),
										(e[c] = s),
										e.pop(),
										delete a[r],
										0 === Object.keys(a).length && delete o[i];
								},
								_lendBinding: function (t) {
									const e = this._bindings,
										n = t._cacheIndex,
										i = this._nActiveBindings++,
										r = e[i];
									(t._cacheIndex = i),
										(e[i] = t),
										(r._cacheIndex = n),
										(e[n] = r);
								},
								_takeBackBinding: function (t) {
									const e = this._bindings,
										n = t._cacheIndex,
										i = --this._nActiveBindings,
										r = e[i];
									(t._cacheIndex = i),
										(e[i] = t),
										(r._cacheIndex = n),
										(e[n] = r);
								},
								_lendControlInterpolant: function () {
									const t = this._controlInterpolants,
										e = this._nActiveControlInterpolants++;
									let n = t[e];
									return (
										void 0 === n &&
											((n = new Xp(
												new Float32Array(2),
												new Float32Array(2),
												1,
												this._controlInterpolantsResultBuffer
											)),
											(n.__cacheIndex = e),
											(t[e] = n)),
										n
									);
								},
								_takeBackControlInterpolant: function (t) {
									const e = this._controlInterpolants,
										n = t.__cacheIndex,
										i = --this._nActiveControlInterpolants,
										r = e[i];
									(t.__cacheIndex = i),
										(e[i] = t),
										(r.__cacheIndex = n),
										(e[n] = r);
								},
								_controlInterpolantsResultBuffer: new Float32Array(1),
								clipAction: function (t, e, n) {
									const i = e || this._root,
										r = i.uuid;
									let o = "string" == typeof t ? cu.findByName(i, t) : t;
									const a = null !== o ? o.uuid : t;
									let s = this._actionsByClip[a],
										c = null;
									if (
										(void 0 === n && (n = null !== o ? o.blendMode : lr),
										void 0 !== s)
									) {
										const t = s.actionByRoot[r];
										if (void 0 !== t && t.blendMode === n) return t;
										(c = s.knownActions[0]), null === o && (o = c._clip);
									}
									if (null === o) return null;
									const l = new Xd(this, o, e, n);
									return (
										this._bindAction(l, c), this._addInactiveAction(l, a, r), l
									);
								},
								existingAction: function (t, e) {
									const n = e || this._root,
										i = n.uuid,
										r = "string" == typeof t ? cu.findByName(n, t) : t,
										o = r ? r.uuid : t,
										a = this._actionsByClip[o];
									return (void 0 !== a && a.actionByRoot[i]) || null;
								},
								stopAllAction: function () {
									const t = this._actions;
									for (let e = this._nActiveActions - 1; e >= 0; --e)
										t[e].stop();
									return this;
								},
								update: function (t) {
									t *= this.timeScale;
									const e = this._actions,
										n = this._nActiveActions,
										i = (this.time += t),
										r = Math.sign(t),
										o = (this._accuIndex ^= 1);
									for (let a = 0; a !== n; ++a) e[a]._update(i, t, r, o);
									const a = this._bindings,
										s = this._nActiveBindings;
									for (let t = 0; t !== s; ++t) a[t].apply(o);
									return this;
								},
								setTime: function (t) {
									this.time = 0;
									for (let t = 0; t < this._actions.length; t++)
										this._actions[t].time = 0;
									return this.update(t);
								},
								getRoot: function () {
									return this._root;
								},
								uncacheClip: function (t) {
									const e = this._actions,
										n = t.uuid,
										i = this._actionsByClip,
										r = i[n];
									if (void 0 !== r) {
										const t = r.knownActions;
										for (let n = 0, i = t.length; n !== i; ++n) {
											const i = t[n];
											this._deactivateAction(i);
											const r = i._cacheIndex,
												o = e[e.length - 1];
											(i._cacheIndex = null),
												(i._byClipCacheIndex = null),
												(o._cacheIndex = r),
												(e[r] = o),
												e.pop(),
												this._removeInactiveBindingsForAction(i);
										}
										delete i[n];
									}
								},
								uncacheRoot: function (t) {
									const e = t.uuid,
										n = this._actionsByClip;
									for (const t in n) {
										const i = n[t].actionByRoot[e];
										void 0 !== i &&
											(this._deactivateAction(i),
											this._removeInactiveAction(i));
									}
									const i = this._bindingsByRootAndName[e];
									if (void 0 !== i)
										for (const t in i) {
											const e = i[t];
											e.restoreOriginalState(), this._removeInactiveBinding(e);
										}
								},
								uncacheAction: function (t, e) {
									const n = this.existingAction(t, e);
									null !== n &&
										(this._deactivateAction(n), this._removeInactiveAction(n));
								},
							})),
							(tm.prototype.clone = function () {
								return new tm(
									void 0 === this.value.clone ? this.value : this.value.clone()
								);
							}),
							(em.prototype = Object.assign(Object.create(Il.prototype), {
								constructor: em,
								isInstancedInterleavedBuffer: !0,
								copy: function (t) {
									return (
										Il.prototype.copy.call(this, t),
										(this.meshPerAttribute = t.meshPerAttribute),
										this
									);
								},
								clone: function (t) {
									const e = Il.prototype.clone.call(this, t);
									return (e.meshPerAttribute = this.meshPerAttribute), e;
								},
								toJSON: function (t) {
									const e = Il.prototype.toJSON.call(this, t);
									return (
										(e.isInstancedInterleavedBuffer = !0),
										(e.meshPerAttribute = this.meshPerAttribute),
										e
									);
								},
							})),
							Object.assign(nm.prototype, {
								set: function (t, e) {
									this.ray.set(t, e);
								},
								setFromCamera: function (t, e) {
									e && e.isPerspectiveCamera
										? (this.ray.origin.setFromMatrixPosition(e.matrixWorld),
										  this.ray.direction
												.set(t.x, t.y, 0.5)
												.unproject(e)
												.sub(this.ray.origin)
												.normalize(),
										  (this.camera = e))
										: e && e.isOrthographicCamera
										? (this.ray.origin
												.set(t.x, t.y, (e.near + e.far) / (e.near - e.far))
												.unproject(e),
										  this.ray.direction
												.set(0, 0, -1)
												.transformDirection(e.matrixWorld),
										  (this.camera = e))
										: console.error(
												"THREE.Raycaster: Unsupported camera type."
										  );
								},
								intersectObject: function (t, e, n) {
									const i = n || [];
									return rm(t, this, i, e), i.sort(im), i;
								},
								intersectObjects: function (t, e, n) {
									const i = n || [];
									if (!1 === Array.isArray(t))
										return (
											console.warn(
												"THREE.Raycaster.intersectObjects: objects is not an Array."
											),
											i
										);
									for (let n = 0, r = t.length; n < r; n++)
										rm(t[n], this, i, e);
									return i.sort(im), i;
								},
							}),
							Object.assign(
								function (t, e, n) {
									return (
										(this.radius = void 0 !== t ? t : 1),
										(this.theta = void 0 !== e ? e : 0),
										(this.y = void 0 !== n ? n : 0),
										this
									);
								}.prototype,
								{
									set: function (t, e, n) {
										return (
											(this.radius = t), (this.theta = e), (this.y = n), this
										);
									},
									clone: function () {
										return new this.constructor().copy(this);
									},
									copy: function (t) {
										return (
											(this.radius = t.radius),
											(this.theta = t.theta),
											(this.y = t.y),
											this
										);
									},
									setFromVector3: function (t) {
										return this.setFromCartesianCoords(t.x, t.y, t.z);
									},
									setFromCartesianCoords: function (t, e, n) {
										return (
											(this.radius = Math.sqrt(t * t + n * n)),
											(this.theta = Math.atan2(t, n)),
											(this.y = e),
											this
										);
									},
								}
							);
						const om = new Rr();
						function am(t, e) {
							(this.min = void 0 !== t ? t : new Rr(1 / 0, 1 / 0)),
								(this.max = void 0 !== e ? e : new Rr(-1 / 0, -1 / 0));
						}
						Object.assign(am.prototype, {
							set: function (t, e) {
								return this.min.copy(t), this.max.copy(e), this;
							},
							setFromPoints: function (t) {
								this.makeEmpty();
								for (let e = 0, n = t.length; e < n; e++)
									this.expandByPoint(t[e]);
								return this;
							},
							setFromCenterAndSize: function (t, e) {
								const n = om.copy(e).multiplyScalar(0.5);
								return this.min.copy(t).sub(n), this.max.copy(t).add(n), this;
							},
							clone: function () {
								return new this.constructor().copy(this);
							},
							copy: function (t) {
								return this.min.copy(t.min), this.max.copy(t.max), this;
							},
							makeEmpty: function () {
								return (
									(this.min.x = this.min.y = 1 / 0),
									(this.max.x = this.max.y = -1 / 0),
									this
								);
							},
							isEmpty: function () {
								return this.max.x < this.min.x || this.max.y < this.min.y;
							},
							getCenter: function (t) {
								return (
									void 0 === t &&
										(console.warn(
											"THREE.Box2: .getCenter() target is now required"
										),
										(t = new Rr())),
									this.isEmpty()
										? t.set(0, 0)
										: t.addVectors(this.min, this.max).multiplyScalar(0.5)
								);
							},
							getSize: function (t) {
								return (
									void 0 === t &&
										(console.warn(
											"THREE.Box2: .getSize() target is now required"
										),
										(t = new Rr())),
									this.isEmpty()
										? t.set(0, 0)
										: t.subVectors(this.max, this.min)
								);
							},
							expandByPoint: function (t) {
								return this.min.min(t), this.max.max(t), this;
							},
							expandByVector: function (t) {
								return this.min.sub(t), this.max.add(t), this;
							},
							expandByScalar: function (t) {
								return this.min.addScalar(-t), this.max.addScalar(t), this;
							},
							containsPoint: function (t) {
								return !(
									t.x < this.min.x ||
									t.x > this.max.x ||
									t.y < this.min.y ||
									t.y > this.max.y
								);
							},
							containsBox: function (t) {
								return (
									this.min.x <= t.min.x &&
									t.max.x <= this.max.x &&
									this.min.y <= t.min.y &&
									t.max.y <= this.max.y
								);
							},
							getParameter: function (t, e) {
								return (
									void 0 === e &&
										(console.warn(
											"THREE.Box2: .getParameter() target is now required"
										),
										(e = new Rr())),
									e.set(
										(t.x - this.min.x) / (this.max.x - this.min.x),
										(t.y - this.min.y) / (this.max.y - this.min.y)
									)
								);
							},
							intersectsBox: function (t) {
								return !(
									t.max.x < this.min.x ||
									t.min.x > this.max.x ||
									t.max.y < this.min.y ||
									t.min.y > this.max.y
								);
							},
							clampPoint: function (t, e) {
								return (
									void 0 === e &&
										(console.warn(
											"THREE.Box2: .clampPoint() target is now required"
										),
										(e = new Rr())),
									e.copy(t).clamp(this.min, this.max)
								);
							},
							distanceToPoint: function (t) {
								return om.copy(t).clamp(this.min, this.max).sub(t).length();
							},
							intersect: function (t) {
								return this.min.max(t.min), this.max.min(t.max), this;
							},
							union: function (t) {
								return this.min.min(t.min), this.max.max(t.max), this;
							},
							translate: function (t) {
								return this.min.add(t), this.max.add(t), this;
							},
							equals: function (t) {
								return t.min.equals(this.min) && t.max.equals(this.max);
							},
						});
						const sm = new zr(),
							cm = new zr();
						function lm(t, e) {
							(this.start = void 0 !== t ? t : new zr()),
								(this.end = void 0 !== e ? e : new zr());
						}
						function hm(t) {
							oo.call(this),
								(this.material = t),
								(this.render = function () {}),
								(this.hasPositions = !1),
								(this.hasNormals = !1),
								(this.hasColors = !1),
								(this.hasUvs = !1),
								(this.positionArray = null),
								(this.normalArray = null),
								(this.colorArray = null),
								(this.uvArray = null),
								(this.count = 0);
						}
						Object.assign(lm.prototype, {
							set: function (t, e) {
								return this.start.copy(t), this.end.copy(e), this;
							},
							clone: function () {
								return new this.constructor().copy(this);
							},
							copy: function (t) {
								return this.start.copy(t.start), this.end.copy(t.end), this;
							},
							getCenter: function (t) {
								return (
									void 0 === t &&
										(console.warn(
											"THREE.Line3: .getCenter() target is now required"
										),
										(t = new zr())),
									t.addVectors(this.start, this.end).multiplyScalar(0.5)
								);
							},
							delta: function (t) {
								return (
									void 0 === t &&
										(console.warn(
											"THREE.Line3: .delta() target is now required"
										),
										(t = new zr())),
									t.subVectors(this.end, this.start)
								);
							},
							distanceSq: function () {
								return this.start.distanceToSquared(this.end);
							},
							distance: function () {
								return this.start.distanceTo(this.end);
							},
							at: function (t, e) {
								return (
									void 0 === e &&
										(console.warn("THREE.Line3: .at() target is now required"),
										(e = new zr())),
									this.delta(e).multiplyScalar(t).add(this.start)
								);
							},
							closestPointToPointParameter: function (t, e) {
								sm.subVectors(t, this.start),
									cm.subVectors(this.end, this.start);
								const n = cm.dot(cm);
								let i = cm.dot(sm) / n;
								return e && (i = qr.clamp(i, 0, 1)), i;
							},
							closestPointToPoint: function (t, e, n) {
								const i = this.closestPointToPointParameter(t, e);
								return (
									void 0 === n &&
										(console.warn(
											"THREE.Line3: .closestPointToPoint() target is now required"
										),
										(n = new zr())),
									this.delta(n).multiplyScalar(i).add(this.start)
								);
							},
							applyMatrix4: function (t) {
								return (
									this.start.applyMatrix4(t), this.end.applyMatrix4(t), this
								);
							},
							equals: function (t) {
								return t.start.equals(this.start) && t.end.equals(this.end);
							},
						}),
							(hm.prototype = Object.create(oo.prototype)),
							(hm.prototype.constructor = hm),
							(hm.prototype.isImmediateRenderObject = !0);
						const pm = new zr();
						function um(t, e) {
							oo.call(this),
								(this.light = t),
								this.light.updateMatrixWorld(),
								(this.matrix = t.matrixWorld),
								(this.matrixAutoUpdate = !1),
								(this.color = e);
							const n = new Ua(),
								i = [
									0, 0, 0, 0, 0, 1, 0, 0, 0, 1, 0, 1, 0, 0, 0, -1, 0, 1, 0, 0,
									0, 0, 1, 1, 0, 0, 0, 0, -1, 1,
								];
							for (let t = 0, e = 1, n = 32; t < n; t++, e++) {
								const r = (t / n) * Math.PI * 2,
									o = (e / n) * Math.PI * 2;
								i.push(
									Math.cos(r),
									Math.sin(r),
									1,
									Math.cos(o),
									Math.sin(o),
									1
								);
							}
							n.setAttribute("position", new fa(i, 3));
							const r = new eh({ fog: !1, toneMapped: !1 });
							(this.cone = new hh(n, r)), this.add(this.cone), this.update();
						}
						(um.prototype = Object.create(oo.prototype)),
							(um.prototype.constructor = um),
							(um.prototype.dispose = function () {
								this.cone.geometry.dispose(), this.cone.material.dispose();
							}),
							(um.prototype.update = function () {
								this.light.updateMatrixWorld();
								const t = this.light.distance ? this.light.distance : 1e3,
									e = t * Math.tan(this.light.angle);
								this.cone.scale.set(e, e, t),
									pm.setFromMatrixPosition(this.light.target.matrixWorld),
									this.cone.lookAt(pm),
									void 0 !== this.color
										? this.cone.material.color.set(this.color)
										: this.cone.material.color.copy(this.light.color);
							});
						const dm = new zr(),
							mm = new jr(),
							fm = new jr();
						function gm(t) {
							const e = [];
							t && t.isBone && e.push(t);
							for (let n = 0; n < t.children.length; n++)
								e.push.apply(e, gm(t.children[n]));
							return e;
						}
						function Sm(t) {
							const e = gm(t),
								n = new Ua(),
								i = [],
								r = [],
								o = new Yo(0, 0, 1),
								a = new Yo(0, 1, 0);
							for (let t = 0; t < e.length; t++) {
								const n = e[t];
								n.parent &&
									n.parent.isBone &&
									(i.push(0, 0, 0),
									i.push(0, 0, 0),
									r.push(o.r, o.g, o.b),
									r.push(a.r, a.g, a.b));
							}
							n.setAttribute("position", new fa(i, 3)),
								n.setAttribute("color", new fa(r, 3));
							const s = new eh({
								vertexColors: !0,
								depthTest: !1,
								depthWrite: !1,
								toneMapped: !1,
								transparent: !0,
							});
							hh.call(this, n, s),
								(this.type = "SkeletonHelper"),
								(this.root = t),
								(this.bones = e),
								(this.matrix = t.matrixWorld),
								(this.matrixAutoUpdate = !1);
						}
						function ym(t, e, n) {
							(this.light = t),
								this.light.updateMatrixWorld(),
								(this.color = n);
							const i = new Mp(e, 4, 2),
								r = new ra({ wireframe: !0, fog: !1, toneMapped: !1 });
							La.call(this, i, r),
								(this.type = "PointLightHelper"),
								(this.matrix = this.light.matrixWorld),
								(this.matrixAutoUpdate = !1),
								this.update();
						}
						(Sm.prototype = Object.create(hh.prototype)),
							(Sm.prototype.constructor = Sm),
							(Sm.prototype.isSkeletonHelper = !0),
							(Sm.prototype.updateMatrixWorld = function (t) {
								const e = this.bones,
									n = this.geometry,
									i = n.getAttribute("position");
								fm.getInverse(this.root.matrixWorld);
								for (let t = 0, n = 0; t < e.length; t++) {
									const r = e[t];
									r.parent &&
										r.parent.isBone &&
										(mm.multiplyMatrices(fm, r.matrixWorld),
										dm.setFromMatrixPosition(mm),
										i.setXYZ(n, dm.x, dm.y, dm.z),
										mm.multiplyMatrices(fm, r.parent.matrixWorld),
										dm.setFromMatrixPosition(mm),
										i.setXYZ(n + 1, dm.x, dm.y, dm.z),
										(n += 2));
								}
								(n.getAttribute("position").needsUpdate = !0),
									oo.prototype.updateMatrixWorld.call(this, t);
							}),
							(ym.prototype = Object.create(La.prototype)),
							(ym.prototype.constructor = ym),
							(ym.prototype.dispose = function () {
								this.geometry.dispose(), this.material.dispose();
							}),
							(ym.prototype.update = function () {
								void 0 !== this.color
									? this.material.color.set(this.color)
									: this.material.color.copy(this.light.color);
							});
						const Vm = new zr(),
							qm = new Yo(),
							Rm = new Yo();
						function Mm(t, e, n) {
							oo.call(this),
								(this.light = t),
								this.light.updateMatrixWorld(),
								(this.matrix = t.matrixWorld),
								(this.matrixAutoUpdate = !1),
								(this.color = n);
							const i = new Kh(e);
							i.rotateY(0.5 * Math.PI),
								(this.material = new ra({
									wireframe: !0,
									fog: !1,
									toneMapped: !1,
								})),
								void 0 === this.color && (this.material.vertexColors = !0);
							const r = i.getAttribute("position"),
								o = new Float32Array(3 * r.count);
							i.setAttribute("color", new sa(o, 3)),
								this.add(new La(i, this.material)),
								this.update();
						}
						function Im(t, e, n, i) {
							(t = t || 10),
								(e = e || 10),
								(n = new Yo(void 0 !== n ? n : 4473924)),
								(i = new Yo(void 0 !== i ? i : 8947848));
							const r = e / 2,
								o = t / e,
								a = t / 2,
								s = [],
								c = [];
							for (let t = 0, l = 0, h = -a; t <= e; t++, h += o) {
								s.push(-a, 0, h, a, 0, h), s.push(h, 0, -a, h, 0, a);
								const e = t === r ? n : i;
								e.toArray(c, l),
									(l += 3),
									e.toArray(c, l),
									(l += 3),
									e.toArray(c, l),
									(l += 3),
									e.toArray(c, l),
									(l += 3);
							}
							const l = new Ua();
							l.setAttribute("position", new fa(s, 3)),
								l.setAttribute("color", new fa(c, 3));
							const h = new eh({ vertexColors: !0, toneMapped: !1 });
							hh.call(this, l, h), (this.type = "GridHelper");
						}
						function vm(t, e, n, i, r, o) {
							(t = t || 10),
								(e = e || 16),
								(n = n || 8),
								(i = i || 64),
								(r = new Yo(void 0 !== r ? r : 4473924)),
								(o = new Yo(void 0 !== o ? o : 8947848));
							const a = [],
								s = [];
							for (let n = 0; n <= e; n++) {
								const i = (n / e) * (2 * Math.PI),
									c = Math.sin(i) * t,
									l = Math.cos(i) * t;
								a.push(0, 0, 0), a.push(c, 0, l);
								const h = 1 & n ? r : o;
								s.push(h.r, h.g, h.b), s.push(h.r, h.g, h.b);
							}
							for (let e = 0; e <= n; e++) {
								const c = 1 & e ? r : o,
									l = t - (t / n) * e;
								for (let t = 0; t < i; t++) {
									let e = (t / i) * (2 * Math.PI),
										n = Math.sin(e) * l,
										r = Math.cos(e) * l;
									a.push(n, 0, r),
										s.push(c.r, c.g, c.b),
										(e = ((t + 1) / i) * (2 * Math.PI)),
										(n = Math.sin(e) * l),
										(r = Math.cos(e) * l),
										a.push(n, 0, r),
										s.push(c.r, c.g, c.b);
								}
							}
							const c = new Ua();
							c.setAttribute("position", new fa(a, 3)),
								c.setAttribute("color", new fa(s, 3));
							const l = new eh({ vertexColors: !0, toneMapped: !1 });
							hh.call(this, c, l), (this.type = "PolarGridHelper");
						}
						(Mm.prototype = Object.create(oo.prototype)),
							(Mm.prototype.constructor = Mm),
							(Mm.prototype.dispose = function () {
								this.children[0].geometry.dispose(),
									this.children[0].material.dispose();
							}),
							(Mm.prototype.update = function () {
								const t = this.children[0];
								if (void 0 !== this.color) this.material.color.set(this.color);
								else {
									const e = t.geometry.getAttribute("color");
									qm.copy(this.light.color), Rm.copy(this.light.groundColor);
									for (let t = 0, n = e.count; t < n; t++) {
										const i = t < n / 2 ? qm : Rm;
										e.setXYZ(t, i.r, i.g, i.b);
									}
									e.needsUpdate = !0;
								}
								t.lookAt(
									Vm.setFromMatrixPosition(this.light.matrixWorld).negate()
								);
							}),
							(Im.prototype = Object.create(hh.prototype)),
							(Im.prototype.constructor = Im),
							(vm.prototype = Object.create(hh.prototype)),
							(vm.prototype.constructor = vm);
						const km = new zr(),
							Um = new zr(),
							wm = new zr();
						function xm(t, e, n) {
							oo.call(this),
								(this.light = t),
								this.light.updateMatrixWorld(),
								(this.matrix = t.matrixWorld),
								(this.matrixAutoUpdate = !1),
								(this.color = n),
								void 0 === e && (e = 1);
							let i = new Ua();
							i.setAttribute(
								"position",
								new fa([-e, e, 0, e, e, 0, e, -e, 0, -e, -e, 0, -e, e, 0], 3)
							);
							const r = new eh({ fog: !1, toneMapped: !1 });
							(this.lightPlane = new sh(i, r)),
								this.add(this.lightPlane),
								(i = new Ua()),
								i.setAttribute("position", new fa([0, 0, 0, 0, 0, 1], 3)),
								(this.targetLine = new sh(i, r)),
								this.add(this.targetLine),
								this.update();
						}
						(xm.prototype = Object.create(oo.prototype)),
							(xm.prototype.constructor = xm),
							(xm.prototype.dispose = function () {
								this.lightPlane.geometry.dispose(),
									this.lightPlane.material.dispose(),
									this.targetLine.geometry.dispose(),
									this.targetLine.material.dispose();
							}),
							(xm.prototype.update = function () {
								km.setFromMatrixPosition(this.light.matrixWorld),
									Um.setFromMatrixPosition(this.light.target.matrixWorld),
									wm.subVectors(Um, km),
									this.lightPlane.lookAt(Um),
									void 0 !== this.color
										? (this.lightPlane.material.color.set(this.color),
										  this.targetLine.material.color.set(this.color))
										: (this.lightPlane.material.color.copy(this.light.color),
										  this.targetLine.material.color.copy(this.light.color)),
									this.targetLine.lookAt(Um),
									(this.targetLine.scale.z = wm.length());
							});
						const Om = new zr(),
							bm = new is();
						function Km(t) {
							const e = new Ua(),
								n = new eh({
									color: 16777215,
									vertexColors: !0,
									toneMapped: !1,
								}),
								i = [],
								r = [],
								o = {},
								a = new Yo(16755200),
								s = new Yo(16711680),
								c = new Yo(43775),
								l = new Yo(16777215),
								h = new Yo(3355443);
							function p(t, e, n) {
								u(t, n), u(e, n);
							}
							function u(t, e) {
								i.push(0, 0, 0),
									r.push(e.r, e.g, e.b),
									void 0 === o[t] && (o[t] = []),
									o[t].push(i.length / 3 - 1);
							}
							p("n1", "n2", a),
								p("n2", "n4", a),
								p("n4", "n3", a),
								p("n3", "n1", a),
								p("f1", "f2", a),
								p("f2", "f4", a),
								p("f4", "f3", a),
								p("f3", "f1", a),
								p("n1", "f1", a),
								p("n2", "f2", a),
								p("n3", "f3", a),
								p("n4", "f4", a),
								p("p", "n1", s),
								p("p", "n2", s),
								p("p", "n3", s),
								p("p", "n4", s),
								p("u1", "u2", c),
								p("u2", "u3", c),
								p("u3", "u1", c),
								p("c", "t", l),
								p("p", "c", h),
								p("cn1", "cn2", h),
								p("cn3", "cn4", h),
								p("cf1", "cf2", h),
								p("cf3", "cf4", h),
								e.setAttribute("position", new fa(i, 3)),
								e.setAttribute("color", new fa(r, 3)),
								hh.call(this, e, n),
								(this.type = "CameraHelper"),
								(this.camera = t),
								this.camera.updateProjectionMatrix &&
									this.camera.updateProjectionMatrix(),
								(this.matrix = t.matrixWorld),
								(this.matrixAutoUpdate = !1),
								(this.pointMap = o),
								this.update();
						}
						function Tm(t, e, n, i, r, o, a) {
							Om.set(r, o, a).unproject(i);
							const s = e[t];
							if (void 0 !== s) {
								const t = n.getAttribute("position");
								for (let e = 0, n = s.length; e < n; e++)
									t.setXYZ(s[e], Om.x, Om.y, Om.z);
							}
						}
						(Km.prototype = Object.create(hh.prototype)),
							(Km.prototype.constructor = Km),
							(Km.prototype.update = function () {
								const t = this.geometry,
									e = this.pointMap;
								bm.projectionMatrixInverse.copy(
									this.camera.projectionMatrixInverse
								),
									Tm("c", e, t, bm, 0, 0, -1),
									Tm("t", e, t, bm, 0, 0, 1),
									Tm("n1", e, t, bm, -1, -1, -1),
									Tm("n2", e, t, bm, 1, -1, -1),
									Tm("n3", e, t, bm, -1, 1, -1),
									Tm("n4", e, t, bm, 1, 1, -1),
									Tm("f1", e, t, bm, -1, -1, 1),
									Tm("f2", e, t, bm, 1, -1, 1),
									Tm("f3", e, t, bm, -1, 1, 1),
									Tm("f4", e, t, bm, 1, 1, 1),
									Tm("u1", e, t, bm, 0.7, 1.1, -1),
									Tm("u2", e, t, bm, -0.7, 1.1, -1),
									Tm("u3", e, t, bm, 0, 2, -1),
									Tm("cf1", e, t, bm, -1, 0, 1),
									Tm("cf2", e, t, bm, 1, 0, 1),
									Tm("cf3", e, t, bm, 0, -1, 1),
									Tm("cf4", e, t, bm, 0, 1, 1),
									Tm("cn1", e, t, bm, -1, 0, -1),
									Tm("cn2", e, t, bm, 1, 0, -1),
									Tm("cn3", e, t, bm, 0, -1, -1),
									Tm("cn4", e, t, bm, 0, 1, -1),
									(t.getAttribute("position").needsUpdate = !0);
							});
						const zm = new Ro();
						function Wm(t, e) {
							(this.object = t), void 0 === e && (e = 16776960);
							const n = new Uint16Array([
									0, 1, 1, 2, 2, 3, 3, 0, 4, 5, 5, 6, 6, 7, 7, 4, 0, 4, 1, 5, 2,
									6, 3, 7,
								]),
								i = new Float32Array(24),
								r = new Ua();
							r.setIndex(new sa(n, 1)),
								r.setAttribute("position", new sa(i, 3)),
								hh.call(this, r, new eh({ color: e, toneMapped: !1 })),
								(this.type = "BoxHelper"),
								(this.matrixAutoUpdate = !1),
								this.update();
						}
						function Em(t, e) {
							(this.type = "Box3Helper"),
								(this.box = t),
								void 0 === e && (e = 16776960);
							const n = new Uint16Array([
									0, 1, 1, 2, 2, 3, 3, 0, 4, 5, 5, 6, 6, 7, 7, 4, 0, 4, 1, 5, 2,
									6, 3, 7,
								]),
								i = new Ua();
							i.setIndex(new sa(n, 1)),
								i.setAttribute(
									"position",
									new fa(
										[
											1, 1, 1, -1, 1, 1, -1, -1, 1, 1, -1, 1, 1, 1, -1, -1, 1,
											-1, -1, -1, -1, 1, -1, -1,
										],
										3
									)
								),
								hh.call(this, i, new eh({ color: e, toneMapped: !1 })),
								(this.type = "Box3Helper"),
								this.geometry.computeBoundingSphere();
						}
						function Cm(t, e, n) {
							(this.plane = t), (this.size = void 0 === e ? 1 : e);
							const i = void 0 !== n ? n : 16776960,
								r = new Ua();
							r.setAttribute(
								"position",
								new fa(
									[
										1, -1, 1, -1, 1, 1, -1, -1, 1, 1, 1, 1, -1, 1, 1, -1, -1, 1,
										1, -1, 1, 1, 1, 1, 0, 0, 1, 0, 0, 0,
									],
									3
								)
							),
								r.computeBoundingSphere(),
								sh.call(this, r, new eh({ color: i, toneMapped: !1 })),
								(this.type = "PlaneHelper");
							const o = new Ua();
							o.setAttribute(
								"position",
								new fa(
									[1, 1, 1, -1, 1, 1, -1, -1, 1, 1, 1, 1, -1, -1, 1, 1, -1, 1],
									3
								)
							),
								o.computeBoundingSphere(),
								this.add(
									new La(
										o,
										new ra({
											color: i,
											opacity: 0.2,
											transparent: !0,
											depthWrite: !1,
											toneMapped: !1,
										})
									)
								);
						}
						(Wm.prototype = Object.create(hh.prototype)),
							(Wm.prototype.constructor = Wm),
							(Wm.prototype.update = function (t) {
								if (
									(void 0 !== t &&
										console.warn(
											"THREE.BoxHelper: .update() has no longer arguments."
										),
									void 0 !== this.object && zm.setFromObject(this.object),
									zm.isEmpty())
								)
									return;
								const e = zm.min,
									n = zm.max,
									i = this.geometry.attributes.position,
									r = i.array;
								(r[0] = n.x),
									(r[1] = n.y),
									(r[2] = n.z),
									(r[3] = e.x),
									(r[4] = n.y),
									(r[5] = n.z),
									(r[6] = e.x),
									(r[7] = e.y),
									(r[8] = n.z),
									(r[9] = n.x),
									(r[10] = e.y),
									(r[11] = n.z),
									(r[12] = n.x),
									(r[13] = n.y),
									(r[14] = e.z),
									(r[15] = e.x),
									(r[16] = n.y),
									(r[17] = e.z),
									(r[18] = e.x),
									(r[19] = e.y),
									(r[20] = e.z),
									(r[21] = n.x),
									(r[22] = e.y),
									(r[23] = e.z),
									(i.needsUpdate = !0),
									this.geometry.computeBoundingSphere();
							}),
							(Wm.prototype.setFromObject = function (t) {
								return (this.object = t), this.update(), this;
							}),
							(Wm.prototype.copy = function (t) {
								return (
									hh.prototype.copy.call(this, t),
									(this.object = t.object),
									this
								);
							}),
							(Em.prototype = Object.create(hh.prototype)),
							(Em.prototype.constructor = Em),
							(Em.prototype.updateMatrixWorld = function (t) {
								const e = this.box;
								e.isEmpty() ||
									(e.getCenter(this.position),
									e.getSize(this.scale),
									this.scale.multiplyScalar(0.5),
									oo.prototype.updateMatrixWorld.call(this, t));
							}),
							(Cm.prototype = Object.create(sh.prototype)),
							(Cm.prototype.constructor = Cm),
							(Cm.prototype.updateMatrixWorld = function (t) {
								let e = -this.plane.constant;
								Math.abs(e) < 1e-8 && (e = 1e-8),
									this.scale.set(0.5 * this.size, 0.5 * this.size, e),
									(this.children[0].material.side = e < 0 ? 1 : 0),
									this.lookAt(this.plane.normal),
									oo.prototype.updateMatrixWorld.call(this, t);
							});
						const Fm = new zr();
						let Zm, Hm;
						function Nm(t, e, n, i, r, o) {
							oo.call(this),
								(this.type = "ArrowHelper"),
								void 0 === t && (t = new zr(0, 0, 1)),
								void 0 === e && (e = new zr(0, 0, 0)),
								void 0 === n && (n = 1),
								void 0 === i && (i = 16776960),
								void 0 === r && (r = 0.2 * n),
								void 0 === o && (o = 0.2 * r),
								void 0 === Zm &&
									((Zm = new Ua()),
									Zm.setAttribute("position", new fa([0, 0, 0, 0, 1, 0], 3)),
									(Hm = new Tp(0, 0.5, 1, 5, 1)),
									Hm.translate(0, -0.5, 0)),
								this.position.copy(e),
								(this.line = new sh(Zm, new eh({ color: i, toneMapped: !1 }))),
								(this.line.matrixAutoUpdate = !1),
								this.add(this.line),
								(this.cone = new La(Hm, new ra({ color: i, toneMapped: !1 }))),
								(this.cone.matrixAutoUpdate = !1),
								this.add(this.cone),
								this.setDirection(t),
								this.setLength(n, r, o);
						}
						function jm(t) {
							const e = [
									0,
									0,
									0,
									(t = t || 1),
									0,
									0,
									0,
									0,
									0,
									0,
									t,
									0,
									0,
									0,
									0,
									0,
									0,
									t,
								],
								n = new Ua();
							n.setAttribute("position", new fa(e, 3)),
								n.setAttribute(
									"color",
									new fa(
										[
											1, 0, 0, 1, 0.6, 0, 0, 1, 0, 0.6, 1, 0, 0, 0, 1, 0, 0.6,
											1,
										],
										3
									)
								);
							const i = new eh({ vertexColors: !0, toneMapped: !1 });
							hh.call(this, n, i), (this.type = "AxesHelper");
						}
						(Nm.prototype = Object.create(oo.prototype)),
							(Nm.prototype.constructor = Nm),
							(Nm.prototype.setDirection = function (t) {
								if (t.y > 0.99999) this.quaternion.set(0, 0, 0, 1);
								else if (t.y < -0.99999) this.quaternion.set(1, 0, 0, 0);
								else {
									Fm.set(t.z, 0, -t.x).normalize();
									const e = Math.acos(t.y);
									this.quaternion.setFromAxisAngle(Fm, e);
								}
							}),
							(Nm.prototype.setLength = function (t, e, n) {
								void 0 === e && (e = 0.2 * t),
									void 0 === n && (n = 0.2 * e),
									this.line.scale.set(1, Math.max(1e-4, t - e), 1),
									this.line.updateMatrix(),
									this.cone.scale.set(n, e, n),
									(this.cone.position.y = t),
									this.cone.updateMatrix();
							}),
							(Nm.prototype.setColor = function (t) {
								this.line.material.color.set(t),
									this.cone.material.color.set(t);
							}),
							(Nm.prototype.copy = function (t) {
								return (
									oo.prototype.copy.call(this, t, !1),
									this.line.copy(t.line),
									this.cone.copy(t.cone),
									this
								);
							}),
							(jm.prototype = Object.create(hh.prototype)),
							(jm.prototype.constructor = jm);
						const Dm = Math.pow(2, 8),
							Am = [0.125, 0.215, 0.35, 0.446, 0.526, 0.582],
							Lm = 5 + Am.length,
							Bm = {
								[hr]: 0,
								[pr]: 1,
								[dr]: 2,
								3004: 3,
								3005: 4,
								3006: 5,
								[ur]: 6,
							},
							Gm = new Xu(),
							{
								_lodPlanes: Qm,
								_sizeLods: _m,
								_sigmas: Pm,
							} = (function () {
								const t = [],
									e = [],
									n = [];
								let i = 8;
								for (let r = 0; r < Lm; r++) {
									const o = Math.pow(2, i);
									e.push(o);
									let a = 1 / o;
									r > 4 ? (a = Am[r - 8 + 4 - 1]) : 0 == r && (a = 0),
										n.push(a);
									const s = 1 / (o - 1),
										c = -s / 2,
										l = 1 + s / 2,
										h = [c, c, l, c, l, l, c, c, l, l, c, l],
										p = 6,
										u = 6,
										d = 3,
										m = 2,
										f = 1,
										g = new Float32Array(d * u * p),
										S = new Float32Array(m * u * p),
										y = new Float32Array(f * u * p);
									for (let t = 0; t < p; t++) {
										const e = ((t % 3) * 2) / 3 - 1,
											n = t > 2 ? 0 : -1,
											i = [
												e,
												n,
												0,
												e + 2 / 3,
												n,
												0,
												e + 2 / 3,
												n + 1,
												0,
												e,
												n,
												0,
												e + 2 / 3,
												n + 1,
												0,
												e,
												n + 1,
												0,
											];
										g.set(i, d * u * t), S.set(h, m * u * t);
										const r = [t, t, t, t, t, t];
										y.set(r, f * u * t);
									}
									const V = new Ua();
									V.setAttribute("position", new sa(g, d)),
										V.setAttribute("uv", new sa(S, m)),
										V.setAttribute("faceIndex", new sa(y, f)),
										t.push(V),
										i > 4 && i--;
								}
								return { _lodPlanes: t, _sizeLods: e, _sigmas: n };
							})();
						let Jm = null;
						const Ym = (1 + Math.sqrt(5)) / 2,
							Xm = 1 / Ym,
							$m = [
								new zr(1, 1, 1),
								new zr(-1, 1, 1),
								new zr(1, 1, -1),
								new zr(-1, 1, -1),
								new zr(0, Ym, Xm),
								new zr(0, Ym, -Xm),
								new zr(Xm, 0, Ym),
								new zr(-Xm, 0, Ym),
								new zr(Ym, Xm, 0),
								new zr(-Ym, Xm, 0),
							];
						function tf(t) {
							(this._renderer = t),
								(this._pingPongRenderTarget = null),
								(this._blurMaterial = new Hp({
									name: "SphericalGaussianBlur",
									defines: { n: 20 },
									uniforms: {
										envMap: { value: null },
										samples: { value: 1 },
										weights: { value: new Float32Array(20) },
										latitudinal: { value: !1 },
										dTheta: { value: 0 },
										mipInt: { value: 0 },
										poleAxis: { value: new zr(0, 1, 0) },
										inputEncoding: { value: Bm[3e3] },
										outputEncoding: { value: Bm[3e3] },
									},
									vertexShader:
										"\n\n\t\tprecision mediump float;\n\t\tprecision mediump int;\n\n\t\tattribute vec3 position;\n\t\tattribute vec2 uv;\n\t\tattribute float faceIndex;\n\n\t\tvarying vec3 vOutputDirection;\n\n\t\t// RH coordinate system; PMREM face-indexing convention\n\t\tvec3 getDirection( vec2 uv, float face ) {\n\n\t\t\tuv = 2.0 * uv - 1.0;\n\n\t\t\tvec3 direction = vec3( uv, 1.0 );\n\n\t\t\tif ( face == 0.0 ) {\n\n\t\t\t\tdirection = direction.zyx; // ( 1, v, u ) pos x\n\n\t\t\t} else if ( face == 1.0 ) {\n\n\t\t\t\tdirection = direction.xzy;\n\t\t\t\tdirection.xz *= -1.0; // ( -u, 1, -v ) pos y\n\n\t\t\t} else if ( face == 2.0 ) {\n\n\t\t\t\tdirection.x *= -1.0; // ( -u, v, 1 ) pos z\n\n\t\t\t} else if ( face == 3.0 ) {\n\n\t\t\t\tdirection = direction.zyx;\n\t\t\t\tdirection.xz *= -1.0; // ( -1, v, -u ) neg x\n\n\t\t\t} else if ( face == 4.0 ) {\n\n\t\t\t\tdirection = direction.xzy;\n\t\t\t\tdirection.xy *= -1.0; // ( -u, -1, v ) neg y\n\n\t\t\t} else if ( face == 5.0 ) {\n\n\t\t\t\tdirection.z *= -1.0; // ( u, v, -1 ) neg z\n\n\t\t\t}\n\n\t\t\treturn direction;\n\n\t\t}\n\n\t\tvoid main() {\n\n\t\t\tvOutputDirection = getDirection( uv, faceIndex );\n\t\t\tgl_Position = vec4( position, 1.0 );\n\n\t\t}\n\t",
									fragmentShader:
										"\n\n\t\t\tprecision mediump float;\n\t\t\tprecision mediump int;\n\n\t\t\tvarying vec3 vOutputDirection;\n\n\t\t\tuniform sampler2D envMap;\n\t\t\tuniform int samples;\n\t\t\tuniform float weights[ n ];\n\t\t\tuniform bool latitudinal;\n\t\t\tuniform float dTheta;\n\t\t\tuniform float mipInt;\n\t\t\tuniform vec3 poleAxis;\n\n\t\t\t\n\n\t\tuniform int inputEncoding;\n\t\tuniform int outputEncoding;\n\n\t\t#include <encodings_pars_fragment>\n\n\t\tvec4 inputTexelToLinear( vec4 value ) {\n\n\t\t\tif ( inputEncoding == 0 ) {\n\n\t\t\t\treturn value;\n\n\t\t\t} else if ( inputEncoding == 1 ) {\n\n\t\t\t\treturn sRGBToLinear( value );\n\n\t\t\t} else if ( inputEncoding == 2 ) {\n\n\t\t\t\treturn RGBEToLinear( value );\n\n\t\t\t} else if ( inputEncoding == 3 ) {\n\n\t\t\t\treturn RGBMToLinear( value, 7.0 );\n\n\t\t\t} else if ( inputEncoding == 4 ) {\n\n\t\t\t\treturn RGBMToLinear( value, 16.0 );\n\n\t\t\t} else if ( inputEncoding == 5 ) {\n\n\t\t\t\treturn RGBDToLinear( value, 256.0 );\n\n\t\t\t} else {\n\n\t\t\t\treturn GammaToLinear( value, 2.2 );\n\n\t\t\t}\n\n\t\t}\n\n\t\tvec4 linearToOutputTexel( vec4 value ) {\n\n\t\t\tif ( outputEncoding == 0 ) {\n\n\t\t\t\treturn value;\n\n\t\t\t} else if ( outputEncoding == 1 ) {\n\n\t\t\t\treturn LinearTosRGB( value );\n\n\t\t\t} else if ( outputEncoding == 2 ) {\n\n\t\t\t\treturn LinearToRGBE( value );\n\n\t\t\t} else if ( outputEncoding == 3 ) {\n\n\t\t\t\treturn LinearToRGBM( value, 7.0 );\n\n\t\t\t} else if ( outputEncoding == 4 ) {\n\n\t\t\t\treturn LinearToRGBM( value, 16.0 );\n\n\t\t\t} else if ( outputEncoding == 5 ) {\n\n\t\t\t\treturn LinearToRGBD( value, 256.0 );\n\n\t\t\t} else {\n\n\t\t\t\treturn LinearToGamma( value, 2.2 );\n\n\t\t\t}\n\n\t\t}\n\n\t\tvec4 envMapTexelToLinear( vec4 color ) {\n\n\t\t\treturn inputTexelToLinear( color );\n\n\t\t}\n\t\n\n\t\t\t#define ENVMAP_TYPE_CUBE_UV\n\t\t\t#include <cube_uv_reflection_fragment>\n\n\t\t\tvec3 getSample( float theta, vec3 axis ) {\n\n\t\t\t\tfloat cosTheta = cos( theta );\n\t\t\t\t// Rodrigues' axis-angle rotation\n\t\t\t\tvec3 sampleDirection = vOutputDirection * cosTheta\n\t\t\t\t\t+ cross( axis, vOutputDirection ) * sin( theta )\n\t\t\t\t\t+ axis * dot( axis, vOutputDirection ) * ( 1.0 - cosTheta );\n\n\t\t\t\treturn bilinearCubeUV( envMap, sampleDirection, mipInt );\n\n\t\t\t}\n\n\t\t\tvoid main() {\n\n\t\t\t\tvec3 axis = latitudinal ? poleAxis : cross( poleAxis, vOutputDirection );\n\n\t\t\t\tif ( all( equal( axis, vec3( 0.0 ) ) ) ) {\n\n\t\t\t\t\taxis = vec3( vOutputDirection.z, 0.0, - vOutputDirection.x );\n\n\t\t\t\t}\n\n\t\t\t\taxis = normalize( axis );\n\n\t\t\t\tgl_FragColor = vec4( 0.0, 0.0, 0.0, 1.0 );\n\t\t\t\tgl_FragColor.rgb += weights[ 0 ] * getSample( 0.0, axis );\n\n\t\t\t\tfor ( int i = 1; i < n; i++ ) {\n\n\t\t\t\t\tif ( i >= samples ) {\n\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t}\n\n\t\t\t\t\tfloat theta = dTheta * float( i );\n\t\t\t\t\tgl_FragColor.rgb += weights[ i ] * getSample( -1.0 * theta, axis );\n\t\t\t\t\tgl_FragColor.rgb += weights[ i ] * getSample( theta, axis );\n\n\t\t\t\t}\n\n\t\t\t\tgl_FragColor = linearToOutputTexel( gl_FragColor );\n\n\t\t\t}\n\t\t",
									blending: 0,
									depthTest: !1,
									depthWrite: !1,
								})),
								(this._equirectShader = null),
								(this._cubemapShader = null),
								this._compileMaterial(this._blurMaterial);
						}
						function ef(t) {
							return (
								void 0 !== t &&
								t.type === Qi &&
								(t.encoding === hr || t.encoding === pr || t.encoding === ur)
							);
						}
						function nf(t) {
							const e = new xr(3 * Dm, 3 * Dm, t);
							return (
								(e.texture.mapping = Fi),
								(e.texture.name = "PMREM.cubeUv"),
								(e.scissorTest = !0),
								e
							);
						}
						function rf(t, e, n, i, r) {
							t.viewport.set(e, n, i, r), t.scissor.set(e, n, i, r);
						}
						function of() {
							return new Hp({
								name: "EquirectangularToCubeUV",
								uniforms: {
									envMap: { value: null },
									texelSize: { value: new Rr(1, 1) },
									inputEncoding: { value: Bm[3e3] },
									outputEncoding: { value: Bm[3e3] },
								},
								vertexShader:
									"\n\n\t\tprecision mediump float;\n\t\tprecision mediump int;\n\n\t\tattribute vec3 position;\n\t\tattribute vec2 uv;\n\t\tattribute float faceIndex;\n\n\t\tvarying vec3 vOutputDirection;\n\n\t\t// RH coordinate system; PMREM face-indexing convention\n\t\tvec3 getDirection( vec2 uv, float face ) {\n\n\t\t\tuv = 2.0 * uv - 1.0;\n\n\t\t\tvec3 direction = vec3( uv, 1.0 );\n\n\t\t\tif ( face == 0.0 ) {\n\n\t\t\t\tdirection = direction.zyx; // ( 1, v, u ) pos x\n\n\t\t\t} else if ( face == 1.0 ) {\n\n\t\t\t\tdirection = direction.xzy;\n\t\t\t\tdirection.xz *= -1.0; // ( -u, 1, -v ) pos y\n\n\t\t\t} else if ( face == 2.0 ) {\n\n\t\t\t\tdirection.x *= -1.0; // ( -u, v, 1 ) pos z\n\n\t\t\t} else if ( face == 3.0 ) {\n\n\t\t\t\tdirection = direction.zyx;\n\t\t\t\tdirection.xz *= -1.0; // ( -1, v, -u ) neg x\n\n\t\t\t} else if ( face == 4.0 ) {\n\n\t\t\t\tdirection = direction.xzy;\n\t\t\t\tdirection.xy *= -1.0; // ( -u, -1, v ) neg y\n\n\t\t\t} else if ( face == 5.0 ) {\n\n\t\t\t\tdirection.z *= -1.0; // ( u, v, -1 ) neg z\n\n\t\t\t}\n\n\t\t\treturn direction;\n\n\t\t}\n\n\t\tvoid main() {\n\n\t\t\tvOutputDirection = getDirection( uv, faceIndex );\n\t\t\tgl_Position = vec4( position, 1.0 );\n\n\t\t}\n\t",
								fragmentShader:
									"\n\n\t\t\tprecision mediump float;\n\t\t\tprecision mediump int;\n\n\t\t\tvarying vec3 vOutputDirection;\n\n\t\t\tuniform sampler2D envMap;\n\t\t\tuniform vec2 texelSize;\n\n\t\t\t\n\n\t\tuniform int inputEncoding;\n\t\tuniform int outputEncoding;\n\n\t\t#include <encodings_pars_fragment>\n\n\t\tvec4 inputTexelToLinear( vec4 value ) {\n\n\t\t\tif ( inputEncoding == 0 ) {\n\n\t\t\t\treturn value;\n\n\t\t\t} else if ( inputEncoding == 1 ) {\n\n\t\t\t\treturn sRGBToLinear( value );\n\n\t\t\t} else if ( inputEncoding == 2 ) {\n\n\t\t\t\treturn RGBEToLinear( value );\n\n\t\t\t} else if ( inputEncoding == 3 ) {\n\n\t\t\t\treturn RGBMToLinear( value, 7.0 );\n\n\t\t\t} else if ( inputEncoding == 4 ) {\n\n\t\t\t\treturn RGBMToLinear( value, 16.0 );\n\n\t\t\t} else if ( inputEncoding == 5 ) {\n\n\t\t\t\treturn RGBDToLinear( value, 256.0 );\n\n\t\t\t} else {\n\n\t\t\t\treturn GammaToLinear( value, 2.2 );\n\n\t\t\t}\n\n\t\t}\n\n\t\tvec4 linearToOutputTexel( vec4 value ) {\n\n\t\t\tif ( outputEncoding == 0 ) {\n\n\t\t\t\treturn value;\n\n\t\t\t} else if ( outputEncoding == 1 ) {\n\n\t\t\t\treturn LinearTosRGB( value );\n\n\t\t\t} else if ( outputEncoding == 2 ) {\n\n\t\t\t\treturn LinearToRGBE( value );\n\n\t\t\t} else if ( outputEncoding == 3 ) {\n\n\t\t\t\treturn LinearToRGBM( value, 7.0 );\n\n\t\t\t} else if ( outputEncoding == 4 ) {\n\n\t\t\t\treturn LinearToRGBM( value, 16.0 );\n\n\t\t\t} else if ( outputEncoding == 5 ) {\n\n\t\t\t\treturn LinearToRGBD( value, 256.0 );\n\n\t\t\t} else {\n\n\t\t\t\treturn LinearToGamma( value, 2.2 );\n\n\t\t\t}\n\n\t\t}\n\n\t\tvec4 envMapTexelToLinear( vec4 color ) {\n\n\t\t\treturn inputTexelToLinear( color );\n\n\t\t}\n\t\n\n\t\t\t#include <common>\n\n\t\t\tvoid main() {\n\n\t\t\t\tgl_FragColor = vec4( 0.0, 0.0, 0.0, 1.0 );\n\n\t\t\t\tvec3 outputDirection = normalize( vOutputDirection );\n\t\t\t\tvec2 uv = equirectUv( outputDirection );\n\n\t\t\t\tvec2 f = fract( uv / texelSize - 0.5 );\n\t\t\t\tuv -= f * texelSize;\n\t\t\t\tvec3 tl = envMapTexelToLinear( texture2D ( envMap, uv ) ).rgb;\n\t\t\t\tuv.x += texelSize.x;\n\t\t\t\tvec3 tr = envMapTexelToLinear( texture2D ( envMap, uv ) ).rgb;\n\t\t\t\tuv.y += texelSize.y;\n\t\t\t\tvec3 br = envMapTexelToLinear( texture2D ( envMap, uv ) ).rgb;\n\t\t\t\tuv.x -= texelSize.x;\n\t\t\t\tvec3 bl = envMapTexelToLinear( texture2D ( envMap, uv ) ).rgb;\n\n\t\t\t\tvec3 tm = mix( tl, tr, f.x );\n\t\t\t\tvec3 bm = mix( bl, br, f.x );\n\t\t\t\tgl_FragColor.rgb = mix( tm, bm, f.y );\n\n\t\t\t\tgl_FragColor = linearToOutputTexel( gl_FragColor );\n\n\t\t\t}\n\t\t",
								blending: 0,
								depthTest: !1,
								depthWrite: !1,
							});
						}
						function af() {
							return new Hp({
								name: "CubemapToCubeUV",
								uniforms: {
									envMap: { value: null },
									inputEncoding: { value: Bm[3e3] },
									outputEncoding: { value: Bm[3e3] },
								},
								vertexShader:
									"\n\n\t\tprecision mediump float;\n\t\tprecision mediump int;\n\n\t\tattribute vec3 position;\n\t\tattribute vec2 uv;\n\t\tattribute float faceIndex;\n\n\t\tvarying vec3 vOutputDirection;\n\n\t\t// RH coordinate system; PMREM face-indexing convention\n\t\tvec3 getDirection( vec2 uv, float face ) {\n\n\t\t\tuv = 2.0 * uv - 1.0;\n\n\t\t\tvec3 direction = vec3( uv, 1.0 );\n\n\t\t\tif ( face == 0.0 ) {\n\n\t\t\t\tdirection = direction.zyx; // ( 1, v, u ) pos x\n\n\t\t\t} else if ( face == 1.0 ) {\n\n\t\t\t\tdirection = direction.xzy;\n\t\t\t\tdirection.xz *= -1.0; // ( -u, 1, -v ) pos y\n\n\t\t\t} else if ( face == 2.0 ) {\n\n\t\t\t\tdirection.x *= -1.0; // ( -u, v, 1 ) pos z\n\n\t\t\t} else if ( face == 3.0 ) {\n\n\t\t\t\tdirection = direction.zyx;\n\t\t\t\tdirection.xz *= -1.0; // ( -1, v, -u ) neg x\n\n\t\t\t} else if ( face == 4.0 ) {\n\n\t\t\t\tdirection = direction.xzy;\n\t\t\t\tdirection.xy *= -1.0; // ( -u, -1, v ) neg y\n\n\t\t\t} else if ( face == 5.0 ) {\n\n\t\t\t\tdirection.z *= -1.0; // ( u, v, -1 ) neg z\n\n\t\t\t}\n\n\t\t\treturn direction;\n\n\t\t}\n\n\t\tvoid main() {\n\n\t\t\tvOutputDirection = getDirection( uv, faceIndex );\n\t\t\tgl_Position = vec4( position, 1.0 );\n\n\t\t}\n\t",
								fragmentShader:
									"\n\n\t\t\tprecision mediump float;\n\t\t\tprecision mediump int;\n\n\t\t\tvarying vec3 vOutputDirection;\n\n\t\t\tuniform samplerCube envMap;\n\n\t\t\t\n\n\t\tuniform int inputEncoding;\n\t\tuniform int outputEncoding;\n\n\t\t#include <encodings_pars_fragment>\n\n\t\tvec4 inputTexelToLinear( vec4 value ) {\n\n\t\t\tif ( inputEncoding == 0 ) {\n\n\t\t\t\treturn value;\n\n\t\t\t} else if ( inputEncoding == 1 ) {\n\n\t\t\t\treturn sRGBToLinear( value );\n\n\t\t\t} else if ( inputEncoding == 2 ) {\n\n\t\t\t\treturn RGBEToLinear( value );\n\n\t\t\t} else if ( inputEncoding == 3 ) {\n\n\t\t\t\treturn RGBMToLinear( value, 7.0 );\n\n\t\t\t} else if ( inputEncoding == 4 ) {\n\n\t\t\t\treturn RGBMToLinear( value, 16.0 );\n\n\t\t\t} else if ( inputEncoding == 5 ) {\n\n\t\t\t\treturn RGBDToLinear( value, 256.0 );\n\n\t\t\t} else {\n\n\t\t\t\treturn GammaToLinear( value, 2.2 );\n\n\t\t\t}\n\n\t\t}\n\n\t\tvec4 linearToOutputTexel( vec4 value ) {\n\n\t\t\tif ( outputEncoding == 0 ) {\n\n\t\t\t\treturn value;\n\n\t\t\t} else if ( outputEncoding == 1 ) {\n\n\t\t\t\treturn LinearTosRGB( value );\n\n\t\t\t} else if ( outputEncoding == 2 ) {\n\n\t\t\t\treturn LinearToRGBE( value );\n\n\t\t\t} else if ( outputEncoding == 3 ) {\n\n\t\t\t\treturn LinearToRGBM( value, 7.0 );\n\n\t\t\t} else if ( outputEncoding == 4 ) {\n\n\t\t\t\treturn LinearToRGBM( value, 16.0 );\n\n\t\t\t} else if ( outputEncoding == 5 ) {\n\n\t\t\t\treturn LinearToRGBD( value, 256.0 );\n\n\t\t\t} else {\n\n\t\t\t\treturn LinearToGamma( value, 2.2 );\n\n\t\t\t}\n\n\t\t}\n\n\t\tvec4 envMapTexelToLinear( vec4 color ) {\n\n\t\t\treturn inputTexelToLinear( color );\n\n\t\t}\n\t\n\n\t\t\tvoid main() {\n\n\t\t\t\tgl_FragColor = vec4( 0.0, 0.0, 0.0, 1.0 );\n\t\t\t\tgl_FragColor.rgb = envMapTexelToLinear( textureCube( envMap, vec3( - vOutputDirection.x, vOutputDirection.yz ) ) ).rgb;\n\t\t\t\tgl_FragColor = linearToOutputTexel( gl_FragColor );\n\n\t\t\t}\n\t\t",
								blending: 0,
								depthTest: !1,
								depthWrite: !1,
							});
						}
						function sf(t) {
							console.warn(
								"THREE.Spline has been removed. Use THREE.CatmullRomCurve3 instead."
							),
								bu.call(this, t),
								(this.type = "catmullrom");
						}
						(tf.prototype = {
							constructor: tf,
							fromScene: function (t, e = 0, n = 0.1, i = 100) {
								Jm = this._renderer.getRenderTarget();
								const r = this._allocateTargets();
								return (
									this._sceneToCubeUV(t, n, i, r),
									e > 0 && this._blur(r, 0, 0, e),
									this._applyPMREM(r),
									this._cleanup(r),
									r
								);
							},
							fromEquirectangular: function (t) {
								return this._fromTexture(t);
							},
							fromCubemap: function (t) {
								return this._fromTexture(t);
							},
							compileCubemapShader: function () {
								null === this._cubemapShader &&
									((this._cubemapShader = af()),
									this._compileMaterial(this._cubemapShader));
							},
							compileEquirectangularShader: function () {
								null === this._equirectShader &&
									((this._equirectShader = of()),
									this._compileMaterial(this._equirectShader));
							},
							dispose: function () {
								this._blurMaterial.dispose(),
									null !== this._cubemapShader && this._cubemapShader.dispose(),
									null !== this._equirectShader &&
										this._equirectShader.dispose();
								for (let t = 0; t < Qm.length; t++) Qm[t].dispose();
							},
							_cleanup: function (t) {
								this._pingPongRenderTarget.dispose(),
									this._renderer.setRenderTarget(Jm),
									(t.scissorTest = !1),
									rf(t, 0, 0, t.width, t.height);
							},
							_fromTexture: function (t) {
								Jm = this._renderer.getRenderTarget();
								const e = this._allocateTargets(t);
								return (
									this._textureToCubeUV(t, e),
									this._applyPMREM(e),
									this._cleanup(e),
									e
								);
							},
							_allocateTargets: function (t) {
								const e = {
										magFilter: Di,
										minFilter: Di,
										generateMipmaps: !1,
										type: Qi,
										format: 1023,
										encoding: ef(t) ? t.encoding : dr,
										depthBuffer: !1,
										stencilBuffer: !1,
									},
									n = nf(e);
								return (
									(n.depthBuffer = !t), (this._pingPongRenderTarget = nf(e)), n
								);
							},
							_compileMaterial: function (t) {
								const e = new La(Qm[0], t);
								this._renderer.compile(e, Gm);
							},
							_sceneToCubeUV: function (t, e, n, i) {
								const r = new rs(90, 1, e, n),
									o = [1, -1, 1, 1, 1, 1],
									a = [1, 1, 1, -1, -1, -1],
									s = this._renderer,
									c = s.outputEncoding,
									l = s.toneMapping,
									h = s.getClearColor(),
									p = s.getClearAlpha();
								(s.toneMapping = 0), (s.outputEncoding = hr);
								let u = t.background;
								if (u && u.isColor) {
									u.convertSRGBToLinear();
									const e = Math.max(u.r, u.g, u.b),
										n = Math.min(Math.max(Math.ceil(Math.log2(e)), -128), 127);
									u = u.multiplyScalar(Math.pow(2, -n));
									const i = (n + 128) / 255;
									s.setClearColor(u, i), (t.background = null);
								}
								for (let e = 0; e < 6; e++) {
									const n = e % 3;
									0 == n
										? (r.up.set(0, o[e], 0), r.lookAt(a[e], 0, 0))
										: 1 == n
										? (r.up.set(0, 0, o[e]), r.lookAt(0, a[e], 0))
										: (r.up.set(0, o[e], 0), r.lookAt(0, 0, a[e])),
										rf(i, n * Dm, e > 2 ? Dm : 0, Dm, Dm),
										s.setRenderTarget(i),
										s.render(t, r);
								}
								(s.toneMapping = l),
									(s.outputEncoding = c),
									s.setClearColor(h, p);
							},
							_textureToCubeUV: function (t, e) {
								const n = this._renderer;
								t.isCubeTexture
									? null == this._cubemapShader && (this._cubemapShader = af())
									: null == this._equirectShader &&
									  (this._equirectShader = of());
								const i = t.isCubeTexture
										? this._cubemapShader
										: this._equirectShader,
									r = new La(Qm[0], i),
									o = i.uniforms;
								(o.envMap.value = t),
									t.isCubeTexture ||
										o.texelSize.value.set(
											1 / t.image.width,
											1 / t.image.height
										),
									(o.inputEncoding.value = Bm[t.encoding]),
									(o.outputEncoding.value = Bm[e.texture.encoding]),
									rf(e, 0, 0, 3 * Dm, 2 * Dm),
									n.setRenderTarget(e),
									n.render(r, Gm);
							},
							_applyPMREM: function (t) {
								const e = this._renderer,
									n = e.autoClear;
								e.autoClear = !1;
								for (let e = 1; e < Lm; e++) {
									const n = Math.sqrt(Pm[e] * Pm[e] - Pm[e - 1] * Pm[e - 1]),
										i = $m[(e - 1) % $m.length];
									this._blur(t, e - 1, e, n, i);
								}
								e.autoClear = n;
							},
							_blur: function (t, e, n, i, r) {
								const o = this._pingPongRenderTarget;
								this._halfBlur(t, o, e, n, i, "latitudinal", r),
									this._halfBlur(o, t, n, n, i, "longitudinal", r);
							},
							_halfBlur: function (t, e, n, i, r, o, a) {
								const s = this._renderer,
									c = this._blurMaterial;
								"latitudinal" !== o &&
									"longitudinal" !== o &&
									console.error(
										"blur direction must be either latitudinal or longitudinal!"
									);
								const l = new La(Qm[i], c),
									h = c.uniforms,
									p = _m[n] - 1,
									u = isFinite(r) ? Math.PI / (2 * p) : (2 * Math.PI) / 39,
									d = r / u,
									m = isFinite(r) ? 1 + Math.floor(3 * d) : 20;
								m > 20 &&
									console.warn(
										`sigmaRadians, ${r}, is too large and will clip, as it requested ${m} samples when the maximum is set to 20`
									);
								const f = [];
								let g = 0;
								for (let t = 0; t < 20; ++t) {
									const e = t / d,
										n = Math.exp((-e * e) / 2);
									f.push(n), 0 == t ? (g += n) : t < m && (g += 2 * n);
								}
								for (let t = 0; t < f.length; t++) f[t] = f[t] / g;
								(h.envMap.value = t.texture),
									(h.samples.value = m),
									(h.weights.value = f),
									(h.latitudinal.value = "latitudinal" === o),
									a && (h.poleAxis.value = a),
									(h.dTheta.value = u),
									(h.mipInt.value = 8 - n),
									(h.inputEncoding.value = Bm[t.texture.encoding]),
									(h.outputEncoding.value = Bm[t.texture.encoding]);
								const S = _m[i];
								rf(
									e,
									3 * Math.max(0, Dm - 2 * S),
									(0 === i ? 0 : 2 * Dm) + 2 * S * (i > 4 ? i - 8 + 4 : 0),
									3 * S,
									2 * S
								),
									s.setRenderTarget(e),
									s.render(l, Gm);
							},
						}),
							(Mu.create = function (t, e) {
								return (
									console.log("THREE.Curve.create() has been deprecated"),
									(t.prototype = Object.create(Mu.prototype)),
									(t.prototype.constructor = t),
									(t.prototype.getPoint = e),
									t
								);
							}),
							Object.assign(Du.prototype, {
								createPointsGeometry: function (t) {
									console.warn(
										"THREE.CurvePath: .createPointsGeometry() has been removed. Use new THREE.Geometry().setFromPoints( points ) instead."
									);
									const e = this.getPoints(t);
									return this.createGeometry(e);
								},
								createSpacedPointsGeometry: function (t) {
									console.warn(
										"THREE.CurvePath: .createSpacedPointsGeometry() has been removed. Use new THREE.Geometry().setFromPoints( points ) instead."
									);
									const e = this.getSpacedPoints(t);
									return this.createGeometry(e);
								},
								createGeometry: function (t) {
									console.warn(
										"THREE.CurvePath: .createGeometry() has been removed. Use new THREE.Geometry().setFromPoints( points ) instead."
									);
									const e = new Ya();
									for (let n = 0, i = t.length; n < i; n++) {
										const i = t[n];
										e.vertices.push(new zr(i.x, i.y, i.z || 0));
									}
									return e;
								},
							}),
							Object.assign(Au.prototype, {
								fromPoints: function (t) {
									return (
										console.warn(
											"THREE.Path: .fromPoints() has been renamed to .setFromPoints()."
										),
										this.setFromPoints(t)
									);
								},
							}),
							Object.create(bu.prototype),
							Object.create(bu.prototype),
							(sf.prototype = Object.create(bu.prototype)),
							Object.assign(sf.prototype, {
								initFromArray: function () {
									console.error(
										"THREE.Spline: .initFromArray() has been removed."
									);
								},
								getControlPointsArray: function () {
									console.error(
										"THREE.Spline: .getControlPointsArray() has been removed."
									);
								},
								reparametrizeByArcLength: function () {
									console.error(
										"THREE.Spline: .reparametrizeByArcLength() has been removed."
									);
								},
							}),
							(Im.prototype.setColors = function () {
								console.error(
									"THREE.GridHelper: setColors() has been deprecated, pass them in the constructor instead."
								);
							}),
							(Sm.prototype.update = function () {
								console.error(
									"THREE.SkeletonHelper: update() no longer needs to be called."
								);
							}),
							Object.assign(du.prototype, {
								extractUrlBase: function (t) {
									return (
										console.warn(
											"THREE.Loader: .extractUrlBase() has been deprecated. Use THREE.LoaderUtils.extractUrlBase() instead."
										),
										ad(t)
									);
								},
							}),
							(du.Handlers = {
								add: function () {
									console.error(
										"THREE.Loader: Handlers.add() has been removed. Use LoadingManager.addHandler() instead."
									);
								},
								get: function () {
									console.error(
										"THREE.Loader: Handlers.get() has been removed. Use LoadingManager.getHandler() instead."
									);
								},
							}),
							Object.assign(pd.prototype, {
								setTexturePath: function (t) {
									return (
										console.warn(
											"THREE.ObjectLoader: .setTexturePath() has been renamed to .setResourcePath()."
										),
										this.setResourcePath(t)
									);
								},
							}),
							Object.assign(am.prototype, {
								center: function (t) {
									return (
										console.warn(
											"THREE.Box2: .center() has been renamed to .getCenter()."
										),
										this.getCenter(t)
									);
								},
								empty: function () {
									return (
										console.warn(
											"THREE.Box2: .empty() has been renamed to .isEmpty()."
										),
										this.isEmpty()
									);
								},
								isIntersectionBox: function (t) {
									return (
										console.warn(
											"THREE.Box2: .isIntersectionBox() has been renamed to .intersectsBox()."
										),
										this.intersectsBox(t)
									);
								},
								size: function (t) {
									return (
										console.warn(
											"THREE.Box2: .size() has been renamed to .getSize()."
										),
										this.getSize(t)
									);
								},
							}),
							Object.assign(Ro.prototype, {
								center: function (t) {
									return (
										console.warn(
											"THREE.Box3: .center() has been renamed to .getCenter()."
										),
										this.getCenter(t)
									);
								},
								empty: function () {
									return (
										console.warn(
											"THREE.Box3: .empty() has been renamed to .isEmpty()."
										),
										this.isEmpty()
									);
								},
								isIntersectionBox: function (t) {
									return (
										console.warn(
											"THREE.Box3: .isIntersectionBox() has been renamed to .intersectsBox()."
										),
										this.intersectsBox(t)
									);
								},
								isIntersectionSphere: function (t) {
									return (
										console.warn(
											"THREE.Box3: .isIntersectionSphere() has been renamed to .intersectsSphere()."
										),
										this.intersectsSphere(t)
									);
								},
								size: function (t) {
									return (
										console.warn(
											"THREE.Box3: .size() has been renamed to .getSize()."
										),
										this.getSize(t)
									);
								},
							}),
							Object.assign(vo.prototype, {
								empty: function () {
									return (
										console.warn(
											"THREE.Sphere: .empty() has been renamed to .isEmpty()."
										),
										this.isEmpty()
									);
								},
							}),
							(ps.prototype.setFromMatrix = function (t) {
								return (
									console.warn(
										"THREE.Frustum: .setFromMatrix() has been renamed to .setFromProjectionMatrix()."
									),
									this.setFromProjectionMatrix(t)
								);
							}),
							(lm.prototype.center = function (t) {
								return (
									console.warn(
										"THREE.Line3: .center() has been renamed to .getCenter()."
									),
									this.getCenter(t)
								);
							}),
							Object.assign(qr, {
								random16: function () {
									return (
										console.warn(
											"THREE.Math: .random16() has been deprecated. Use Math.random() instead."
										),
										Math.random()
									);
								},
								nearestPowerOfTwo: function (t) {
									return (
										console.warn(
											"THREE.Math: .nearestPowerOfTwo() has been renamed to .floorPowerOfTwo()."
										),
										qr.floorPowerOfTwo(t)
									);
								},
								nextPowerOfTwo: function (t) {
									return (
										console.warn(
											"THREE.Math: .nextPowerOfTwo() has been renamed to .ceilPowerOfTwo()."
										),
										qr.ceilPowerOfTwo(t)
									);
								},
							}),
							Object.assign(Mr.prototype, {
								flattenToArrayOffset: function (t, e) {
									return (
										console.warn(
											"THREE.Matrix3: .flattenToArrayOffset() has been deprecated. Use .toArray() instead."
										),
										this.toArray(t, e)
									);
								},
								multiplyVector3: function (t) {
									return (
										console.warn(
											"THREE.Matrix3: .multiplyVector3() has been removed. Use vector.applyMatrix3( matrix ) instead."
										),
										t.applyMatrix3(this)
									);
								},
								multiplyVector3Array: function () {
									console.error(
										"THREE.Matrix3: .multiplyVector3Array() has been removed."
									);
								},
								applyToBufferAttribute: function (t) {
									return (
										console.warn(
											"THREE.Matrix3: .applyToBufferAttribute() has been removed. Use attribute.applyMatrix3( matrix ) instead."
										),
										t.applyMatrix3(this)
									);
								},
								applyToVector3Array: function () {
									console.error(
										"THREE.Matrix3: .applyToVector3Array() has been removed."
									);
								},
							}),
							Object.assign(jr.prototype, {
								extractPosition: function (t) {
									return (
										console.warn(
											"THREE.Matrix4: .extractPosition() has been renamed to .copyPosition()."
										),
										this.copyPosition(t)
									);
								},
								flattenToArrayOffset: function (t, e) {
									return (
										console.warn(
											"THREE.Matrix4: .flattenToArrayOffset() has been deprecated. Use .toArray() instead."
										),
										this.toArray(t, e)
									);
								},
								getPosition: function () {
									return (
										console.warn(
											"THREE.Matrix4: .getPosition() has been removed. Use Vector3.setFromMatrixPosition( matrix ) instead."
										),
										new zr().setFromMatrixColumn(this, 3)
									);
								},
								setRotationFromQuaternion: function (t) {
									return (
										console.warn(
											"THREE.Matrix4: .setRotationFromQuaternion() has been renamed to .makeRotationFromQuaternion()."
										),
										this.makeRotationFromQuaternion(t)
									);
								},
								multiplyToArray: function () {
									console.warn(
										"THREE.Matrix4: .multiplyToArray() has been removed."
									);
								},
								multiplyVector3: function (t) {
									return (
										console.warn(
											"THREE.Matrix4: .multiplyVector3() has been removed. Use vector.applyMatrix4( matrix ) instead."
										),
										t.applyMatrix4(this)
									);
								},
								multiplyVector4: function (t) {
									return (
										console.warn(
											"THREE.Matrix4: .multiplyVector4() has been removed. Use vector.applyMatrix4( matrix ) instead."
										),
										t.applyMatrix4(this)
									);
								},
								multiplyVector3Array: function () {
									console.error(
										"THREE.Matrix4: .multiplyVector3Array() has been removed."
									);
								},
								rotateAxis: function (t) {
									console.warn(
										"THREE.Matrix4: .rotateAxis() has been removed. Use Vector3.transformDirection( matrix ) instead."
									),
										t.transformDirection(this);
								},
								crossVector: function (t) {
									return (
										console.warn(
											"THREE.Matrix4: .crossVector() has been removed. Use vector.applyMatrix4( matrix ) instead."
										),
										t.applyMatrix4(this)
									);
								},
								translate: function () {
									console.error(
										"THREE.Matrix4: .translate() has been removed."
									);
								},
								rotateX: function () {
									console.error("THREE.Matrix4: .rotateX() has been removed.");
								},
								rotateY: function () {
									console.error("THREE.Matrix4: .rotateY() has been removed.");
								},
								rotateZ: function () {
									console.error("THREE.Matrix4: .rotateZ() has been removed.");
								},
								rotateByAxis: function () {
									console.error(
										"THREE.Matrix4: .rotateByAxis() has been removed."
									);
								},
								applyToBufferAttribute: function (t) {
									return (
										console.warn(
											"THREE.Matrix4: .applyToBufferAttribute() has been removed. Use attribute.applyMatrix4( matrix ) instead."
										),
										t.applyMatrix4(this)
									);
								},
								applyToVector3Array: function () {
									console.error(
										"THREE.Matrix4: .applyToVector3Array() has been removed."
									);
								},
								makeFrustum: function (t, e, n, i, r, o) {
									return (
										console.warn(
											"THREE.Matrix4: .makeFrustum() has been removed. Use .makePerspective( left, right, top, bottom, near, far ) instead."
										),
										this.makePerspective(t, e, i, n, r, o)
									);
								},
							}),
							(Co.prototype.isIntersectionLine = function (t) {
								return (
									console.warn(
										"THREE.Plane: .isIntersectionLine() has been renamed to .intersectsLine()."
									),
									this.intersectsLine(t)
								);
							}),
							(br.prototype.multiplyVector3 = function (t) {
								return (
									console.warn(
										"THREE.Quaternion: .multiplyVector3() has been removed. Use is now vector.applyQuaternion( quaternion ) instead."
									),
									t.applyQuaternion(this)
								);
							}),
							Object.assign(To.prototype, {
								isIntersectionBox: function (t) {
									return (
										console.warn(
											"THREE.Ray: .isIntersectionBox() has been renamed to .intersectsBox()."
										),
										this.intersectsBox(t)
									);
								},
								isIntersectionPlane: function (t) {
									return (
										console.warn(
											"THREE.Ray: .isIntersectionPlane() has been renamed to .intersectsPlane()."
										),
										this.intersectsPlane(t)
									);
								},
								isIntersectionSphere: function (t) {
									return (
										console.warn(
											"THREE.Ray: .isIntersectionSphere() has been renamed to .intersectsSphere()."
										),
										this.intersectsSphere(t)
									);
								},
							}),
							Object.assign(Qo.prototype, {
								area: function () {
									return (
										console.warn(
											"THREE.Triangle: .area() has been renamed to .getArea()."
										),
										this.getArea()
									);
								},
								barycoordFromPoint: function (t, e) {
									return (
										console.warn(
											"THREE.Triangle: .barycoordFromPoint() has been renamed to .getBarycoord()."
										),
										this.getBarycoord(t, e)
									);
								},
								midpoint: function (t) {
									return (
										console.warn(
											"THREE.Triangle: .midpoint() has been renamed to .getMidpoint()."
										),
										this.getMidpoint(t)
									);
								},
								normal: function (t) {
									return (
										console.warn(
											"THREE.Triangle: .normal() has been renamed to .getNormal()."
										),
										this.getNormal(t)
									);
								},
								plane: function (t) {
									return (
										console.warn(
											"THREE.Triangle: .plane() has been renamed to .getPlane()."
										),
										this.getPlane(t)
									);
								},
							}),
							Object.assign(Qo, {
								barycoordFromPoint: function (t, e, n, i, r) {
									return (
										console.warn(
											"THREE.Triangle: .barycoordFromPoint() has been renamed to .getBarycoord()."
										),
										Qo.getBarycoord(t, e, n, i, r)
									);
								},
								normal: function (t, e, n, i) {
									return (
										console.warn(
											"THREE.Triangle: .normal() has been renamed to .getNormal()."
										),
										Qo.getNormal(t, e, n, i)
									);
								},
							}),
							Object.assign(Lu.prototype, {
								extractAllPoints: function (t) {
									return (
										console.warn(
											"THREE.Shape: .extractAllPoints() has been removed. Use .extractPoints() instead."
										),
										this.extractPoints(t)
									);
								},
								extrude: function (t) {
									return (
										console.warn(
											"THREE.Shape: .extrude() has been removed. Use ExtrudeGeometry() instead."
										),
										new fp(this, t)
									);
								},
								makeGeometry: function (t) {
									return (
										console.warn(
											"THREE.Shape: .makeGeometry() has been removed. Use ShapeGeometry() instead."
										),
										new wp(this, t)
									);
								},
							}),
							Object.assign(Rr.prototype, {
								fromAttribute: function (t, e, n) {
									return (
										console.warn(
											"THREE.Vector2: .fromAttribute() has been renamed to .fromBufferAttribute()."
										),
										this.fromBufferAttribute(t, e, n)
									);
								},
								distanceToManhattan: function (t) {
									return (
										console.warn(
											"THREE.Vector2: .distanceToManhattan() has been renamed to .manhattanDistanceTo()."
										),
										this.manhattanDistanceTo(t)
									);
								},
								lengthManhattan: function () {
									return (
										console.warn(
											"THREE.Vector2: .lengthManhattan() has been renamed to .manhattanLength()."
										),
										this.manhattanLength()
									);
								},
							}),
							Object.assign(zr.prototype, {
								setEulerFromRotationMatrix: function () {
									console.error(
										"THREE.Vector3: .setEulerFromRotationMatrix() has been removed. Use Euler.setFromRotationMatrix() instead."
									);
								},
								setEulerFromQuaternion: function () {
									console.error(
										"THREE.Vector3: .setEulerFromQuaternion() has been removed. Use Euler.setFromQuaternion() instead."
									);
								},
								getPositionFromMatrix: function (t) {
									return (
										console.warn(
											"THREE.Vector3: .getPositionFromMatrix() has been renamed to .setFromMatrixPosition()."
										),
										this.setFromMatrixPosition(t)
									);
								},
								getScaleFromMatrix: function (t) {
									return (
										console.warn(
											"THREE.Vector3: .getScaleFromMatrix() has been renamed to .setFromMatrixScale()."
										),
										this.setFromMatrixScale(t)
									);
								},
								getColumnFromMatrix: function (t, e) {
									return (
										console.warn(
											"THREE.Vector3: .getColumnFromMatrix() has been renamed to .setFromMatrixColumn()."
										),
										this.setFromMatrixColumn(e, t)
									);
								},
								applyProjection: function (t) {
									return (
										console.warn(
											"THREE.Vector3: .applyProjection() has been removed. Use .applyMatrix4( m ) instead."
										),
										this.applyMatrix4(t)
									);
								},
								fromAttribute: function (t, e, n) {
									return (
										console.warn(
											"THREE.Vector3: .fromAttribute() has been renamed to .fromBufferAttribute()."
										),
										this.fromBufferAttribute(t, e, n)
									);
								},
								distanceToManhattan: function (t) {
									return (
										console.warn(
											"THREE.Vector3: .distanceToManhattan() has been renamed to .manhattanDistanceTo()."
										),
										this.manhattanDistanceTo(t)
									);
								},
								lengthManhattan: function () {
									return (
										console.warn(
											"THREE.Vector3: .lengthManhattan() has been renamed to .manhattanLength()."
										),
										this.manhattanLength()
									);
								},
							}),
							Object.assign(wr.prototype, {
								fromAttribute: function (t, e, n) {
									return (
										console.warn(
											"THREE.Vector4: .fromAttribute() has been renamed to .fromBufferAttribute()."
										),
										this.fromBufferAttribute(t, e, n)
									);
								},
								lengthManhattan: function () {
									return (
										console.warn(
											"THREE.Vector4: .lengthManhattan() has been renamed to .manhattanLength()."
										),
										this.manhattanLength()
									);
								},
							}),
							Object.assign(Ya.prototype, {
								computeTangents: function () {
									console.error(
										"THREE.Geometry: .computeTangents() has been removed."
									);
								},
								computeLineDistances: function () {
									console.error(
										"THREE.Geometry: .computeLineDistances() has been removed. Use THREE.Line.computeLineDistances() instead."
									);
								},
								applyMatrix: function (t) {
									return (
										console.warn(
											"THREE.Geometry: .applyMatrix() has been renamed to .applyMatrix4()."
										),
										this.applyMatrix4(t)
									);
								},
							}),
							Object.assign(oo.prototype, {
								getChildByName: function (t) {
									return (
										console.warn(
											"THREE.Object3D: .getChildByName() has been renamed to .getObjectByName()."
										),
										this.getObjectByName(t)
									);
								},
								renderDepth: function () {
									console.warn(
										"THREE.Object3D: .renderDepth has been removed. Use .renderOrder, instead."
									);
								},
								translate: function (t, e) {
									return (
										console.warn(
											"THREE.Object3D: .translate() has been removed. Use .translateOnAxis( axis, distance ) instead."
										),
										this.translateOnAxis(e, t)
									);
								},
								getWorldRotation: function () {
									console.error(
										"THREE.Object3D: .getWorldRotation() has been removed. Use THREE.Object3D.getWorldQuaternion( target ) instead."
									);
								},
								applyMatrix: function (t) {
									return (
										console.warn(
											"THREE.Object3D: .applyMatrix() has been renamed to .applyMatrix4()."
										),
										this.applyMatrix4(t)
									);
								},
							}),
							Object.defineProperties(oo.prototype, {
								eulerOrder: {
									get: function () {
										return (
											console.warn(
												"THREE.Object3D: .eulerOrder is now .rotation.order."
											),
											this.rotation.order
										);
									},
									set: function (t) {
										console.warn(
											"THREE.Object3D: .eulerOrder is now .rotation.order."
										),
											(this.rotation.order = t);
									},
								},
								useQuaternion: {
									get: function () {
										console.warn(
											"THREE.Object3D: .useQuaternion has been removed. The library now uses quaternions by default."
										);
									},
									set: function () {
										console.warn(
											"THREE.Object3D: .useQuaternion has been removed. The library now uses quaternions by default."
										);
									},
								},
							}),
							Object.assign(La.prototype, {
								setDrawMode: function () {
									console.error(
										"THREE.Mesh: .setDrawMode() has been removed. The renderer now always assumes THREE.TrianglesDrawMode. Transform your geometry via BufferGeometryUtils.toTrianglesDrawMode() if necessary."
									);
								},
							}),
							Object.defineProperties(La.prototype, {
								drawMode: {
									get: function () {
										return (
											console.error(
												"THREE.Mesh: .drawMode has been removed. The renderer now always assumes THREE.TrianglesDrawMode."
											),
											0
										);
									},
									set: function () {
										console.error(
											"THREE.Mesh: .drawMode has been removed. The renderer now always assumes THREE.TrianglesDrawMode. Transform your geometry via BufferGeometryUtils.toTrianglesDrawMode() if necessary."
										);
									},
								},
							}),
							Object.defineProperties(Ll.prototype, {
								objects: {
									get: function () {
										return (
											console.warn(
												"THREE.LOD: .objects has been renamed to .levels."
											),
											this.levels
										);
									},
								},
							}),
							Object.defineProperty(_l.prototype, "useVertexTexture", {
								get: function () {
									console.warn(
										"THREE.Skeleton: useVertexTexture has been removed."
									);
								},
								set: function () {
									console.warn(
										"THREE.Skeleton: useVertexTexture has been removed."
									);
								},
							}),
							(Bl.prototype.initBones = function () {
								console.error(
									"THREE.SkinnedMesh: initBones() has been removed."
								);
							}),
							Object.defineProperty(Mu.prototype, "__arcLengthDivisions", {
								get: function () {
									return (
										console.warn(
											"THREE.Curve: .__arcLengthDivisions is now .arcLengthDivisions."
										),
										this.arcLengthDivisions
									);
								},
								set: function (t) {
									console.warn(
										"THREE.Curve: .__arcLengthDivisions is now .arcLengthDivisions."
									),
										(this.arcLengthDivisions = t);
								},
							}),
							(rs.prototype.setLens = function (t, e) {
								console.warn(
									"THREE.PerspectiveCamera.setLens is deprecated. Use .setFocalLength and .filmGauge for a photographic setup."
								),
									void 0 !== e && (this.filmGauge = e),
									this.setFocalLength(t);
							}),
							Object.defineProperties(Bu.prototype, {
								onlyShadow: {
									set: function () {
										console.warn("THREE.Light: .onlyShadow has been removed.");
									},
								},
								shadowCameraFov: {
									set: function (t) {
										console.warn(
											"THREE.Light: .shadowCameraFov is now .shadow.camera.fov."
										),
											(this.shadow.camera.fov = t);
									},
								},
								shadowCameraLeft: {
									set: function (t) {
										console.warn(
											"THREE.Light: .shadowCameraLeft is now .shadow.camera.left."
										),
											(this.shadow.camera.left = t);
									},
								},
								shadowCameraRight: {
									set: function (t) {
										console.warn(
											"THREE.Light: .shadowCameraRight is now .shadow.camera.right."
										),
											(this.shadow.camera.right = t);
									},
								},
								shadowCameraTop: {
									set: function (t) {
										console.warn(
											"THREE.Light: .shadowCameraTop is now .shadow.camera.top."
										),
											(this.shadow.camera.top = t);
									},
								},
								shadowCameraBottom: {
									set: function (t) {
										console.warn(
											"THREE.Light: .shadowCameraBottom is now .shadow.camera.bottom."
										),
											(this.shadow.camera.bottom = t);
									},
								},
								shadowCameraNear: {
									set: function (t) {
										console.warn(
											"THREE.Light: .shadowCameraNear is now .shadow.camera.near."
										),
											(this.shadow.camera.near = t);
									},
								},
								shadowCameraFar: {
									set: function (t) {
										console.warn(
											"THREE.Light: .shadowCameraFar is now .shadow.camera.far."
										),
											(this.shadow.camera.far = t);
									},
								},
								shadowCameraVisible: {
									set: function () {
										console.warn(
											"THREE.Light: .shadowCameraVisible has been removed. Use new THREE.CameraHelper( light.shadow.camera ) instead."
										);
									},
								},
								shadowBias: {
									set: function (t) {
										console.warn(
											"THREE.Light: .shadowBias is now .shadow.bias."
										),
											(this.shadow.bias = t);
									},
								},
								shadowDarkness: {
									set: function () {
										console.warn(
											"THREE.Light: .shadowDarkness has been removed."
										);
									},
								},
								shadowMapWidth: {
									set: function (t) {
										console.warn(
											"THREE.Light: .shadowMapWidth is now .shadow.mapSize.width."
										),
											(this.shadow.mapSize.width = t);
									},
								},
								shadowMapHeight: {
									set: function (t) {
										console.warn(
											"THREE.Light: .shadowMapHeight is now .shadow.mapSize.height."
										),
											(this.shadow.mapSize.height = t);
									},
								},
							}),
							Object.defineProperties(sa.prototype, {
								length: {
									get: function () {
										return (
											console.warn(
												"THREE.BufferAttribute: .length has been deprecated. Use .count instead."
											),
											this.array.length
										);
									},
								},
								dynamic: {
									get: function () {
										return (
											console.warn(
												"THREE.BufferAttribute: .dynamic has been deprecated. Use .usage instead."
											),
											this.usage === gr
										);
									},
									set: function () {
										console.warn(
											"THREE.BufferAttribute: .dynamic has been deprecated. Use .usage instead."
										),
											this.setUsage(gr);
									},
								},
							}),
							Object.assign(sa.prototype, {
								setDynamic: function (t) {
									return (
										console.warn(
											"THREE.BufferAttribute: .setDynamic() has been deprecated. Use .setUsage() instead."
										),
										this.setUsage(!0 === t ? gr : fr),
										this
									);
								},
								copyIndicesArray: function () {
									console.error(
										"THREE.BufferAttribute: .copyIndicesArray() has been removed."
									);
								},
								setArray: function () {
									console.error(
										"THREE.BufferAttribute: .setArray has been removed. Use BufferGeometry .setAttribute to replace/resize attribute buffers"
									);
								},
							}),
							Object.assign(Ua.prototype, {
								addIndex: function (t) {
									console.warn(
										"THREE.BufferGeometry: .addIndex() has been renamed to .setIndex()."
									),
										this.setIndex(t);
								},
								addAttribute: function (t, e) {
									return (
										console.warn(
											"THREE.BufferGeometry: .addAttribute() has been renamed to .setAttribute()."
										),
										(e && e.isBufferAttribute) ||
										(e && e.isInterleavedBufferAttribute)
											? "index" === t
												? (console.warn(
														"THREE.BufferGeometry.addAttribute: Use .setIndex() for index attribute."
												  ),
												  this.setIndex(e),
												  this)
												: this.setAttribute(t, e)
											: (console.warn(
													"THREE.BufferGeometry: .addAttribute() now expects ( name, attribute )."
											  ),
											  this.setAttribute(
													t,
													new sa(arguments[1], arguments[2])
											  ))
									);
								},
								addDrawCall: function (t, e, n) {
									void 0 !== n &&
										console.warn(
											"THREE.BufferGeometry: .addDrawCall() no longer supports indexOffset."
										),
										console.warn(
											"THREE.BufferGeometry: .addDrawCall() is now .addGroup()."
										),
										this.addGroup(t, e);
								},
								clearDrawCalls: function () {
									console.warn(
										"THREE.BufferGeometry: .clearDrawCalls() is now .clearGroups()."
									),
										this.clearGroups();
								},
								computeTangents: function () {
									console.warn(
										"THREE.BufferGeometry: .computeTangents() has been removed."
									);
								},
								computeOffsets: function () {
									console.warn(
										"THREE.BufferGeometry: .computeOffsets() has been removed."
									);
								},
								removeAttribute: function (t) {
									return (
										console.warn(
											"THREE.BufferGeometry: .removeAttribute() has been renamed to .deleteAttribute()."
										),
										this.deleteAttribute(t)
									);
								},
								applyMatrix: function (t) {
									return (
										console.warn(
											"THREE.BufferGeometry: .applyMatrix() has been renamed to .applyMatrix4()."
										),
										this.applyMatrix4(t)
									);
								},
							}),
							Object.defineProperties(Ua.prototype, {
								drawcalls: {
									get: function () {
										return (
											console.error(
												"THREE.BufferGeometry: .drawcalls has been renamed to .groups."
											),
											this.groups
										);
									},
								},
								offsets: {
									get: function () {
										return (
											console.warn(
												"THREE.BufferGeometry: .offsets has been renamed to .groups."
											),
											this.groups
										);
									},
								},
							}),
							Object.defineProperties(sd.prototype, {
								maxInstancedCount: {
									get: function () {
										return (
											console.warn(
												"THREE.InstancedBufferGeometry: .maxInstancedCount has been renamed to .instanceCount."
											),
											this.instanceCount
										);
									},
									set: function (t) {
										console.warn(
											"THREE.InstancedBufferGeometry: .maxInstancedCount has been renamed to .instanceCount."
										),
											(this.instanceCount = t);
									},
								},
							}),
							Object.defineProperties(nm.prototype, {
								linePrecision: {
									get: function () {
										return (
											console.warn(
												"THREE.Raycaster: .linePrecision has been deprecated. Use .params.Line.threshold instead."
											),
											this.params.Line.threshold
										);
									},
									set: function (t) {
										console.warn(
											"THREE.Raycaster: .linePrecision has been deprecated. Use .params.Line.threshold instead."
										),
											(this.params.Line.threshold = t);
									},
								},
							}),
							Object.defineProperties(Il.prototype, {
								dynamic: {
									get: function () {
										return (
											console.warn(
												"THREE.InterleavedBuffer: .length has been deprecated. Use .usage instead."
											),
											this.usage === gr
										);
									},
									set: function (t) {
										console.warn(
											"THREE.InterleavedBuffer: .length has been deprecated. Use .usage instead."
										),
											this.setUsage(t);
									},
								},
							}),
							Object.assign(Il.prototype, {
								setDynamic: function (t) {
									return (
										console.warn(
											"THREE.InterleavedBuffer: .setDynamic() has been deprecated. Use .setUsage() instead."
										),
										this.setUsage(!0 === t ? gr : fr),
										this
									);
								},
								setArray: function () {
									console.error(
										"THREE.InterleavedBuffer: .setArray has been removed. Use BufferGeometry .setAttribute to replace/resize attribute buffers"
									);
								},
							}),
							Object.assign(gp.prototype, {
								getArrays: function () {
									console.error(
										"THREE.ExtrudeBufferGeometry: .getArrays() has been removed."
									);
								},
								addShapeList: function () {
									console.error(
										"THREE.ExtrudeBufferGeometry: .addShapeList() has been removed."
									);
								},
								addShape: function () {
									console.error(
										"THREE.ExtrudeBufferGeometry: .addShape() has been removed."
									);
								},
							}),
							Object.defineProperties(tm.prototype, {
								dynamic: {
									set: function () {
										console.warn(
											"THREE.Uniform: .dynamic has been removed. Use object.onBeforeRender() instead."
										);
									},
								},
								onUpdate: {
									value: function () {
										return (
											console.warn(
												"THREE.Uniform: .onUpdate() has been removed. Use object.onBeforeRender() instead."
											),
											this
										);
									},
								},
							}),
							Object.defineProperties(ia.prototype, {
								wrapAround: {
									get: function () {
										console.warn(
											"THREE.Material: .wrapAround has been removed."
										);
									},
									set: function () {
										console.warn(
											"THREE.Material: .wrapAround has been removed."
										);
									},
								},
								overdraw: {
									get: function () {
										console.warn("THREE.Material: .overdraw has been removed.");
									},
									set: function () {
										console.warn("THREE.Material: .overdraw has been removed.");
									},
								},
								wrapRGB: {
									get: function () {
										return (
											console.warn(
												"THREE.Material: .wrapRGB has been removed."
											),
											new Yo()
										);
									},
								},
								shading: {
									get: function () {
										console.error(
											"THREE." +
												this.type +
												": .shading has been removed. Use the boolean .flatShading instead."
										);
									},
									set: function (t) {
										console.warn(
											"THREE." +
												this.type +
												": .shading has been removed. Use the boolean .flatShading instead."
										),
											(this.flatShading = 1 === t);
									},
								},
								stencilMask: {
									get: function () {
										return (
											console.warn(
												"THREE." +
													this.type +
													": .stencilMask has been removed. Use .stencilFuncMask instead."
											),
											this.stencilFuncMask
										);
									},
									set: function (t) {
										console.warn(
											"THREE." +
												this.type +
												": .stencilMask has been removed. Use .stencilFuncMask instead."
										),
											(this.stencilFuncMask = t);
									},
								},
							}),
							Object.defineProperties(Dp.prototype, {
								metal: {
									get: function () {
										return (
											console.warn(
												"THREE.MeshPhongMaterial: .metal has been removed. Use THREE.MeshStandardMaterial instead."
											),
											!1
										);
									},
									set: function () {
										console.warn(
											"THREE.MeshPhongMaterial: .metal has been removed. Use THREE.MeshStandardMaterial instead"
										);
									},
								},
							}),
							Object.defineProperties(jp.prototype, {
								transparency: {
									get: function () {
										return (
											console.warn(
												"THREE.MeshPhysicalMaterial: .transparency has been renamed to .transmission."
											),
											this.transmission
										);
									},
									set: function (t) {
										console.warn(
											"THREE.MeshPhysicalMaterial: .transparency has been renamed to .transmission."
										),
											(this.transmission = t);
									},
								},
							}),
							Object.defineProperties(ns.prototype, {
								derivatives: {
									get: function () {
										return (
											console.warn(
												"THREE.ShaderMaterial: .derivatives has been moved to .extensions.derivatives."
											),
											this.extensions.derivatives
										);
									},
									set: function (t) {
										console.warn(
											"THREE. ShaderMaterial: .derivatives has been moved to .extensions.derivatives."
										),
											(this.extensions.derivatives = t);
									},
								},
							}),
							Object.assign(Vl.prototype, {
								clearTarget: function (t, e, n, i) {
									console.warn(
										"THREE.WebGLRenderer: .clearTarget() has been deprecated. Use .setRenderTarget() and .clear() instead."
									),
										this.setRenderTarget(t),
										this.clear(e, n, i);
								},
								animate: function (t) {
									console.warn(
										"THREE.WebGLRenderer: .animate() is now .setAnimationLoop()."
									),
										this.setAnimationLoop(t);
								},
								getCurrentRenderTarget: function () {
									return (
										console.warn(
											"THREE.WebGLRenderer: .getCurrentRenderTarget() is now .getRenderTarget()."
										),
										this.getRenderTarget()
									);
								},
								getMaxAnisotropy: function () {
									return (
										console.warn(
											"THREE.WebGLRenderer: .getMaxAnisotropy() is now .capabilities.getMaxAnisotropy()."
										),
										this.capabilities.getMaxAnisotropy()
									);
								},
								getPrecision: function () {
									return (
										console.warn(
											"THREE.WebGLRenderer: .getPrecision() is now .capabilities.precision."
										),
										this.capabilities.precision
									);
								},
								resetGLState: function () {
									return (
										console.warn(
											"THREE.WebGLRenderer: .resetGLState() is now .state.reset()."
										),
										this.state.reset()
									);
								},
								supportsFloatTextures: function () {
									return (
										console.warn(
											"THREE.WebGLRenderer: .supportsFloatTextures() is now .extensions.get( 'OES_texture_float' )."
										),
										this.extensions.get("OES_texture_float")
									);
								},
								supportsHalfFloatTextures: function () {
									return (
										console.warn(
											"THREE.WebGLRenderer: .supportsHalfFloatTextures() is now .extensions.get( 'OES_texture_half_float' )."
										),
										this.extensions.get("OES_texture_half_float")
									);
								},
								supportsStandardDerivatives: function () {
									return (
										console.warn(
											"THREE.WebGLRenderer: .supportsStandardDerivatives() is now .extensions.get( 'OES_standard_derivatives' )."
										),
										this.extensions.get("OES_standard_derivatives")
									);
								},
								supportsCompressedTextureS3TC: function () {
									return (
										console.warn(
											"THREE.WebGLRenderer: .supportsCompressedTextureS3TC() is now .extensions.get( 'WEBGL_compressed_texture_s3tc' )."
										),
										this.extensions.get("WEBGL_compressed_texture_s3tc")
									);
								},
								supportsCompressedTexturePVRTC: function () {
									return (
										console.warn(
											"THREE.WebGLRenderer: .supportsCompressedTexturePVRTC() is now .extensions.get( 'WEBGL_compressed_texture_pvrtc' )."
										),
										this.extensions.get("WEBGL_compressed_texture_pvrtc")
									);
								},
								supportsBlendMinMax: function () {
									return (
										console.warn(
											"THREE.WebGLRenderer: .supportsBlendMinMax() is now .extensions.get( 'EXT_blend_minmax' )."
										),
										this.extensions.get("EXT_blend_minmax")
									);
								},
								supportsVertexTextures: function () {
									return (
										console.warn(
											"THREE.WebGLRenderer: .supportsVertexTextures() is now .capabilities.vertexTextures."
										),
										this.capabilities.vertexTextures
									);
								},
								supportsInstancedArrays: function () {
									return (
										console.warn(
											"THREE.WebGLRenderer: .supportsInstancedArrays() is now .extensions.get( 'ANGLE_instanced_arrays' )."
										),
										this.extensions.get("ANGLE_instanced_arrays")
									);
								},
								enableScissorTest: function (t) {
									console.warn(
										"THREE.WebGLRenderer: .enableScissorTest() is now .setScissorTest()."
									),
										this.setScissorTest(t);
								},
								initMaterial: function () {
									console.warn(
										"THREE.WebGLRenderer: .initMaterial() has been removed."
									);
								},
								addPrePlugin: function () {
									console.warn(
										"THREE.WebGLRenderer: .addPrePlugin() has been removed."
									);
								},
								addPostPlugin: function () {
									console.warn(
										"THREE.WebGLRenderer: .addPostPlugin() has been removed."
									);
								},
								updateShadowMap: function () {
									console.warn(
										"THREE.WebGLRenderer: .updateShadowMap() has been removed."
									);
								},
								setFaceCulling: function () {
									console.warn(
										"THREE.WebGLRenderer: .setFaceCulling() has been removed."
									);
								},
								allocTextureUnit: function () {
									console.warn(
										"THREE.WebGLRenderer: .allocTextureUnit() has been removed."
									);
								},
								setTexture: function () {
									console.warn(
										"THREE.WebGLRenderer: .setTexture() has been removed."
									);
								},
								setTexture2D: function () {
									console.warn(
										"THREE.WebGLRenderer: .setTexture2D() has been removed."
									);
								},
								setTextureCube: function () {
									console.warn(
										"THREE.WebGLRenderer: .setTextureCube() has been removed."
									);
								},
								getActiveMipMapLevel: function () {
									return (
										console.warn(
											"THREE.WebGLRenderer: .getActiveMipMapLevel() is now .getActiveMipmapLevel()."
										),
										this.getActiveMipmapLevel()
									);
								},
							}),
							Object.defineProperties(Vl.prototype, {
								shadowMapEnabled: {
									get: function () {
										return this.shadowMap.enabled;
									},
									set: function (t) {
										console.warn(
											"THREE.WebGLRenderer: .shadowMapEnabled is now .shadowMap.enabled."
										),
											(this.shadowMap.enabled = t);
									},
								},
								shadowMapType: {
									get: function () {
										return this.shadowMap.type;
									},
									set: function (t) {
										console.warn(
											"THREE.WebGLRenderer: .shadowMapType is now .shadowMap.type."
										),
											(this.shadowMap.type = t);
									},
								},
								shadowMapCullFace: {
									get: function () {
										console.warn(
											"THREE.WebGLRenderer: .shadowMapCullFace has been removed. Set Material.shadowSide instead."
										);
									},
									set: function () {
										console.warn(
											"THREE.WebGLRenderer: .shadowMapCullFace has been removed. Set Material.shadowSide instead."
										);
									},
								},
								context: {
									get: function () {
										return (
											console.warn(
												"THREE.WebGLRenderer: .context has been removed. Use .getContext() instead."
											),
											this.getContext()
										);
									},
								},
								vr: {
									get: function () {
										return (
											console.warn(
												"THREE.WebGLRenderer: .vr has been renamed to .xr"
											),
											this.xr
										);
									},
								},
								gammaInput: {
									get: function () {
										return (
											console.warn(
												"THREE.WebGLRenderer: .gammaInput has been removed. Set the encoding for textures via Texture.encoding instead."
											),
											!1
										);
									},
									set: function () {
										console.warn(
											"THREE.WebGLRenderer: .gammaInput has been removed. Set the encoding for textures via Texture.encoding instead."
										);
									},
								},
								gammaOutput: {
									get: function () {
										return (
											console.warn(
												"THREE.WebGLRenderer: .gammaOutput has been removed. Set WebGLRenderer.outputEncoding instead."
											),
											!1
										);
									},
									set: function (t) {
										console.warn(
											"THREE.WebGLRenderer: .gammaOutput has been removed. Set WebGLRenderer.outputEncoding instead."
										),
											(this.outputEncoding = !0 === t ? pr : hr);
									},
								},
								toneMappingWhitePoint: {
									get: function () {
										return (
											console.warn(
												"THREE.WebGLRenderer: .toneMappingWhitePoint has been removed."
											),
											1
										);
									},
									set: function () {
										console.warn(
											"THREE.WebGLRenderer: .toneMappingWhitePoint has been removed."
										);
									},
								},
							}),
							Object.defineProperties(hl.prototype, {
								cullFace: {
									get: function () {
										console.warn(
											"THREE.WebGLRenderer: .shadowMap.cullFace has been removed. Set Material.shadowSide instead."
										);
									},
									set: function () {
										console.warn(
											"THREE.WebGLRenderer: .shadowMap.cullFace has been removed. Set Material.shadowSide instead."
										);
									},
								},
								renderReverseSided: {
									get: function () {
										console.warn(
											"THREE.WebGLRenderer: .shadowMap.renderReverseSided has been removed. Set Material.shadowSide instead."
										);
									},
									set: function () {
										console.warn(
											"THREE.WebGLRenderer: .shadowMap.renderReverseSided has been removed. Set Material.shadowSide instead."
										);
									},
								},
								renderSingleSided: {
									get: function () {
										console.warn(
											"THREE.WebGLRenderer: .shadowMap.renderSingleSided has been removed. Set Material.shadowSide instead."
										);
									},
									set: function () {
										console.warn(
											"THREE.WebGLRenderer: .shadowMap.renderSingleSided has been removed. Set Material.shadowSide instead."
										);
									},
								},
							}),
							Object.defineProperties(xr.prototype, {
								wrapS: {
									get: function () {
										return (
											console.warn(
												"THREE.WebGLRenderTarget: .wrapS is now .texture.wrapS."
											),
											this.texture.wrapS
										);
									},
									set: function (t) {
										console.warn(
											"THREE.WebGLRenderTarget: .wrapS is now .texture.wrapS."
										),
											(this.texture.wrapS = t);
									},
								},
								wrapT: {
									get: function () {
										return (
											console.warn(
												"THREE.WebGLRenderTarget: .wrapT is now .texture.wrapT."
											),
											this.texture.wrapT
										);
									},
									set: function (t) {
										console.warn(
											"THREE.WebGLRenderTarget: .wrapT is now .texture.wrapT."
										),
											(this.texture.wrapT = t);
									},
								},
								magFilter: {
									get: function () {
										return (
											console.warn(
												"THREE.WebGLRenderTarget: .magFilter is now .texture.magFilter."
											),
											this.texture.magFilter
										);
									},
									set: function (t) {
										console.warn(
											"THREE.WebGLRenderTarget: .magFilter is now .texture.magFilter."
										),
											(this.texture.magFilter = t);
									},
								},
								minFilter: {
									get: function () {
										return (
											console.warn(
												"THREE.WebGLRenderTarget: .minFilter is now .texture.minFilter."
											),
											this.texture.minFilter
										);
									},
									set: function (t) {
										console.warn(
											"THREE.WebGLRenderTarget: .minFilter is now .texture.minFilter."
										),
											(this.texture.minFilter = t);
									},
								},
								anisotropy: {
									get: function () {
										return (
											console.warn(
												"THREE.WebGLRenderTarget: .anisotropy is now .texture.anisotropy."
											),
											this.texture.anisotropy
										);
									},
									set: function (t) {
										console.warn(
											"THREE.WebGLRenderTarget: .anisotropy is now .texture.anisotropy."
										),
											(this.texture.anisotropy = t);
									},
								},
								offset: {
									get: function () {
										return (
											console.warn(
												"THREE.WebGLRenderTarget: .offset is now .texture.offset."
											),
											this.texture.offset
										);
									},
									set: function (t) {
										console.warn(
											"THREE.WebGLRenderTarget: .offset is now .texture.offset."
										),
											(this.texture.offset = t);
									},
								},
								repeat: {
									get: function () {
										return (
											console.warn(
												"THREE.WebGLRenderTarget: .repeat is now .texture.repeat."
											),
											this.texture.repeat
										);
									},
									set: function (t) {
										console.warn(
											"THREE.WebGLRenderTarget: .repeat is now .texture.repeat."
										),
											(this.texture.repeat = t);
									},
								},
								format: {
									get: function () {
										return (
											console.warn(
												"THREE.WebGLRenderTarget: .format is now .texture.format."
											),
											this.texture.format
										);
									},
									set: function (t) {
										console.warn(
											"THREE.WebGLRenderTarget: .format is now .texture.format."
										),
											(this.texture.format = t);
									},
								},
								type: {
									get: function () {
										return (
											console.warn(
												"THREE.WebGLRenderTarget: .type is now .texture.type."
											),
											this.texture.type
										);
									},
									set: function (t) {
										console.warn(
											"THREE.WebGLRenderTarget: .type is now .texture.type."
										),
											(this.texture.type = t);
									},
								},
								generateMipmaps: {
									get: function () {
										return (
											console.warn(
												"THREE.WebGLRenderTarget: .generateMipmaps is now .texture.generateMipmaps."
											),
											this.texture.generateMipmaps
										);
									},
									set: function (t) {
										console.warn(
											"THREE.WebGLRenderTarget: .generateMipmaps is now .texture.generateMipmaps."
										),
											(this.texture.generateMipmaps = t);
									},
								},
							}),
							Object.defineProperties(zd.prototype, {
								load: {
									value: function (t) {
										console.warn(
											"THREE.Audio: .load has been deprecated. Use THREE.AudioLoader instead."
										);
										const e = this;
										return (
											new Md().load(t, function (t) {
												e.setBuffer(t);
											}),
											this
										);
									},
								},
								startTime: {
									set: function () {
										console.warn(
											"THREE.Audio: .startTime is now .play( delay )."
										);
									},
								},
							}),
							(Hd.prototype.getData = function () {
								return (
									console.warn(
										"THREE.AudioAnalyser: .getData() is now .getFrequencyData()."
									),
									this.getFrequencyData()
								);
							}),
							(as.prototype.updateCubeMap = function (t, e) {
								return (
									console.warn(
										"THREE.CubeCamera: .updateCubeMap() is now .update()."
									),
									this.update(t, e)
								);
							}),
							(vr.crossOrigin = void 0),
							(vr.loadTexture = function (t, e, n, i) {
								console.warn(
									"THREE.ImageUtils.loadTexture has been deprecated. Use THREE.TextureLoader() instead."
								);
								const r = new Ru();
								r.setCrossOrigin(this.crossOrigin);
								const o = r.load(t, n, void 0, i);
								return e && (o.mapping = e), o;
							}),
							(vr.loadTextureCube = function (t, e, n, i) {
								console.warn(
									"THREE.ImageUtils.loadTextureCube has been deprecated. Use THREE.CubeTextureLoader() instead."
								);
								const r = new qu();
								r.setCrossOrigin(this.crossOrigin);
								const o = r.load(t, n, void 0, i);
								return e && (o.mapping = e), o;
							}),
							(vr.loadCompressedTexture = function () {
								console.error(
									"THREE.ImageUtils.loadCompressedTexture has been removed. Use THREE.DDSLoader instead."
								);
							}),
							(vr.loadCompressedTextureCube = function () {
								console.error(
									"THREE.ImageUtils.loadCompressedTextureCube has been removed. Use THREE.DDSLoader instead."
								);
							}),
							"undefined" != typeof __THREE_DEVTOOLS__ &&
								__THREE_DEVTOOLS__.dispatchEvent(
									new CustomEvent("register", { detail: { revision: "119" } })
								);
						var cf = n(276),
							lf = n.n(cf);
						function hf(t, e, n, i, r) {
							t.faceVertexUvs[0].forEach(function (t, o) {
								t.forEach(function (t, o) {
									(t.x = (t.x + i) * e), (t.y = (t.y + r) * n);
								});
							});
						}
						var pf,
							uf = (function () {
								function t() {
									var t = this;
									(this.containerElement = document.createElement("div")),
										document.body.appendChild(this.containerElement),
										(this.scene = new ao()),
										(this.camera = new rs(
											45,
											window.innerWidth / window.innerHeight,
											1,
											2e5
										)),
										(this.camera.position.z = -1e3);
									var e = 1 === window.devicePixelRatio;
									(this.renderer = new Vl({ antialias: e })),
										this.renderer.setClearColor(0),
										this.renderer.setPixelRatio(window.devicePixelRatio),
										this.renderer.setSize(
											window.innerWidth,
											window.innerHeight
										),
										this.containerElement.appendChild(this.renderer.domElement),
										window.addEventListener("resize", function (e) {
											t.handleResize(e);
										});
								}
								return (
									(t.prototype.startRendering = function () {
										this.update();
									}),
									(t.prototype.render = function () {
										this.renderer.render(this.scene, this.camera);
									}),
									(t.prototype.onTick = function () {}),
									(t.prototype.handleResize = function (t) {
										(this.camera.aspect =
											window.innerWidth / window.innerHeight),
											this.camera.updateProjectionMatrix(),
											this.renderer.setSize(
												window.innerWidth,
												window.innerHeight
											);
									}),
									(t.prototype.update = function () {
										requestAnimationFrame(this.update.bind(this)),
											this.onTick(),
											this.render();
									}),
									t
								);
							})(),
							df =
								((pf = function (t, e) {
									return (pf =
										Object.setPrototypeOf ||
										({ __proto__: [] } instanceof Array &&
											function (t, e) {
												t.__proto__ = e;
											}) ||
										function (t, e) {
											for (var n in e)
												Object.prototype.hasOwnProperty.call(e, n) &&
													(t[n] = e[n]);
										})(t, e);
								}),
								function (t, e) {
									if ("function" != typeof e && null !== e)
										throw new TypeError(
											"Class extends value " +
												String(e) +
												" is not a constructor or null"
										);
									function n() {
										this.constructor = t;
									}
									pf(t, e),
										(t.prototype =
											null === e
												? Object.create(e)
												: ((n.prototype = e.prototype), new n()));
								});
						Ei.registerPlugin(lf());
						var mf = (function (t) {
								function e() {
									var e = t.call(this) || this;
									return (
										(e.HELPER_ZERO = new zr(0, 0, 0)),
										(e.CANVAS_W = 250),
										(e.CANVAS_H = 40),
										(e._matrixLength = 8),
										(e._particleList = []),
										(e._wordIndex = 0),
										(e._hue = 0.6),
										e
									);
								}
								return (
									df(e, t),
									(e.prototype.setup = function () {}),
									(e.prototype.createWorld = function () {
										(this.camera.far = 1e5),
											(this.camera.near = 1),
											(this.camera.position.z = 5e3),
											this.camera.lookAt(this.HELPER_ZERO);
										var t = new La(
											new gs(5e4, 5e4, 1, 1),
											new ra({
												map: new Ru().load(
													"data:image/jpeg;base64,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MrMzMwszMrIzMzNrM2sLKyazKzNrMzMiijMrMzMzAjCzMisrMjMzMzMzMzMjN1lBkFFZtYGZmZmRkZmYGZmYUUOsjMwdZmRmZGZgZmZmRmZWZAZm6jAyMzMzAyMjAzMzB1NRmZmYGRmYOozMwMjMwIzMjdZtBEBmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmFmFUZmZmFmZWZkZmFWZmZmZWZmZWZmFmZWZmZmZmZWZmZmZWZkZmFmZWZmBmFWDrKHVZmZlZmZmZmZlZmYWZmZmZl1mZmZmZhbVZmZmZdZmZmZmZmYWYWVm1mZmZmZmZmXWZGFlZmZmZlFmZmZmFtUGYWZmZm1mZmZRRmXWZGZWZNZmUWZmZkVlRkVmYWZmVmYE1mVGRhZWZmRWZmZGZQZBRQVGRhZWRg6zMzN1tYGYUZmZmYGZmZkQGZmZus2gyCigzMzN1mZGDrI3WYGZkRmYGZkYOsmszAyMzMjB1mZkBmZGZmBkZmBmZGBkZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmFmZdYeojKzMwqzMzMjMwqzMzMwdVmZhZmVmZmZmZhVmbWZtZlZmZmZl1A6yt1WZmBWZtYWYG1hVmZmZmZmVmZmbWZtZl1mZmZhZhZWZmZmZmZmVmZmZmZhZmZWZmZhZmZmZmZRZmZmZmZmZmbVFmZlZkZlZmZGZmFtVmZmZmZmZmYWVmZkZlZkZmZmYWVmZkYGZmZmYes2gzCiszMzMzAzMzMjMzMyt1k1kZus2gzCzMjMzAzMzMzAyMjMzAzMzQUUGRmZkZmYOsmgzMzMzAiMzAzMzAiMzMzMyB1m0GR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ZmZlZmZmZlZmZm1mZmZhZmZWZmZhZmZmZmVmZmZmZmZmZmZhZmZmZWZmbWZmZmFlZmZmZtZmZmZmZmZm1hZWZmZmRmVmRmZmZmZmZmZm6zCyszMjMzMzAzMzMzMzMjMrMjAzCzMzN1mDqMzM3WbWZAZmZmZmZmRhZQ62o3WYEZmZmZmQGZuszMwIzdZGZgZmZmRAZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmVmZmZmZmZhVmZmZmZmVmZmZGVmRmVmZmZhZmVmZmZmZmZmZmVmZmZmZhZWZhZgZhZgZhVmbWZmZmZmZmZmZmFlZmZmZmZmZmZmZmZmZmZmZmZlFlZmZmZmZmZGZmZkZlZkZlZmZmFmBmZmFFZmBmZmZkZmZmZGZmZmZlbrIDMzMzMyMDMLMDMzMzMyMzM3WYGRuszMzIwMjMzIzKwMzdRgZGZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmVmZmZmZhVmZmZmbWZWZmZmZkZmZmZmZWZmZmZmZmFWZmZmZmZlFmZmZmZmZdZkZmZlZmZmZm1hZWZmZmZmZmZmZmZmZmZhZWZmZmZmZmRmZmZmVmZmRmVmRmZmZmZmZWZGZhZWRmZmZgZmZmZmZmZmZmTWZmZmBtZmZmZkZmRmVmRmYGZuozMzMwMzMjMwMzMzIwKjIzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzKzMzMzMwqzMzMzMzMzNrMrMzMzMzMyMrMjMrMzM2sLKzMzMzMzMzMLMzazKzMzMzMzMrMzMzMzMjMrMzMzMwszNqszM2szMLMDazMzMzMzIzKzIzMzMzMzMzMzMzNrCyszAyN1m1kZmZmZmYGZmYWVkRmYGZmZmZmZkZmYGZmRmZuswdZmZmZmRgZGZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmVmbWZmZtZmZmYVZmZmZmZmZmZlZmZmZmZmZmZmZmYVZkZlZkZlZm1mZhZWZmZmZmZmZmZmZmZmZhZmZmZmZQZBZmZgZmZhRQVGRWVGZmRmZmZmZmZWZm6zazIzKzIzMzMzMCMzMLKzMzMCMLMHW1mZGZmZmZgZmZmRmZAZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZn/2Q=="
												),
											})
										);
										this.scene.add(t), (this._bg = t);
										var e = new td(16777215);
										e.position.set(0, 1, 1).normalize(),
											this.scene.add(e),
											(this._wrap = new oo()),
											this.scene.add(this._wrap);
									}),
									(e.prototype.createParticle = function (t) {
										var e = 1 / this._matrixLength,
											n = 1 / this._matrixLength;
										this._particleList = [];
										for (var i = 0; i < this.CANVAS_W; i++)
											for (var r = 0; r < this.CANVAS_H; r++) {
												var o = Math.floor(this._matrixLength * Math.random()),
													a = Math.floor(this._matrixLength * Math.random()),
													s = new fs(40, 40, 1, 1);
												hf(s, e, n, o, a);
												var c = new Np({
													color: 16777215,
													map: t,
													transparent: !0,
													side: 2,
												});
												c.blending = 2;
												var l = new La(s, c);
												this._wrap.add(l), this._particleList.push(l);
											}
									}),
									(e.prototype.createLetter = function (t, e) {
										var n = t.getContext("2d");
										if (!n) throw new Error("contextを取得失敗しました");
										this._particleList.forEach(function (t) {
											t.visible = !1;
										});
										for (
											var i = n.getImageData(
													0,
													0,
													this.CANVAS_W,
													this.CANVAS_H
												).data,
												r = [],
												o = 0;
											o < this.CANVAS_W;
											o++
										) {
											r[o] = [];
											for (var a = 0; a < this.CANVAS_H; a++) {
												var s = 0 === i[4 * (o + a * this.CANVAS_W) + 3];
												r[o][a] = s;
											}
										}
										var c = 0,
											l = this.CANVAS_W * this.CANVAS_H;
										for (o = 0; o < this.CANVAS_W; o++)
											for (a = 0; a < this.CANVAS_H; a++)
												if (!0 !== r[o][a]) {
													var h = this._particleList[c];
													h.material.color.setHSL(
														this._hue + 0.2 * ((o * t.height) / l - 0.5),
														0.5,
														0.6 + 0.4 * Math.random()
													),
														(h.material.blending = 2),
														this._wrap.add(h);
													var p = {
															x: 30 * (o - t.width / 2),
															y: 30 * (t.height / 2 - a),
															z: 0,
														},
														u = {
															x: 2e3 * (Math.random() - 0.5) - 500,
															y: 1e3 * (Math.random() - 0.5),
															z: 1e4,
														};
													(h.position.x = u.x),
														(h.position.y = u.y),
														(h.position.z = u.z);
													var d = { z: 10 * Math.PI * (Math.random() - 0.5) };
													h.rotation.z = d.z;
													var m =
														3 * kn.easeInOut(c / 1600) + 1.5 * Math.random();
													e.to(h.rotation, 6, { z: 0, ease: kn.easeInOut }, m),
														(h.visible = !1),
														e.set(h, { visible: !0 }, m),
														e.to(
															h.position,
															7,
															{
																motionPath: {
																	path: [
																		u,
																		{
																			x: (0 + p.x) / 2 + 300,
																			y: (u.y + p.y) / 2 + 500 * Math.random(),
																			z: (u.z + p.z) / 2,
																		},
																		p,
																	],
																},
																delay: m / 1,
																ease: wn.easeInOut,
															},
															0
														),
														c++;
												}
										(this._wrap.position.z = -5e3),
											e.to(
												this._wrap.position,
												12,
												{ z: 6e3, ease: Un.easeIn },
												0
											);
									}),
									e
								);
							})(uf),
							ff = n(933),
							gf = "Source Code Pro",
							Sf = "FontAwesome",
							yf = n(379),
							Vf = n.n(yf),
							qf = n(401);
						Vf()(qf.Z, { insert: "head", singleton: !1 }), qf.Z.locals;
						var Rf = (function () {
							var t = function (e, n) {
								return (t =
									Object.setPrototypeOf ||
									({ __proto__: [] } instanceof Array &&
										function (t, e) {
											t.__proto__ = e;
										}) ||
									function (t, e) {
										for (var n in e)
											Object.prototype.hasOwnProperty.call(e, n) &&
												(t[n] = e[n]);
									})(e, n);
							};
							return function (e, n) {
								if ("function" != typeof n && null !== n)
									throw new TypeError(
										"Class extends value " +
											String(n) +
											" is not a constructor or null"
									);
								function i() {
									this.constructor = e;
								}
								t(e, n),
									(e.prototype =
										null === n
											? Object.create(n)
											: ((i.prototype = n.prototype), new i()));
							};
						})();
						window.addEventListener("DOMContentLoaded", function () {
							return (
								(t = void 0),
								(e = void 0),
								(i = function () {
									return (function (t, e) {
										var n,
											i,
											r,
											o,
											a = {
												label: 0,
												sent: function () {
													if (1 & r[0]) throw r[1];
													return r[1];
												},
												trys: [],
												ops: [],
											};
										return (
											(o = { next: s(0), throw: s(1), return: s(2) }),
											"function" == typeof Symbol &&
												(o[Symbol.iterator] = function () {
													return this;
												}),
											o
										);
										function s(o) {
											return function (s) {
												return (function (o) {
													if (n)
														throw new TypeError(
															"Generator is already executing."
														);
													for (; a; )
														try {
															if (
																((n = 1),
																i &&
																	(r =
																		2 & o[0]
																			? i.return
																			: o[0]
																			? i.throw ||
																			  ((r = i.return) && r.call(i), 0)
																			: i.next) &&
																	!(r = r.call(i, o[1])).done)
															)
																return r;
															switch (
																((i = 0), r && (o = [2 & o[0], r.value]), o[0])
															) {
																case 0:
																case 1:
																	r = o;
																	break;
																case 4:
																	return a.label++, { value: o[1], done: !1 };
																case 5:
																	a.label++, (i = o[1]), (o = [0]);
																	continue;
																case 7:
																	(o = a.ops.pop()), a.trys.pop();
																	continue;
																default:
																	if (
																		!(
																			(r =
																				(r = a.trys).length > 0 &&
																				r[r.length - 1]) ||
																			(6 !== o[0] && 2 !== o[0])
																		)
																	) {
																		a = 0;
																		continue;
																	}
																	if (
																		3 === o[0] &&
																		(!r || (o[1] > r[0] && o[1] < r[3]))
																	) {
																		a.label = o[1];
																		break;
																	}
																	if (6 === o[0] && a.label < r[1]) {
																		(a.label = r[1]), (r = o);
																		break;
																	}
																	if (r && a.label < r[2]) {
																		(a.label = r[2]), a.ops.push(o);
																		break;
																	}
																	r[2] && a.ops.pop(), a.trys.pop();
																	continue;
															}
															o = e.call(t, a);
														} catch (t) {
															(o = [6, t]), (i = 0);
														} finally {
															n = r = 0;
														}
													if (5 & o[0]) throw o[1];
													return { value: o[0] ? o[1] : void 0, done: !0 };
												})([o, s]);
											};
										}
									})(this, function (t) {
										switch (t.label) {
											case 0:
												return [
													4,
													new Promise(function (t, e) {
														ff.load({
															custom: {
																families: [gf, Sf],
																urls: [
																	"https://fonts.googleapis.com/css?family=Source+Code+Pro:600",
																	"https://netdna.bootstrapcdn.com/font-awesome/4.0.3/css/font-awesome.css",
																],
																testStrings: { FontAwesome: "" },
															},
															active: function () {
																t();
															},
															inactive: function () {
																e();
															},
														});
													}),
												];
											case 1:
												return t.sent(), new Mf(), [2];
										}
									});
								}),
								new ((n = void 0) || (n = Promise))(function (r, o) {
									function a(t) {
										try {
											c(i.next(t));
										} catch (t) {
											o(t);
										}
									}
									function s(t) {
										try {
											c(i.throw(t));
										} catch (t) {
											o(t);
										}
									}
									function c(t) {
										var e;
										t.done
											? r(t.value)
											: ((e = t.value),
											  e instanceof n
													? e
													: new n(function (t) {
															t(e);
													  })).then(a, s);
									}
									c((i = i.apply(t, e || [])).next());
								})
							);
							var t, e, n, i;
						});
						var Mf = (function (t) {
							function e() {
								var e = t.call(this) || this;
								return (
									(e.WORD_LIST = ["WebGL", "HTML5", "THREE"]),
									e.setup(),
									e.createLogo(),
									e.startRendering(),
									e
								);
							}
							return (
								Rf(e, t),
								(e.prototype.onTick = function () {
									t.prototype.onTick.call(this),
										this.camera.lookAt(this.HELPER_ZERO);
									var e = this.camera.position.clone();
									e.negate(),
										e.normalize(),
										e.multiplyScalar(25e3),
										this._bg.position.copy(e),
										this._bg.lookAt(this.camera.position);
								}),
								(e.prototype.setup = function () {
									this.createWorld();
									var t = 256,
										e = document.createElement("canvas");
									e.setAttribute("width", t * this._matrixLength + "px"),
										e.setAttribute("height", t * this._matrixLength + "px");
									var n = e.getContext("2d");
									if (!n) throw new Error();
									for (
										var i = this._matrixLength * this._matrixLength, r = 0;
										r < i;
										r++
									) {
										var o = String.fromCharCode(61730 + r),
											a = t * (r % this._matrixLength) + 128,
											s = t * Math.floor(r / this._matrixLength) + 128;
										(n.fillStyle = "white"),
											(n.font = "200px " + Sf),
											(n.textAlign = "center"),
											(n.textBaseline = "middle"),
											n.fillText(o, a, s);
									}
									var c = new Rh(e);
									this.createParticle(c);
									var l = (function () {
										for (var t = new Ya(), e = 1e4, n = 0; n < 5e4; n++)
											t.vertices.push(
												new zr(
													e * (Math.random() - 0.5),
													e * (Math.random() - 0.5),
													e * (Math.random() - 0.5)
												)
											);
										return new Sh(
											t,
											new uh({
												size: 20,
												color: 6710886,
												blending: 2,
												transparent: !0,
												depthTest: !1,
												map: new Ru().load(
													"data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAACAAAAAgCAYAAABzenr0AAADLUlEQVRYCcXX51JbQRCEUeOc/f6v6ZzxHKFPLAoI84epmrp7985294QVxcXl5eWjh7Sn9yB/MWcej19sXQb87/iP8f+yiztWAOmzcYL5k/F9AX9m7/fWf83zTmLOVeD5AHECWieiKpR95D8nlhPcepbH7TYBL+dI/mrWRCRkrQIBZY9Q5vzb+PdxQj2P2ikBCPnrxb0TRMQpAYiRIa9lVcregR0TgATZm/G3W7cmxn5VaA6qQNkjEkNAMbPcDOpBJfYF6DMByJC/H3+3XSfC97IziATov8FD8HUcDmzZs+bETSF0Z+cEICeCE0TYOQFlHznSZoTQkwIc5PW+FqwC7NUGVagCXTvlXzNHXnXE5LsrulYAYFduX4Ts11b4LlaWlbXBWzNH2GxojzN4jgogJgENYreganyYGELsq1YCAOp9CZX5eivEwy9mltcvPvqwirBHSGKIQE6Eitg35forO5mxSo5cDJyVHIf3TRVSIxNgiUgIUO5Abel2qII4hLJnSk5M7XC2rMPGU5s2APO++11PiKBVUECEyAq5athHyvS6TO2vhOHB72/ILK+VtHnb0+EEAkeiLZGV2UpyG94cvRbgh+KcGyzenZb5l3FPbbBfzDks3zcmE9aBCIBF1FCt16meO98M6L3BEpeohIUHP65ZXvXJM2IH8oCAATZYiJWc+a7swJF/HvddnHjnuLgwE4RvY1XAAVMuwAHvHPA61cUDNnD6DUws8k/j2kJEZ8NahdjbWIBeVvJIgSISh4yJ8931SgBwpMhVwtPZKiIeaSJmeWWrgMolENh6pSKXrTjftcKU66m9ziViFSI+AWJ3tgoQADTwrtdKLvvinE2AfcAylTXyj9tn1UiE8ztbBdhUIiD2u9ez3PS5LP0QJe6UgKpgJhpOuPBv2DEBMubAmbI3H0BqDYEJcBOAy06mqpCI/xIw5zYViFx/gZc98IZyX0DtITIR+4M4n27afgX6CgB52dffsq9FawWqkipUCWLyWR7aKQEiHVwFuHbrX7batApNRO3wPOj77O3swf8zuquAneJZaEPZ14KqcOOKrYdOre8j4BTWvfZl8qD2D7ghcomuE8XXAAAAAElFTkSuQmCC"
												),
											})
										);
									})();
									this.scene.add(l);
								}),
								(e.prototype.createLogo = function () {
									var t = this,
										e = (function (t, e, n, i) {
											var r = document.createElement("canvas");
											r.setAttribute("width", n + "px"),
												r.setAttribute("height", i + "px");
											var o = r.getContext("2d");
											if (!o) throw new Error();
											return (
												(o.fillStyle = "white"),
												(o.font = "42px " + gf),
												(o.textAlign = "center"),
												(o.textBaseline = "top"),
												o.fillText(t, n / 2, 0),
												r
											);
										})(
											this.WORD_LIST[this._wordIndex],
											0,
											this.CANVAS_W,
											this.CANVAS_H
										);
									this._wordIndex++,
										this._wordIndex >= this.WORD_LIST.length &&
											(this._wordIndex = 0);
									var n = Ei.timeline({
										onComplete: function () {
											var e = Ei.timeline();
											e.to("#coverBlack", 1, { css: { opacity: 1 } }),
												e.call(function () {
													t.createLogo();
												});
										},
									});
									this.createLetter(e, n),
										Math.random() < 0.3
											? (n.set(
													this.camera.position,
													{ x: 200, y: -200, z: 1e3 },
													0
											  ),
											  n.to(
													this.camera.position,
													{
														x: 0,
														y: 0,
														z: 5e3,
														duration: 14,
														ease: Un.easeInOut,
													},
													0
											  ),
											  n.set(this.camera, { fov: 90 }, 0),
											  n.to(
													this.camera,
													{ fov: 45, duration: 14, ease: Un.easeInOut },
													0
											  ))
											: Math.random() < 0.5
											? (n.set(
													this.camera.position,
													{ x: 100, y: 1e3, z: 1e3 },
													0
											  ),
											  n.to(
													this.camera.position,
													{
														x: 0,
														y: 0,
														z: 5e3,
														duration: 14,
														ease: Un.easeInOut,
													},
													0
											  ))
											: (n.set(
													this.camera.position,
													{ x: -3e3, y: 3e3, z: 0 },
													0
											  ),
											  n.to(
													this.camera.position,
													{
														x: 0,
														y: 0,
														z: 5e3,
														duration: 15,
														ease: Un.easeInOut,
													},
													0
											  )),
										n.to(
											"#coverBlack",
											{ css: { opacity: 0 }, duration: 1 },
											0
										),
										Math.random() < 0.3
											? (n.timeScale(3),
											  n.call(
													function () {
														Ei.to(n, 1, {
															timeScale: 0.05,
															ease: kn.easeInOut,
														}),
															Ei.to(n, 0.5, {
																timeScale: 3,
																delay: 3.5,
																ease: kn.easeInOut,
															}),
															Ei.to(n, 0.5, {
																timeScale: 0.05,
																delay: 4,
																ease: kn.easeInOut,
															}),
															Ei.to(n, 2, {
																timeScale: 5,
																delay: 9,
																ease: kn.easeIn,
															});
													},
													[],
													3.5
											  ))
											: Math.random() < 0.5
											? (n.timeScale(6),
											  Ei.to(n, 4, { timeScale: 0.005, ease: kn.easeOut }),
											  Ei.to(n, 4, {
													timeScale: 2,
													ease: kn.easeIn,
													delay: 5,
											  }))
											: n.timeScale(1),
										this._bg.material.color.setHSL(this._hue, 1, 0.5),
										(this._hue += 0.2),
										this._hue >= 1 && (this._hue = 0);
								}),
								e
							);
						})(mf);
					})();
			})();
		</script>
	</body>
</html>
